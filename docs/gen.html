<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gen API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># FABGen - The FABulous binding Generator for CPython and Lua
#       Copyright (C) 2018 Emmanuel Julien

from pypeg2 import re, flag, name, Plain, optional, attr, K, parse, Keyword, Enum, List, csl, some, maybe_some
from collections import OrderedDict
import zlib
import copy


#
api_prefix = &#39;gen&#39;

def apply_api_prefix(symbol):
        return &#39;%s_%s&#39; % (api_prefix, symbol) if api_prefix else symbol


def get_fabgen_api():
                return &#39;&#39;&#39;\
// FABgen .h

#pragma once

enum OwnershipPolicy { NonOwning, Copy, Owning };
&#39;&#39;&#39;


#converts a function to its C representation
def get_fully_qualified_function_signature(func):
        out = &#39;&#39;
        #Get return type
        if hasattr(func, &#39;void_rval&#39;): # void return type
                out += &#39;void&#39;
        else:
                out += str(func.rval) # return type
        #Get all arguments from the Ctype function
        if hasattr(func, &#39;args&#39;):
                args = [str(arg) for arg in func.args]
                out += &#39;(%s)&#39; % &#39;, &#39;.join(args)
        else: #No arguments
                out += &#39;()&#39;

        return out #return a string of the form rtype [arg1,arg2...]


def get_fully_qualified_ctype_name(ctype):
        parts = []

        if ctype.const:
                parts.append(&#39;const&#39;)
        if ctype.signed:
                parts.append(&#39;signed&#39;)
        if ctype.unsigned:
                parts.append(&#39;unsigned&#39;)

        if hasattr(ctype, &#39;template&#39;):
                if hasattr(ctype.template, &#39;args&#39;):
                        parts.append(ctype.name + &#39;&lt;%s&gt;&#39; % &#39;, &#39;.join([str(arg) for arg in ctype.template.args]))
                elif hasattr(ctype.template, &#39;function&#39;):
                        parts.append(ctype.name + &#39;&lt;%s&gt;&#39; % get_fully_qualified_function_signature(ctype.template.function))
        else:
                parts.append(repr(ctype.scoped_typename))

        if ctype.const_ref:
                parts.append(&#39;const&#39;)
        if hasattr(ctype, &#39;ref&#39;):
                parts.append(ctype.ref)

        return &#39; &#39;.join(parts)


def ref_to_string(ref):
        parts = []
        for e in ref:
                if ref == &#39;*&#39;:
                        parts.append(&#39;ptr&#39;)
                elif ref == &#39;&amp;&#39;:
                        parts.append(&#39;ref&#39;)
        return &#39;_&#39;.join(parts)


def ctype_to_plain_string(ctype):
        parts = []

        if ctype.const:
                parts.append(&#39;const&#39;)
        if ctype.signed:
                parts.append(&#39;signed&#39;)
        if ctype.unsigned:
                parts.append(&#39;unsigned&#39;)

        _ctype = ctype.scoped_typename.parts[-1]  # ignore namespace entries (only consider last type in chain)
        _name = _ctype.name.replace(&#39;::&#39;, &#39;_&#39;).replace(&#39;:&#39;, &#39;_&#39;)

        parts.append(_name)

        if hasattr(_ctype, &#39;template&#39;):
                if hasattr(_ctype.template, &#39;function&#39;):
                        function = _ctype.template.function

                        parts.append(&#39;returning&#39;)

                        if hasattr(function, &#39;void_rval&#39;):
                                parts.append(&#39;void&#39;)
                        else:
                                parts.append(ctype_to_plain_string(function.rval))

                        if hasattr(function, &#39;args&#39;):
                                parts.append(&#39;taking&#39;)
                                for arg in function.args:
                                        parts.append(ctype_to_plain_string(arg))
                else:
                        parts.append(&#39;of_&#39; + &#39;_and_&#39;.join([ctype_to_plain_string(arg) for arg in _ctype.template.args]))

        if ctype.const_ref:
                parts.append(&#39;const&#39;)
        if hasattr(ctype, &#39;ref&#39;):
                parts.append(ref_to_string(ctype.ref))

        return &#39;_&#39;.join(parts)


def get_ctype_default_bound_name(ctype):
        ctype = copy.deepcopy(ctype)
        ctype.scoped_typename.explicit_global = False
        return ctype_to_plain_string(ctype)


#
symbol_clean_rules = OrderedDict()

symbol_clean_rules[&#39;::&#39;] = &#39;__&#39;  # namespace

symbol_clean_rules[&#39;+=&#39;] = &#39;inplace_add&#39;
symbol_clean_rules[&#39;*=&#39;] = &#39;inplace_mul&#39;
symbol_clean_rules[&#39;/=&#39;] = &#39;inplace_div&#39;
symbol_clean_rules[&#39;-=&#39;] = &#39;inplace_sub&#39;

symbol_clean_rules[&#39;+&#39;] = &#39;add&#39;
symbol_clean_rules[&#39;*&#39;] = &#39;mul&#39;
symbol_clean_rules[&#39;/&#39;] = &#39;div&#39;
symbol_clean_rules[&#39;-&#39;] = &#39;sub&#39;

symbol_clean_rules[&#39;||&#39;] = &#39;logicor&#39;
symbol_clean_rules[&#39;&amp;&amp;&#39;] = &#39;logicand&#39;
symbol_clean_rules[&#39;|&#39;] = &#39;pipe&#39;
symbol_clean_rules[&#39;&amp;&#39;] = &#39;and&#39;

symbol_clean_rules[&#39;&lt;&#39;] = &#39;lt&#39;
symbol_clean_rules[&#39;&lt;=&#39;] = &#39;le&#39;
symbol_clean_rules[&#39;==&#39;] = &#39;eq&#39;
symbol_clean_rules[&#39;!=&#39;] = &#39;ne&#39;
symbol_clean_rules[&#39;&gt;&#39;] = &#39;gt&#39;
symbol_clean_rules[&#39;&gt;=&#39;] = &#39;ge&#39;


def strip_namespace(name):
        parts = name.split(&#39;::&#39;)
        return parts[-1] if len(parts) &gt; 1 else name


def get_clean_symbol_name(name):
        &#34;&#34;&#34; Return a string cleaned so that it may be used as a valid symbol name in the generator output.&#34;&#34;&#34;

        parts = name.split(&#39; &#39;)

        def clean_symbol_name_part(part):
                for f_o, f_d in symbol_clean_rules.items():
                        part = part.replace(f_o, f_d)
                return part

        parts = [clean_symbol_name_part(part) for part in parts]
        return &#39;_&#39;.join(parts)


def get_symbol_default_bound_name(name):
        if isinstance(name, str):  # no namespace
                name = strip_namespace(name)
        else:
                name = name.naked_name()

        return get_clean_symbol_name(name)


def clean_name_with_title(name):
        new_name = &#34;&#34;
        if &#34;_&#34; in name:
                # redo a special string.title()
                next_is_forced_uppercase = True
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;]:
                                new_name += c
                        elif c in [&#34;_&#34;, &#34;-&#34;]:
                                next_is_forced_uppercase = True
                        else:
                                if next_is_forced_uppercase:
                                        next_is_forced_uppercase = False
                                        new_name += c.capitalize()
                                else:
                                        new_name += c
        else:
                # make sur the first letter is captialize
                first_letter_checked = False
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;] or first_letter_checked:
                                new_name += c
                        elif not first_letter_checked:
                                first_letter_checked = True
                                new_name += c.capitalize()
        return new_name.strip().replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;)

#
typename = re.compile(r&#34;(_|[A-z])[A-z0-9_]*&#34;)
ref_re = re.compile(r&#34;[&amp;*]+&#34;)

#
class _CType:
        def __repr__(self):
                return get_fully_qualified_ctype_name(self)

        def get_ref(self):
                return (self.ref if hasattr(self, &#39;ref&#39;) else &#39;&#39;)

        def add_ref(self, ref):
                t = copy.deepcopy(self)
                if hasattr(self, &#39;ref&#39;):
                        t.ref += ref
                else:
                        setattr(t, &#39;ref&#39;, ref)
                return t

        def is_pointer(self):
                return self.get_ref() == &#39;*&#39;

        def is_const(self):
                if self.get_ref() == &#39;&#39;:
                        return self.const
                return self.const_ref

        def non_const(self):
                t = copy.deepcopy(self)
                t.const = False
                return t

        def dereference_once(self):
                t = copy.deepcopy(self)
                if hasattr(t, &#39;ref&#39;):
                        t.ref = t.ref[:-1]
                        if t.ref == &#39;&#39;:
                                delattr(t, &#39;ref&#39;)
                return t

        def ref_stripped(self):  # pragma: no cover
                t = copy.deepcopy(self)
                if hasattr(t, &#39;ref&#39;):
                        delattr(t, &#39;ref&#39;)
                return t


class _FunctionSignature:
        grammar = [attr(&#34;void_rval&#34;, &#34;void&#34;), attr(&#34;rval&#34;, _CType)], &#34;(&#34;, optional(attr(&#34;args&#34;, csl(_CType))), &#34;)&#34;

        def __repr__(self):
                return get_fully_qualified_function_signature(self)


class _TemplateParameters:
        grammar = &#34;&lt;&#34;, [attr(&#34;function&#34;, _FunctionSignature), attr(&#34;args&#34;, csl(_CType))], &#34;&gt;&#34;

        def __repr__(self):
                if hasattr(self, &#34;function&#34;):
                        args = [repr(self.function)]
                else:
                        args = [repr(arg) for arg in self.args]

                return &#39;&lt;&#39; + &#39;,&#39;.join(args) + &#39;&gt;&#39;


class _Typename:
        grammar = attr(&#34;name&#34;, typename), optional(attr(&#34;template&#34;, _TemplateParameters))

        def __repr__(self):
                out = self.name

                if hasattr(self, &#39;template&#39;):
                        out += repr(self.template)

                return out


class _ScopedTypename:
        grammar = flag(&#34;explicit_global&#34;, K(&#34;::&#34;)), attr(&#34;parts&#34;, csl(_Typename, separator=&#34;::&#34;))

        def naked_name(self):
                return self.parts[-1].name

        def __eq__(self, other):
                return repr(self) == repr(other)

        def __repr__(self):
                out = &#39;&#39;
                if self.explicit_global:
                        out += &#39;::&#39;

                parts = []
                for part in self.parts:
                        parts.append(repr(part))

                out += &#39;::&#39;.join(parts)
                return out


_CType.grammar = flag(&#34;const&#34;), flag(&#34;signed&#34;), flag(&#34;unsigned&#34;), attr(&#34;scoped_typename&#34;, _ScopedTypename), optional(attr(&#34;ref&#34;, ref_re)), flag(&#34;const_ref&#34;, K(&#34;const&#34;))


#
class _NamedCType:
        grammar = attr(&#34;ctype&#34;, _CType), attr(&#34;name&#34;, _ScopedTypename)

        def __repr__(self):  # pragma: no cover
                return &#39; &#39;.join([repr(self.ctype), self.name.naked_name()])


#
def ctype_ref_to(src_ref, dst_ref):
        i = 0
        while i &lt; len(src_ref) and i &lt; len(dst_ref):
                if src_ref[i] != dst_ref[i]:
                        break
                i += 1

        src_ref = src_ref[i:]
        dst_ref = dst_ref[i:]

        if src_ref == &#39;&amp;&#39;:
                if dst_ref == &#39;&amp;&#39;:
                        return &#39;&#39;  # ref to ref
                elif dst_ref == &#39;*&#39;:
                        return &#39;&amp;&#39;  # ref to ptr
                else:
                        return &#39;&#39;  # ref to value
        elif src_ref == &#39;*&#39;:
                if dst_ref == &#39;&amp;&#39;:
                        return &#39;*&#39;  # ptr to ref
                elif dst_ref == &#39;*&#39;:
                        return &#39;&#39;  # ptr to ptr
                else:
                        return &#39;*&#39;  # ptr to value
        else:
                if dst_ref == &#39;&amp;&#39;:
                        return &#39;&#39;  # value to ref
                elif dst_ref == &#39;*&#39;:
                        return &#39;&amp;&#39;  # value to ptr
                else:
                        return &#39;&#39;  # value to value


def transform_var_ref_to(var, from_ref, to_ref):
        if isinstance(var, _ScopedTypename):
                var = var.naked_name()
        return ctype_ref_to(from_ref, to_ref) + var


def add_list_unique(lst, val, dlg):
        for ent in lst:
                if dlg(val, ent):
                        return
        lst.append(val)


def collect_attr_from_conv_recursive(out, conv, attr, dlg):
        for entry in getattr(conv, attr):
                add_list_unique(out, entry, dlg)
        for base in conv._bases:
                collect_attr_from_conv_recursive(out, base, attr, dlg)
        return out


class TypeConverter:
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                self.ctype = parse(type, _CType)
                self.to_c_storage_ctype = parse(to_c_storage_type, _CType) if to_c_storage_type is not None else self.ctype.non_const()
                self.bound_name = get_ctype_default_bound_name(self.ctype) if bound_name is None else bound_name
                self.from_c_storage_ctype = parse(from_c_storage_type, _CType) if from_c_storage_type is not None else None  # if None the prototype return value type will be used to determine adequate storage at binding time

                if needs_c_storage_class:
                        self.c_storage_class = &#39;storage_%s&#39; % self.bound_name
                else:
                        self.c_storage_class = None

                self.type_tag = &#39;type_tag_&#39; + self.bound_name

                self.constructor = None
                self.members = []
                self.static_members = []
                self.methods = []
                self.static_methods = []
                self.arithmetic_ops = []
                self.comparison_ops = []

                self._non_copyable = False
                self._moveable = False
                self._inline = False
                self._supports_deep_compare = False
                self._is_pointer = False

                self._features = {}
                self._casts = []  # valid casts
                self._bases = []  # bases

                self.nobind = False

                self.check_func = apply_api_prefix(&#39;check_%s&#39; % self.bound_name)
                self.to_c_func = apply_api_prefix(&#39;to_c_%s&#39; % self.bound_name)
                self.from_c_func = apply_api_prefix(&#39;from_c_%s&#39; % self.bound_name)

        def is_type_class(self):
                return False

        def get_operator(self, op):
                for arithmetic_op in self.arithmetic_ops:
                        if arithmetic_op[&#39;op&#39;] == op:
                                return arithmetic_op

        def get_type_api(self, module_name):
                return &#39;&#39;

        def finalize_type(self):
                return &#39;&#39;

        def to_c_call(self, out_var, expr):
                assert &#39;not implemented in this converter&#39;  # pragma: no cover
        def from_c_call(self, out_var, expr, ownership):
                assert &#39;not implemented in this converter&#39;  # pragma: no cover

        def prepare_var_for_conv(self, var, input_ref):
                &#34;&#34;&#34;Transform a variable for use with the converter from_c/to_c methods.&#34;&#34;&#34;
                return transform_var_ref_to(var, input_ref, self.to_c_storage_ctype.get_ref())
        def prepare_var_from_conv(self, var, target_ref):
                &#34;&#34;&#34;Transform a converted variable back to its ctype reference.&#34;&#34;&#34;
                return transform_var_ref_to(var, self.to_c_storage_ctype.get_ref(), target_ref)

        def get_all_members(self):
                return collect_attr_from_conv_recursive([], self, &#39;members&#39;, lambda a,b: a[&#39;name&#39;] == b[&#39;name&#39;])
        def get_all_static_members(self):
                return collect_attr_from_conv_recursive([], self, &#39;static_members&#39;, lambda a,b: a[&#39;name&#39;] == b[&#39;name&#39;])
        def get_all_methods(self):
                return collect_attr_from_conv_recursive([], self, &#39;methods&#39;, lambda a,b: a[&#39;bound_name&#39;] == b[&#39;bound_name&#39;])
        def get_all_static_methods(self):
                return collect_attr_from_conv_recursive([], self, &#39;static_methods&#39;, lambda a,b: a[&#39;bound_name&#39;] == b[&#39;bound_name&#39;])

        def add_feature(self, key, val):
                self._features[key] = val


def format_list_for_comment(lst):
        ln = len(lst)

        if ln == 0:
                return &#39;&#39;
        if ln == 1:
                return lst[0]
        if ln == 2:
                return &#39;%s or %s&#39; % (lst[0], lst[1])

        return &#39;, &#39;.join(lst[:-1]) + &#39; or &#39; + lst[-1]


#
class FABGen:
        def __init__(self):
                self.verbose = True
                self.embedded = False
                self.check_self_type_in_ops = False
                self.defines = []

        def apply_api_prefix(self, symbol):
                return apply_api_prefix(symbol)

        def get_language(self):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def parse_ctype(self, type):
                return parse(type, _CType)

        def parse_named_ctype(self, type):
                type = type.replace(&#39;* *&#39;, &#39;**&#39;)
                return parse(type, _NamedCType)

        def ctype_to_plain_string(self, ctype):
                return ctype_to_plain_string(ctype)

        get_symbol_doc_hook = lambda gen, name: &#34;&#34;

        def get_symbol_doc(self, name):
                return self.get_symbol_doc_hook(name)

        def output_header(self):
                common = &#34;// This file is automatically generated, do not modify manually!\n\n&#34;

                self._source += &#34;// FABgen output .cpp\n&#34;
                self._source += common
                self._source += &#39;#include &#34;fabgen.h&#34;\n\n&#39;

                self._header += &#39;// FABgen output .h\n&#39;
                self._header += common
                self._header += &#39;#pragma once\n\n&#39;
                self._header += &#39;#include &lt;cstdint&gt;\n\n&#39;
                self._header += &#39;#include &lt;cstddef&gt;\n\n&#39;

        def output_includes(self):
                self.add_include(&#39;cstdint&#39;, True)
                self.add_include(&#39;cassert&#39;, True)
                self.add_include(&#39;map&#39;, True)

                self._source += &#39;{{{__WRAPPER_INCLUDES__}}}\n&#39;

        def start(self, name):
                self._name = name
                self._header, self._source = &#34;&#34;, &#34;&#34;

                self.__system_includes, self.__user_includes = [], []

                self.__type_convs = {}
                self.__function_declarations = {}

                self._bound_types = []  # list of bound types
                self._bound_functions = []  # list of bound functions
                self._bound_variables = []  # list of bound variables
                self._enums = {}  # list of bound enumerations

                self._extern_types = []  # list of extern types

                self._custom_init_code = &#34;&#34;
                self._custom_free_code = &#34;&#34;

                self.output_header()
                self.output_includes()

                self._source += &#39;static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag);\n&#39;
                self._source += &#39;static void *_type_tag_cast(void *in_T0, uint32_t in_type_tag, uint32_t out_type_tag);\n\n&#39;

        def add_include(self, path, is_system=False):
                if is_system:
                        if path not in self.__system_includes:
                                self.__system_includes.append(path)
                else:
                        if path not in self.__user_includes:
                                self.__user_includes.append(path)

        def insert_code(self, code, in_source=True, in_header=True):
                if in_header:
                        self._header += code
                if in_source:
                        self._source += code

        def insert_binding_code(self, code, comment=None):
                parts = []
                if comment is not None:
                        parts.append(&#39;// %s\n&#39; % comment)
                parts.append(code)
                parts.append(&#39;\n&#39;)
                self._source += &#39;&#39;.join(parts)

        def add_custom_init_code(self, code):
                self._custom_init_code += code

        def add_custom_free_code(self, code):
                self._custom_free_code += code

        #
        def defined(self, symbol):
                return symbol in self.defines

        #
        def begin_type(self, conv, features, nobind=False):
                &#34;&#34;&#34;Declare a new type converter.&#34;&#34;&#34;
                if False:#self.verbose:
                        print(&#39;Binding type %s (%s)&#39; % (conv.bound_name, conv.ctype))

                self._header += conv.get_type_api(self._name)

                self._source += &#39;// %s type tag\n&#39; % conv.ctype
                self._source += &#39;static uint32_t %s = %s;\n\n&#39; % (conv.type_tag, hex(zlib.crc32(conv.bound_name.encode()) &amp; 0xffffffff))

                self._source += conv.get_type_api(self._name)

                conv.nobind = nobind
                conv._features = copy.deepcopy(features)

                self._bound_types.append(conv)
                self.__type_convs[repr(conv.ctype)] = conv

                feats = list(conv._features.values())
                for feat in feats:
                        if hasattr(feat, &#39;init_type_converter&#39;):
                                feat.init_type_converter(self, conv)  # init converter feature

                return conv

        def end_type(self, conv):
                type_glue = conv.get_type_glue(self, self._name)
                self._source += type_glue + &#39;\n&#39;

        def bind_type(self, conv, features={}):
                self.begin_type(conv, features)
                self.end_type(conv)
                return conv

        #
        def typedef(self, type, alias_of, to_c_storage_type=None, bound_name=None):
                conv = copy.deepcopy(self.__type_convs[alias_of])

                default_arg_storage_type = type if to_c_storage_type is None else to_c_storage_type

                if bound_name is not None:
                        conv.bound_name=bound_name
                conv.ctype = parse(type, _CType)
                conv.to_c_storage_ctype = parse(default_arg_storage_type, _CType)

                self.__type_convs[type] = conv

        #
        def bind_named_enum(self, name, symbols, storage_type=&#39;int&#39;, bound_name=None, prefix=&#39;&#39;, namespace=None):
                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)

                self.typedef(name, storage_type, bound_name=bound_name)

                if namespace is None:
                        namespace = name

                enum = {}
                for symbol in symbols:
                        enum[prefix + symbol] = &#39;%s::%s&#39; % (namespace, symbol)

                self._enums[bound_name] = enum

        #
        def begin_class(self, type, converter_class=None, noncopyable=False, moveable=False, bound_name=None, features={}, nobind=False):
                &#34;&#34;&#34;Begin a class declaration.&#34;&#34;&#34;
                if type in self.__type_convs:
                        return self.__type_convs[type]  # type already declared

                default_storage_type = type + &#39;*&#39;

                conv = self.default_class_converter(type, default_storage_type, bound_name) if converter_class is None else converter_class(type, default_storage_type, bound_name)
                conv = self.begin_type(conv, features, nobind)

                conv._non_copyable = noncopyable
                conv._moveable = moveable
                return conv

        def end_class(self, conv):
                &#34;&#34;&#34;End a class declaration.&#34;&#34;&#34;
                self.end_type(conv)

        #
        def bind_extern_type(self, type, bound_name=None, module=None):
                &#34;&#34;&#34;Bind an external type.&#34;&#34;&#34;
                if type in self.__type_convs:
                        return self.__type_convs[type]  # type already declared

                default_storage_type = type + &#39;*&#39;

                conv = self.default_extern_converter(type, default_storage_type, bound_name, module)

                if self.verbose:
                        print(&#39;Binding extern type %s (%s)&#39; % (conv.bound_name, conv.ctype))

                self._header += conv.get_type_api(self._name)
                self._source += conv.get_type_api(self._name)

                self._extern_types.append(conv)
                self.__type_convs[repr(conv.ctype)] = conv

                self._source += conv.get_type_glue(self, self._name) + &#39;\n&#39;
                return conv

        #
        def bind_ptr(self, type, converter_class=None, bound_name=None, features={}):
                if type in self.__type_convs:
                        return self.__type_convs[type]  # type already declared

                conv = self.default_ptr_converter(type, None, bound_name) if converter_class is None else converter_class(type, None, bound_name)
                self.bind_type(conv, features)

                return conv

        #
        def add_cast(self, src_conv, tgt_conv, cast_delegate):
                &#34;&#34;&#34;Declare a cast delegate from one type to another.&#34;&#34;&#34;
                src_conv._casts.append((tgt_conv, cast_delegate))

        #
        def __add_upcast(self, conv, base):
                self.add_cast(conv, base, lambda in_var, out_var: &#39;%s = (%s *)((%s *)%s);\n&#39; % (out_var, base.ctype, conv.ctype, in_var))
                for base_of_base in base._bases:
                        self.__add_upcast(conv, base_of_base)

        def add_base(self, conv, base):
                self.__add_upcast(conv, base)
                conv._bases.append(base)

        def add_bases(self, conv, bases):
                for base in bases:
                        self.add_base(conv, base)

        #
        def select_ctype_conv(self, ctype):
                &#34;&#34;&#34;Select a type converter.&#34;&#34;&#34;
                if repr(ctype) == &#39;void&#39;:
                        return None

                while True:
                        type = repr(ctype)
                        if type in self.__type_convs:
                                return self.__type_convs[type]

                        type = repr(ctype.non_const())
                        if type in self.__type_convs:
                                return self.__type_convs[type]

                        if ctype.get_ref() == &#39;&#39;:
                                break
                        #alt 
                        ctype = ctype.dereference_once()

                raise Exception(&#34;Unknown type %s (no converter available)&#34; % ctype)

        def get_conv(self, type):
                return self.__type_convs[type]

        #
        def decl_var(self, ctype, name, eol=&#39;;\n&#39;):
                return &#39;%s %s%s&#39; % (get_fully_qualified_ctype_name(ctype), name, eol)

        #
        def select_args_convs(self, args):
                return [{&#39;conv&#39;: self.select_ctype_conv(arg.ctype), &#39;ctype&#39;: arg.ctype} for i, arg in enumerate(args)]

        #
        def commit_from_c_vars(self, rval, ctx):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def rval_assign_arg_in_out(self, out_var, arg_in_out):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        #
        def proxy_call_error(self, msg, ctx):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        #
        def __ctype_to_ownership_policy(self, ctype):
                return &#39;Copy&#39; if ctype.get_ref() == &#39;&#39; else &#39;NonOwning&#39;

        # --
        def __expand_protos(self, protos):
                _protos = []

                for proto in protos:
                        _proto = (proto[0], [], proto[2])

                        for arg in proto[1]:
                                if arg.startswith(&#39;?&#39;):
                                        _protos.append(_proto)
                                        _proto = copy.deepcopy(_proto)
                                        arg = arg[1:]

                                _proto[1].append(arg)

                        _protos.append(_proto)

                return _protos

        def __prepare_protos(self, protos):
                &#34;&#34;&#34;Prepare a list of prototypes, select converter objects&#34;&#34;&#34;
                _protos = []

                for proto in protos:
                        assert len(proto) == 3, &#34;prototype incomplete. Expected 3 entries (type, [arguments], [features]), found %d&#34; % len(proto)

                        rval_type, args, features = proto

                        rval_ctype = parse(rval_type, _CType)
                        rval_conv = self.select_ctype_conv(rval_ctype)

                        if rval_conv is not None and rval_conv.from_c_storage_ctype is not None:
                                from_c_storage_ctype = rval_conv.from_c_storage_ctype
                        else:
                                from_c_storage_ctype = rval_ctype  # prepare the return value variable CType
                                if from_c_storage_ctype.get_ref() == &#39;&#39;:
                                        from_c_storage_ctype = from_c_storage_ctype.non_const()

                        _proto = {&#39;rval&#39;: {&#39;storage_ctype&#39;: from_c_storage_ctype, &#39;conv&#39;: rval_conv}, &#39;args&#39;: [], &#39;argsin&#39;: [], &#39;features&#39;: features}

                        if not type(args) is type([]):
                                args = [args]

                        for arg in args:
                                carg = self.parse_named_ctype(arg)
                                conv = self.select_ctype_conv(carg.ctype)
                                _proto[&#39;args&#39;].append({&#39;carg&#39;: carg, &#39;conv&#39;: conv, &#39;check_var&#39;: None})

                        # prepare argsin, a list of arguments that should be provided by the caller
                        _proto[&#39;argsin&#39;] = _proto[&#39;args&#39;]  # default to the full arg list

                        if &#39;arg_out&#39; in features:  # exclude output arguments from the argsin list
                                _proto[&#39;argsin&#39;] = [arg for arg in _proto[&#39;args&#39;] if arg[&#39;carg&#39;].name.naked_name() not in _proto[&#39;features&#39;][&#39;arg_out&#39;]]

                        _protos.append(_proto)

                # compute suggested_suffix if language doesn&#39;t support overload
                if len(_protos) &gt; 1:
                        # get the base one, usually the first one with the less args
                        id_base = 0
                        proto_base = _protos[id_base]
                        for id, proto in enumerate(_protos[1:]):
                                if len(proto[&#34;args&#34;]) &lt; len(proto_base[&#34;args&#34;]):
                                        proto_base = proto
                                        id_base = id + 1

                        suggested_suffixes = []
                        
                        for id, proto in enumerate(_protos):
                                if id == id_base:
                                        continue
                                
                                # check members difference
                                def get_suggested_suffix(with_type = False):
                                        suggested_suffix = &#34;&#34;
                                        for i, arg in enumerate(proto[&#34;args&#34;]):
                                                if i &gt;= len(proto_base[&#34;args&#34;]) or proto_base[&#34;args&#34;][i][&#34;carg&#34;].name != arg[&#34;carg&#34;].name or str(proto_base[&#34;args&#34;][i][&#34;carg&#34;].ctype) != str(arg[&#34;carg&#34;].ctype):
                                                        if suggested_suffix == &#34;&#34;:
                                                                suggested_suffix = &#34;With&#34;
                                                        if with_type:
                                                                if arg[&#34;conv&#34;].bound_name is not None:
                                                                        suggested_suffix += clean_name_with_title(str(arg[&#34;conv&#34;].bound_name))
                                                                else:
                                                                        suggested_suffix += clean_name_with_title(str(arg[&#39;carg&#39;].ctype))

                                                                if suggested_suffix.endswith(&#34;_nobind&#34;) and arg[&#34;conv&#34;].nobind:
                                                                        suggested_suffix = suggested_suffix[:-len(&#34;_nobind&#34;)]

                                                        suggested_suffix += clean_name_with_title(str(arg[&#34;carg&#34;].name))
                                        return suggested_suffix

                                suggested_suffix = get_suggested_suffix()
                                
                                # check if this suffix already exists
                                if suggested_suffix in suggested_suffixes:
                                        # recheck the suggested suffix, but with the type
                                        suggested_suffix = get_suggested_suffix(True)

                                suggested_suffixes.append(suggested_suffix)

                                proto[&#34;suggested_suffix&#34;] = suggested_suffix

                return _protos

        def __assert_conv_feature(self, conv, feature):
                assert feature in conv._features, &#34;Type converter for %s does not support the %s feature&#34; % (conv.ctype, feature)

        #
        def _prepare_to_c_self(self, conv, out_var, ctx=&#39;none&#39;, features=[]):
                out = &#39;&#39;
                if &#39;proxy&#39; in features:
                        proxy = conv._features[&#39;proxy&#39;]

                        out += &#39;        &#39; + self.decl_var(conv.to_c_storage_ctype, &#39;%s_wrapped&#39; % out_var)
                        out += &#39;        &#39; + conv.to_c_call(self.get_self(ctx), &#39;&amp;%s_wrapped&#39; % out_var)

                        out += &#39;        &#39; + self.decl_var(proxy.wrapped_conv.to_c_storage_ctype, out_var)
                        out += proxy.unwrap(&#39;%s_wrapped&#39; % out_var, out_var)
                else:
                        out += &#39;        &#39; + self.decl_var(conv.to_c_storage_ctype, out_var)
                        out += &#39;        &#39; + conv.to_c_call(self.get_self(ctx), &#39;&amp;%s&#39; % out_var)
                return out

        def _declare_to_c_var(self, ctype, var):
                return self.decl_var(ctype, var)

        def _convert_to_c_var(self, idx, conv, var, ctx=&#39;default&#39;, features=[]):
                out = conv.to_c_call(self.get_var(idx, ctx), &#39;&amp;%s&#39; % var)

                if &#39;validate_arg_in&#39; in features:
                        validator = features[&#39;validate_arg_in&#39;][idx]
                        if validator is not None:
                                out += validator(self, var, ctx)

                return out

        def prepare_to_c_var(self, idx, conv, var, ctx=&#39;default&#39;, features=[]):
                return self._declare_to_c_var(conv.to_c_storage_ctype, var) + self._convert_to_c_var(idx, conv, var, ctx, features)

        #
        def declare_from_c_var(self, out_var):
                return &#39;&#39;

        def prepare_from_c_var(self, rval):
                if rval[&#39;ownership&#39;] is None:
                        rval[&#39;ownership&#39;] = self.__ctype_to_ownership_policy(rval[&#39;ctype&#39;])

                # transform from {T&amp;, T*, T**, ...} to T* where T is conv.ctype
                expr = transform_var_ref_to(rval[&#39;var&#39;], rval[&#39;ctype&#39;].get_ref(), rval[&#39;conv&#39;].ctype.add_ref(&#39;*&#39;).get_ref())

                out_var = (rval[&#39;var&#39;] if isinstance(rval[&#39;var&#39;], str) else rval[&#39;var&#39;].naked_name()) + &#39;_out&#39;
                src = self.declare_from_c_var(out_var)
                if &#39;rval_transform&#39; in rval[&#39;conv&#39;]._features:
                        src += rval[&#39;conv&#39;]._features[&#39;rval_transform&#39;](self, rval[&#39;conv&#39;], expr, out_var, rval[&#39;ownership&#39;])
                else:
                        check_is_valid_pointer = rval[&#39;ctype&#39;].is_pointer() or rval[&#39;conv&#39;]._is_pointer

                        if check_is_valid_pointer:
                                src += &#39;if (!%s) {\n&#39; % rval[&#39;var&#39;]
                                src += self.rval_from_nullptr(out_var)
                                src += &#39;} else {\n&#39;

                        if rval[&#39;conv&#39;].is_type_class() and rval[&#39;is_arg_in_out&#39;]:  # if an object is used as arg_out then reuse the input argument directly 
                                src += self.rval_assign_arg_in_out(out_var, self.get_var(rval[&#39;arg_idx&#39;], rval[&#39;ctx&#39;]))
                        else:
                                src += self.rval_from_c_ptr(rval[&#39;conv&#39;], out_var, expr, rval[&#39;ownership&#39;])

                        if check_is_valid_pointer:
                                src += &#39;}\n&#39;

                return src

        #
        def _proto_call(self, self_conv, proto, expr_eval, ctx, fixed_arg_count=None):
                parts = []

                features = proto[&#39;features&#39;]

                enable_proxy = &#39;proxy&#39; in features
                if enable_proxy:
                        assert ctx != &#39;function&#39;, &#34;Proxy feature cannot be used for a function call&#34;

                        if self_conv is not None:
                                self.__assert_conv_feature(self_conv, &#39;proxy&#39;)

                # prepare C call self argument
                if self_conv:
                        if ctx in [&#39;getter&#39;, &#39;setter&#39;, &#39;method&#39;, &#39;arithmetic_op&#39;, &#39;inplace_arithmetic_op&#39;, &#39;comparison_op&#39;]:
                                parts.append(self._prepare_to_c_self(self_conv, &#39;_self&#39;, ctx, features))

                # prepare C call arguments
                args = proto[&#39;args&#39;]
                arg_out = features[&#39;arg_out&#39;] if &#39;arg_out&#39; in features else None

                c_call_args = []

                argin_idx = 0
                for idx, arg in enumerate(args):
                        conv = arg[&#39;conv&#39;]

                        var = &#39;arg%d&#39; % idx

                        if arg_out is not None and arg[&#39;carg&#39;].name.naked_name() in arg_out:
                                arg_ctype = conv.ctype
                                parts.append(self._declare_to_c_var(arg_ctype, var))
                        else:
                                arg_ctype = conv.to_c_storage_ctype
                                parts.append(self._declare_to_c_var(conv.to_c_storage_ctype, var))
                                parts.append(self._convert_to_c_var(argin_idx, conv, var, ctx, features))
                                argin_idx += 1

                        c_call_args.append(transform_var_ref_to(var, arg_ctype.get_ref(), arg[&#39;carg&#39;].ctype.get_ref()))

                if &#39;arg_in_out&#39; in features:  # add in_out vars to the arg_out list
                        if arg_out is None:
                                arg_out = []
                        arg_out = arg_out + features[&#39;arg_in_out&#39;]

                # c++ exception support
                if &#39;exception&#39; in features:
                        parts.append(&#39;try {\n&#39;)

                # declare return value
                rvals = []
                rvals_prepare_args = []

                if ctx == &#39;constructor&#39;:
                        rval_conv = proto[&#39;rval&#39;][&#39;conv&#39;]
                        from_c_storage_ctype = proto[&#39;rval&#39;][&#39;storage_ctype&#39;].add_ref(&#39;*&#39;)  # constructor returns a pointer

                        ownership = &#39;Owning&#39;  # constructor output is always owned by the VM

                        if enable_proxy:
                                proxy = rval_conv._features[&#39;proxy&#39;]

                                parts.append(self.decl_var(proxy.wrapped_conv.ctype.add_ref(&#39;*&#39;), &#39;rval_raw&#39;, &#39; = &#39;))
                                parts.append(&#39;new %s(%s);\n&#39; % (proxy.wrapped_conv.ctype, &#39;, &#39;.join(c_call_args)))

                                parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;))
                                parts.append(proxy.wrap(&#39;rval_raw&#39;, &#39;rval&#39;))
                        else:
                                if &#39;route&#39; in features:
                                        parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;, &#39; = &#39;))

                                        expr_eval = features[&#39;route&#39;]  # hijack the output expression
                                        parts.append(expr_eval(c_call_args) + &#39;\n&#39;)
                                else:
                                        if rval_conv._inline:
                                                if len(c_call_args) &gt; 0:
                                                        parts.append(&#39;%s _new_obj(%s);\n&#39; % (rval_conv.ctype, &#39;, &#39;.join(c_call_args)))  # construct new inline object on the stack
                                                else:
                                                        parts.append(&#39;%s _new_obj;\n&#39; % rval_conv.ctype)
                                                ownership = &#39;Copy&#39;  # inline objects are constructed on the heap then copy constructed to the VM memory block

                                        parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;, &#39; = &#39;))

                                        if rval_conv._inline:
                                                parts.append(&#39;&amp;_new_obj;\n&#39;)
                                        else:
                                                parts.append(&#39;new %s(%s);\n&#39; % (rval_conv.ctype, &#39;, &#39;.join(c_call_args)))

                        rvals_prepare_args.append({&#39;conv&#39;: rval_conv, &#39;ctype&#39;: from_c_storage_ctype, &#39;var&#39;: &#39;rval&#39;, &#39;is_arg_in_out&#39;: False, &#39;ctx&#39;: ctx, &#39;ownership&#39;: ownership})
                        rvals.append(&#39;rval&#39;)
                else:
                        rval_conv = proto[&#39;rval&#39;][&#39;conv&#39;]
                        from_c_storage_ctype = proto[&#39;rval&#39;][&#39;storage_ctype&#39;]

                        # return value is optional for a function call
                        if rval_conv:
                                parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;, &#39; = &#39;))

                        if &#39;route&#39; in features:
                                if self_conv:
                                        c_call_args = [&#39;_self&#39;] + c_call_args
                                expr_eval = features[&#39;route&#39;]  # hijack the output expression

                        parts.append(expr_eval(c_call_args) + &#39;\n&#39;)

                        if rval_conv:
                                ownership = None  # automatic ownership policy
                                if &#39;new_obj&#39; in features:
                                        ownership = &#39;Owning&#39;  # force ownership when the prototype is flagged to return a new object
                                elif &#39;copy_obj&#39; in features:
                                        ownership = &#39;Copy&#39;  # force copy ownership

                                rvals_prepare_args.append({&#39;conv&#39;: rval_conv, &#39;ctype&#39;: from_c_storage_ctype, &#39;var&#39;: &#39;rval&#39;, &#39;is_arg_in_out&#39;: False, &#39;ctx&#39;: ctx, &#39;ownership&#39;: ownership})
                                rvals.append(&#39;rval&#39;)

                # process arg_out
                if arg_out is not None:
                        arg_in_out = features[&#39;arg_in_out&#39;] if &#39;arg_in_out&#39; in features else []

                        for idx, arg in enumerate(args):
                                carg_name = arg[&#39;carg&#39;].name.naked_name()

                                if carg_name in arg_out:
                                        is_arg_in_out = carg_name in arg_in_out

                                        if is_arg_in_out:
                                                arg_ctype = arg[&#39;conv&#39;].to_c_storage_ctype
                                        else:
                                                arg_ctype = arg[&#39;conv&#39;].ctype

                                        rvals_prepare_args.append({&#39;conv&#39;: arg[&#39;conv&#39;], &#39;ctype&#39;: arg_ctype, &#39;var&#39;: &#39;arg%d&#39; % idx, &#39;is_arg_in_out&#39;: is_arg_in_out, &#39;arg_idx&#39;: idx, &#39;ctx&#39;: ctx, &#39;ownership&#39;: None})
                                        rvals.append(&#39;arg%d&#39; % idx)

                # check return values
                if &#39;check_rval&#39; in features:
                        parts.append(features[&#39;check_rval&#39;](rvals, ctx))

                # prepare return values ([EJ] once check is done so we don&#39;t leak)
                for rval in rvals_prepare_args:
                        parts.append(self.prepare_from_c_var(rval))

                parts.append(self.commit_from_c_vars(rvals, ctx))

                if &#39;exception&#39; in features:
                        parts.append(&#39;}\n&#39;)
                        parts.append(&#39;catch(...) {\n&#39;)
                        parts.append(self.proxy_call_error(features[&#39;exception&#39;], ctx))
                        parts.append(&#39;}\n&#39;)

                return &#39;&#39;.join(parts)

        def _bind_proxy(self, name, self_conv, protos, desc, expr_eval, ctx, fixed_arg_count=None):
                parts = []

                if self.verbose:
                        print(&#39;Binding proxy %s&#39; % name)

                protos = self.__expand_protos(protos)
                protos = self.__prepare_protos(protos)

                # categorize prototypes by number of argument they take
                def get_protos_per_arg_count(protos):
                        by_arg_count = {}
                        for proto in protos:
                                arg_count = len(proto[&#39;argsin&#39;])
                                if arg_count not in by_arg_count:
                                        by_arg_count[arg_count] = []
                                by_arg_count[arg_count].append(proto)
                        return by_arg_count


                protos_by_arg_count = get_protos_per_arg_count(protos)

                # prepare proxy function
                self.insert_code(&#39;// %s\n&#39; % desc, True, False)

                max_arg_count = max(protos_by_arg_count.keys())

                parts.append(self.open_proxy(name, max_arg_count, ctx))

                # check self
                if self.check_self_type_in_ops and ctx in [&#39;arithmetic_op&#39;, &#39;inplace_arithmetic_op&#39;, &#39;comparison_op&#39;]:
                        parts.append(&#39;if (!%s) {\n&#39; % self_conv.check_call(self.get_self(ctx)))
                        parts.append(self.proxy_call_error(&#39;incorrect type for argument 0 to %s, expected %s&#39; % (desc, self_conv.bound_name), ctx))
                        parts.append(&#39;}\n\n&#39;)

                # output dispatching logic
                def get_protos_per_arg_conv(protos, arg_idx):
                        per_arg_conv = {}
                        for proto in protos:
                                arg_conv = proto[&#39;argsin&#39;][arg_idx][&#39;conv&#39;]
                                if arg_conv not in per_arg_conv:
                                        per_arg_conv[arg_conv] = []
                                per_arg_conv[arg_conv].append(proto)
                        return per_arg_conv
                        

                has_fixed_argc = fixed_arg_count is not None

                if has_fixed_argc:
                        assert len(protos_by_arg_count) == 1 and fixed_arg_count in protos_by_arg_count

                for arg_count, protos_with_arg_count in protos_by_arg_count.items():
                        if not has_fixed_argc:
                                parts.append(&#39;  if (arg_count == %d) {\n&#39; % arg_count)

                        def output_arg_check_and_dispatch(protos, arg_idx, arg_limit):
                                parts = []
                                indent = &#39;      &#39; * (arg_idx+(2 if not has_fixed_argc else 1))

                                if arg_idx == arg_limit:
                                        assert len(protos) == 1  # there should only be exactly one prototype with a single signature
                                        parts.append(self._proto_call(self_conv, protos[0], expr_eval, ctx, fixed_arg_count))
                                        return &#39;&#39;.join(parts)

                                protos_per_arg_conv = get_protos_per_arg_conv(protos, arg_idx)

                                parts.append(indent)
                                for conv, protos_for_conv in protos_per_arg_conv.items():
                                        parts.append(&#39;if (%s) {\n&#39; % conv.check_call(self.get_var(arg_idx, ctx)))
                                        parts.append(output_arg_check_and_dispatch(protos_for_conv, arg_idx+1, arg_limit))
                                        parts.append(indent + &#39;} else &#39;)

                                parts.append(&#39;{\n&#39;)

                                expected_types = []
                                for proto in protos:
                                        proto_arg = proto[&#39;argsin&#39;][arg_idx]

                                        proto_arg_name = str(proto_arg[&#39;carg&#39;].name)
                                        proto_arg_bound_name = proto_arg[&#39;conv&#39;].bound_name

                                        expected_types.append(&#39;%s %s&#39; % (proto_arg_bound_name, proto_arg_name))

                                parts.append(self.set_error(&#39;runtime&#39;, &#39;incorrect type for argument %d to %s, expected %s&#39; % (arg_idx+1, desc, format_list_for_comment(expected_types))))
                                parts.append(indent + &#39;}\n&#39;)
                                return &#39;&#39;.join(parts)

                        parts.append(output_arg_check_and_dispatch(protos_with_arg_count, 0, arg_count))

                        if not has_fixed_argc:
                                parts.append(&#39;  } else &#39;)

                if not has_fixed_argc:
                        parts.append(&#39;{\n&#39;)
                        parts.append(self.set_error(&#39;runtime&#39;, &#39;incorrect number of arguments to %s&#39; % desc))
                        parts.append(&#39;  }\n&#39;)

                #
                parts.append(self.close_proxy(ctx))
                parts.append(&#39;\n&#39;)

                self._source += &#39;&#39;.join(parts)

        #
        def __do_bind_function_overloads(self, name, protos, bound_name=None):
                expr_eval = lambda args: &#39;%s(%s);&#39; % (name, &#39;, &#39;.join(args))

                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)
                proxy_name = apply_api_prefix(bound_name)

                self._bind_proxy(proxy_name, None, protos, &#39;function %s&#39; % bound_name, expr_eval, &#39;function&#39;)
                self._bound_functions.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def __commit_function_declarations(self):
                for name, decl in self.__function_declarations.items():
                        self.__do_bind_function_overloads(name, decl[&#39;protos&#39;], decl[&#39;bound_name&#39;])

        def bind_function(self, name, rval, args, features=[], bound_name=None):
                self.bind_function_overloads(name, [(rval, args, features)], bound_name)

        def bind_function_overloads(self, name, protos, bound_name=None):
                if not name in self.__function_declarations:
                        fn = self.__function_declarations[name] = {
                                &#39;protos&#39;: protos,
                                &#39;bound_name&#39;: bound_name
                        }
                else:
                        fn = self.__function_declarations[name]
                        assert(bound_name == fn[&#39;bound_name&#39;])  # ensure bound_name coherency
                        fn[&#39;protos&#39;] = fn[&#39;protos&#39;] + protos

        # reverse binding support
        def _get_rbind_call_signature(self, name, rval, args):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def _prepare_rbind_call(self, rval, args):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def _rbind_call(self, rval, args, success_var):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def _clean_rbind_call(self, rval, args):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def __get_rbind_call_signature(self, name, rval, args, output_default_args):
                return &#39;%s %s(%s%s, bool *success%s)&#39; % (rval, name, self._get_rbind_call_custom_args(), (&#39;, &#39; + &#39;, &#39;.join([str(arg) for arg in args])) if len(args) &gt; 0 else &#39;&#39;, &#39; = NULL&#39; if output_default_args else &#39;&#39;)

        def rbind_function(self, name, rval, args, internal=False):
                parts = []
                args = [self.parse_named_ctype(arg) for arg in args]

                if internal:
                        parts.append(&#39;static inline %s {\n&#39; % self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, True))
                else:
                        self._header += &#39;// C to Lua reverse binding call &#39; + name + &#39;\n&#39;
                        self._header += self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, True) + &#39;;\n\n&#39;
                        parts.append(&#39;%s {\n&#39; % self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, False))

                parts.append(self._prepare_rbind_call(rval, args))

                # prepare args
                for arg in args:
                        arg_conv = self.select_ctype_conv(arg.ctype)
                        parts.append(self.prepare_from_c_var({&#39;conv&#39;: arg_conv, &#39;ctype&#39;: arg.ctype, &#39;var&#39;: arg.name, &#39;is_arg_in_out&#39;: False, &#39;ownership&#39;: None}))

                parts.append(self.commit_from_c_vars([arg.name for arg in args], &#39;rbind_args&#39;))

                # call
                parts.append(&#39;bool _call_success_var;&#39;)
                parts.append(&#39;\n&#39; + self._rbind_call(rval, args, &#39;_call_success_var&#39;) + &#39;\n&#39;)
                parts.append(&#39;&#39;&#39;\
if (success)
        *success = _call_success_var;
&#39;&#39;&#39;)

                # rval
                if rval != &#39;void&#39;:
                        rval_conv = self.select_ctype_conv(self.parse_ctype(rval))

                        parts.append(self._declare_to_c_var(rval_conv.to_c_storage_ctype, &#39;_rbind_rval&#39;))
                        parts.append(&#39;&#39;&#39;\
if (%s) {
        %s
} else if (success != NULL) {
        *success = false;
}
&#39;&#39;&#39; % (rval_conv.check_call(self.get_var(0, &#39;rbind_rval&#39;)), self._convert_to_c_var(0, rval_conv, &#39;_rbind_rval&#39;, &#39;rbind_rval&#39;)))

                parts.append(self._clean_rbind_call(rval, args))

                if rval != &#39;void&#39;:
                        parts.append(&#39;return _rbind_rval;\n&#39;)

                parts.append(&#39;}\n&#39;)
                self._source += &#39;&#39;.join(parts)

        #
        def bind_constructor(self, conv, args, features=[]):
                self.bind_constructor_overloads(conv, [(args, features)])

        def bind_constructor_overloads(self, conv, proto_args):
                type = repr(conv.ctype)
                expr_eval = None  # unused for constructors

                protos = [(type, args[0], args[1]) for args in proto_args]
                proxy_name = apply_api_prefix(&#39;construct_%s&#39; % conv.bound_name)

                self._bind_proxy(proxy_name, conv, protos, &#39;%s constructor&#39; % conv.bound_name, expr_eval, &#39;constructor&#39;)
                conv.constructor = {&#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos}

        #
        def bind_method(self, conv, name, rval, args, features=[], bound_name=None):
                self.bind_method_overloads(conv, name, [(rval, args, features)], bound_name)

        def bind_method_overloads(self, conv, name, protos, bound_name=None):
                expr_eval = lambda args: &#39;_self-&gt;%s(%s);&#39; % (name, &#39;, &#39;.join(args))

                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)
                proxy_name = apply_api_prefix(&#39;method_%s_of_%s&#39; % (bound_name, conv.bound_name))

                self._bind_proxy(proxy_name, conv, protos, &#39;method %s of %s&#39; % (bound_name, conv.bound_name), expr_eval, &#39;method&#39;)
                conv.methods.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        #
        def bind_static_method(self, conv, name, rval, args, features=[], bound_name=None):
                self.bind_static_method_overloads(conv, name, [(rval, args, features)], bound_name)

        def bind_static_method_overloads(self, conv, name, protos, bound_name=None):
                expr_eval = lambda args: &#39;%s::%s(%s);&#39; % (conv.ctype, name, &#39;, &#39;.join(args))

                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)
                proxy_name = apply_api_prefix(&#39;static_method_%s_of_%s&#39; % (bound_name, conv.bound_name))

                self._bind_proxy(proxy_name, conv, protos, &#39;static method %s of %s&#39; % (bound_name, conv.bound_name), expr_eval, &#39;static_method&#39;)
                conv.static_methods.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        #
        def bind_members(self, conv, members, features=[]):
                for member in members:
                        self.bind_member(conv, member, features)

        def bind_member(self, conv, member, features=[]):
                is_bitfield = member.endswith(&#39;:&#39;)
                if is_bitfield:
                        member = member[:-1]

                arg = parse(member, _NamedCType)

                # getter
                expr_eval = lambda args: &#39;_self-&gt;%s;&#39; % arg.name
                arg_ctype = arg.ctype if is_bitfield else arg.ctype.add_ref(&#39;&amp;&#39;)
                getter_protos = [(repr(arg_ctype), [], features)]
                getter_proxy_name = apply_api_prefix(&#39;get_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                self._bind_proxy(getter_proxy_name, conv, getter_protos, &#39;get member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;getter&#39;, 0)

                # setter
                if not arg.ctype.is_const():
                        expr_eval = lambda args: &#39;_self-&gt;%s = %s;&#39; % (arg.name, args[0])

                        setter_protos = [(&#39;void&#39;, [member], features)]
                        setter_proxy_name = apply_api_prefix(&#39;set_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                        self._bind_proxy(setter_proxy_name, conv, setter_protos, &#39;set member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;setter&#39;, 1)
                else:
                        setter_proxy_name = None

                conv.members.append({&#39;name&#39;: arg.name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name, &#39;is_bitfield&#39;: is_bitfield})

        #
        def bind_static_member(self, conv, member, features=[]):
                arg = parse(member, _NamedCType)

                # getter
                if &#39;proxy&#39; in features:
                        self.__assert_conv_feature(conv, &#39;proxy&#39;)
                        expr_eval = lambda args: &#39;&amp;%s::%s;&#39; % (conv._features[&#39;proxy&#39;].wrapped_conv.ctype, arg.name)
                else:
                        expr_eval = lambda args: &#39;&amp;%s::%s;&#39; % (conv.ctype, arg.name)

                getter_protos = [(repr(arg.ctype.add_ref(&#39;*&#39;)), [], features)]
                getter_proxy_name = apply_api_prefix(&#39;get_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))
                
                self._bind_proxy(getter_proxy_name, None, getter_protos, &#39;get static member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;getter&#39;, 0)

                # setter
                if not arg.ctype.is_const():
                        expr_eval = lambda args: &#39;%s::%s = %s;&#39; % (conv.ctype, arg.name, args[0])

                        setter_protos = [(&#39;void&#39;, [member], features)]
                        setter_proxy_name = apply_api_prefix(&#39;set_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                        self._bind_proxy(setter_proxy_name, None, setter_protos, &#39;set static member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;setter&#39;, 1)
                else:
                        setter_proxy_name = None

                conv.static_members.append({&#39;name&#39;: arg.name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name})

        def bind_static_members(self, conv, members, features=[]):
                for member in members:
                        self.bind_static_member(conv, member, features)

        #
        def bind_variable(self, var, features=[], bound_name=None, group=None):
                arg = self.parse_named_ctype(var)
                conv = self.select_ctype_conv(arg.ctype)

                if bound_name == None:
                        bound_name = get_symbol_default_bound_name(arg.name)

                # getter
                expr_eval = lambda args: &#39;&amp;%s;&#39; % arg.name

                getter_protos = [(repr(arg.ctype.add_ref(&#39;*&#39;)), [], features)]
                getter_proxy_name = apply_api_prefix(&#39;get_%s_variable&#39; % bound_name)

                self._bind_proxy(getter_proxy_name, None, getter_protos, &#39;get variable %s&#39; % arg.name, expr_eval, &#39;getter&#39;, 0)

                # setter
                if not(arg.ctype.is_const() or conv._non_copyable):
                        expr_eval = lambda args: &#39;%s = %s;&#39; % (arg.name, args[0])

                        setter_protos = [(&#39;void&#39;, [&#34;%s %s&#34; % (str(arg.ctype), bound_name)], features)]
                        setter_proxy_name = apply_api_prefix(&#39;set_%s_variable&#39; % bound_name)

                        self._bind_proxy(setter_proxy_name, None, setter_protos, &#39;set variable %s&#39; % arg.name, expr_eval, &#39;setter&#39;, 1)
                else:
                        setter_proxy_name = None

                self._bound_variables.append({&#39;name&#39;: arg.name, &#39;bound_name&#39;: bound_name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name, &#39;group&#39;: group})

        def bind_variables(self, vars, features=[], group=None):
                for var in vars:
                        self.bind_variable(var, features, None, group)

        #
        def bind_constant(self, type, name, value, group=None):
                self.insert_binding_code(&#39;static const %s %s = %s;\n&#39; % (type, name, value))
                self.bind_variable(&#39;const %s %s&#39; % (type, name), [], None, group)

        def bind_constants(self, type, names_values, group=None):
                for nv in names_values:
                        self.bind_constant(type, nv[0], nv[1], group)

        #
        def bind_arithmetic_op(self, conv, op, rval, args, features=[]):
                self.bind_arithmetic_op_overloads(conv, op, [(rval, args, features)])

        def bind_arithmetic_op_overloads(self, conv, op, protos):
                assert op in [&#39;-&#39;, &#39;+&#39;, &#39;*&#39;, &#39;/&#39;], &#39;Unsupported arithmetic operator &#39; + op

                expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
                proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))

                self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;arithmetic_op&#39;, 1)
                conv.arithmetic_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def bind_arithmetic_ops(self, conv, ops, rval, args, features=[]):
                for op in ops:
                        self.bind_arithmetic_op(conv, op, rval, args, features)

        def bind_arithmetic_ops_overloads(self, conv, ops, protos):
                for op in ops:
                        self.bind_arithmetic_op_overloads(conv, op, protos)

        #
        def bind_inplace_arithmetic_op(self, conv, op, args, features=[]):
                self.bind_inplace_arithmetic_op_overloads(conv, op, [(args, features)])

        def bind_inplace_arithmetic_op_overloads(self, conv, op, args):
                assert op in [&#39;-=&#39;, &#39;+=&#39;, &#39;*=&#39;, &#39;/=&#39;], &#39;Unsupported inplace arithmetic operator &#39; + op

                expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
                proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))
                protos = [(&#39;void&#39;, arg[0], arg[1]) for arg in args]

                self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;inplace_arithmetic_op&#39;, 1)
                conv.arithmetic_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def bind_inplace_arithmetic_ops(self, conv, ops, args, features=[]):
                for op in ops:
                        self.bind_inplace_arithmetic_op(conv, op, args, features)

        def bind_inplace_arithmetic_ops_overloads(self, conv, ops, args):
                for op in ops:
                        self.bind_inplace_arithmetic_op_overloads(conv, op, args)

        #
        def bind_comparison_op(self, conv, op, args, features=[]):
                self.bind_comparison_op_overloads(conv, op, [(args, features)])

        def bind_comparison_op_overloads(self, conv, op, args):
                assert op in [&#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;==&#39;, &#39;!=&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;], &#39;Unsupported comparison operator &#39; + op

                expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
                proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))
                protos = [(&#39;bool&#39;, arg[0], arg[1]) for arg in args]

                self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;comparison_op&#39;, 1)
                conv.comparison_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def bind_comparison_ops(self, conv, ops, args, features=[]):
                for op in ops:
                        self.bind_comparison_op(conv, op, args, features)

        def bind_comparison_ops_overloads(self, conv, ops, protos):
                for op in ops:
                        self.bind_comparison_op_overloads(conv, op, protos)

        #
        def get_type_tag_cast_function(self):
                out = &#39;// type_tag based cast system\n&#39;

                def output_type_tag_cast_tree(expr):
                        out = []

                        i = 0
                        for conv in self._bound_types:
                                if len(conv._casts) == 0:
                                        continue

                                out.append(&#39;    &#39; if i == 0 else &#39; else &#39;)
                                out.append(&#39;if (in_type_tag == %s) {\n&#39; % conv.type_tag)

                                for j, cast in enumerate(conv._casts):
                                        out.append(&#39;    &#39; if j == 0 else &#39; else &#39;)
                                        out.append(&#39;if (out_type_tag == %s) {\n&#39; % cast[0].type_tag)
                                        out.append(expr(cast))
                                        out.append(&#39;}\n&#39;)

                                out.append(&#39;}\n&#39;)
                                i += 1

                        return &#39;&#39;.join(out)

                # can cast
                out += &#39;&#39;&#39;\
static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag) {
        if (out_type_tag == in_type_tag)
                return true;

        %s
        return false;
}\n\n&#39;&#39;&#39; % output_type_tag_cast_tree(lambda cast: &#39;     return true;\n&#39;)

                # cast
                out += &#39;&#39;&#39;\
static void *_type_tag_cast(void *in_ptr, uint32_t in_type_tag, uint32_t out_type_tag) {
        if (out_type_tag == in_type_tag)
                return in_ptr;

        void *out_ptr = NULL;
        %s

        return out_ptr;
}\n\n&#39;&#39;&#39; % output_type_tag_cast_tree(lambda cast: cast[1](&#39;in_ptr&#39;, &#39;out_ptr&#39;))

                return out

        def bind_cast_functions(self):
                upcasts = {}
                for conv in self._bound_types:
                        if not conv.nobind:
                                if conv not in upcasts:
                                        upcasts[conv] = []
                                for cast in conv._casts:
                                        if not cast[0].nobind and cast[0] not in upcasts[conv]:
                                                upcasts[conv].append(cast[0])

                for conv, casts in upcasts.items():
                        for cast in casts:
                                name = &#39;_Cast_%s_To_%s&#39; % (cast.bound_name, conv.bound_name)
                                self.insert_binding_code(&#39;static %s *%s(%s *o) { return (%s *)o; }&#39; % (repr(conv.ctype), name, repr(cast.ctype), repr(conv.ctype)))
                                self.bind_function(name, repr(conv.ctype) + &#39; *&#39;, [repr(cast.ctype) + &#39; *o&#39;], [], name[1:])

        def __get_stats(self):  # pragma: no cover
                out = &#39;Module statistics:\n&#39;

                out += &#39; - %d types\n&#39; % len(self.__type_convs)
                out += &#39; - %d functions\n&#39; % len(self._bound_functions)
                out += &#39; - %d enums\n&#39; % len(self._enums)
                out += &#39; - %d extern types\n&#39; % len(self._extern_types)

                method_count, static_method_count, member_count, static_member_count = 0, 0, 0, 0

                for name, conv in self.__type_convs.items():
                        method_count += len(conv.methods)
                        static_method_count += len(conv.static_methods)
                        member_count += len(conv.members)
                        static_member_count += len(conv.static_members)

                out += &#39; - %d methods\n&#39; % method_count
                out += &#39; - %d static methods\n&#39; % static_method_count
                out += &#39; - %d member\n&#39; % member_count
                out += &#39; - %d static member\n&#39; % static_member_count

                return &#34;&#34;

        def __print_stats(self):  # pragma: no cover
                print(self.__get_stats())

        def output_linker_api(self):
                link_func = self.apply_api_prefix(&#39;link_binding&#39;)

                self._header += &#39;&#39;&#39;\
/*
        pass the get_c_type_info function from another binding to this function to resolve external types declared in this binding.
        you will need to write a wrapper to cast the type_info * pointer to the correct type if you are using a binding prefix.
        this function returns the number of unresolved external symbols.
*/
size_t %s(%s *(*get_c_type_info)(const char *));\n
&#39;&#39;&#39; % (link_func, self.apply_api_prefix(&#39;type_info&#39;))

                self._source += &#39;&#39;&#39;\
size_t %s(%s *(*get_c_type_info)(const char *type)) {
        size_t unresolved = 0;\n
&#39;&#39;&#39; % (link_func, self.apply_api_prefix(&#39;type_info&#39;))

                for extern_type in self._extern_types:
                        self._source += &#39;&#39;&#39;\
        if (%s == nullptr) {
                if (%s *info = (*get_c_type_info)(&#34;%s&#34;)) {
                        %s = info-&gt;check;
                        %s = info-&gt;to_c;
                        %s = info-&gt;from_c;
                } else {
                        ++unresolved;
                }
        }

&#39;&#39;&#39; % (
                extern_type.check_func,
                self.apply_api_prefix(&#39;type_info&#39;),
                extern_type.ctype,
                extern_type.check_func,
                extern_type.to_c_func,
                extern_type.from_c_func
        )

                self._source += &#39;&#39;&#39;\
        return unresolved;
}

&#39;&#39;&#39;

        def finalize(self):
                # insert includes
                system_includes = &#39;&#39;
                if len(self.__system_includes) &gt; 0:
                        system_includes = &#39;&#39;.join([&#39;#include &lt;%s&gt;\n&#39; % path for path in self.__system_includes])

                user_includes = &#39;&#39;
                if len(self.__user_includes) &gt; 0:
                        user_includes = &#39;&#39;.join([&#39;#include &#34;%s&#34;\n&#39; % path for path in self.__user_includes])

                self._source = self._source.replace(&#39;{{{__WRAPPER_INCLUDES__}}}&#39;, system_includes + user_includes)

                # cast to
                self._source += self.get_type_tag_cast_function()
                self.bind_cast_functions()

                # commit all function declarations
                self.__commit_function_declarations()

                # statistics
                if self.verbose:  # pragma: no cover
                        self.__print_stats()

                # extern types linker API
                self.output_linker_api()

        def get_output(self):
                return {
                        &#39;bind_%s.h&#39; % self.get_language(): self._header,
                        &#39;bind_%s.cpp&#39; % self.get_language(): self._source
                }

        def _build_protos(self, protos):
                return self.__prepare_protos(self.__expand_protos(protos))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gen.add_list_unique"><code class="name flex">
<span>def <span class="ident">add_list_unique</span></span>(<span>lst, val, dlg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_list_unique(lst, val, dlg):
        for ent in lst:
                if dlg(val, ent):
                        return
        lst.append(val)</code></pre>
</details>
</dd>
<dt id="gen.apply_api_prefix"><code class="name flex">
<span>def <span class="ident">apply_api_prefix</span></span>(<span>symbol)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_api_prefix(symbol):
        return &#39;%s_%s&#39; % (api_prefix, symbol) if api_prefix else symbol</code></pre>
</details>
</dd>
<dt id="gen.clean_name_with_title"><code class="name flex">
<span>def <span class="ident">clean_name_with_title</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_name_with_title(name):
        new_name = &#34;&#34;
        if &#34;_&#34; in name:
                # redo a special string.title()
                next_is_forced_uppercase = True
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;]:
                                new_name += c
                        elif c in [&#34;_&#34;, &#34;-&#34;]:
                                next_is_forced_uppercase = True
                        else:
                                if next_is_forced_uppercase:
                                        next_is_forced_uppercase = False
                                        new_name += c.capitalize()
                                else:
                                        new_name += c
        else:
                # make sur the first letter is captialize
                first_letter_checked = False
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;] or first_letter_checked:
                                new_name += c
                        elif not first_letter_checked:
                                first_letter_checked = True
                                new_name += c.capitalize()
        return new_name.strip().replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="gen.collect_attr_from_conv_recursive"><code class="name flex">
<span>def <span class="ident">collect_attr_from_conv_recursive</span></span>(<span>out, conv, attr, dlg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_attr_from_conv_recursive(out, conv, attr, dlg):
        for entry in getattr(conv, attr):
                add_list_unique(out, entry, dlg)
        for base in conv._bases:
                collect_attr_from_conv_recursive(out, base, attr, dlg)
        return out</code></pre>
</details>
</dd>
<dt id="gen.ctype_ref_to"><code class="name flex">
<span>def <span class="ident">ctype_ref_to</span></span>(<span>src_ref, dst_ref)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctype_ref_to(src_ref, dst_ref):
        i = 0
        while i &lt; len(src_ref) and i &lt; len(dst_ref):
                if src_ref[i] != dst_ref[i]:
                        break
                i += 1

        src_ref = src_ref[i:]
        dst_ref = dst_ref[i:]

        if src_ref == &#39;&amp;&#39;:
                if dst_ref == &#39;&amp;&#39;:
                        return &#39;&#39;  # ref to ref
                elif dst_ref == &#39;*&#39;:
                        return &#39;&amp;&#39;  # ref to ptr
                else:
                        return &#39;&#39;  # ref to value
        elif src_ref == &#39;*&#39;:
                if dst_ref == &#39;&amp;&#39;:
                        return &#39;*&#39;  # ptr to ref
                elif dst_ref == &#39;*&#39;:
                        return &#39;&#39;  # ptr to ptr
                else:
                        return &#39;*&#39;  # ptr to value
        else:
                if dst_ref == &#39;&amp;&#39;:
                        return &#39;&#39;  # value to ref
                elif dst_ref == &#39;*&#39;:
                        return &#39;&amp;&#39;  # value to ptr
                else:
                        return &#39;&#39;  # value to value</code></pre>
</details>
</dd>
<dt id="gen.ctype_to_plain_string"><code class="name flex">
<span>def <span class="ident">ctype_to_plain_string</span></span>(<span>ctype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctype_to_plain_string(ctype):
        parts = []

        if ctype.const:
                parts.append(&#39;const&#39;)
        if ctype.signed:
                parts.append(&#39;signed&#39;)
        if ctype.unsigned:
                parts.append(&#39;unsigned&#39;)

        _ctype = ctype.scoped_typename.parts[-1]  # ignore namespace entries (only consider last type in chain)
        _name = _ctype.name.replace(&#39;::&#39;, &#39;_&#39;).replace(&#39;:&#39;, &#39;_&#39;)

        parts.append(_name)

        if hasattr(_ctype, &#39;template&#39;):
                if hasattr(_ctype.template, &#39;function&#39;):
                        function = _ctype.template.function

                        parts.append(&#39;returning&#39;)

                        if hasattr(function, &#39;void_rval&#39;):
                                parts.append(&#39;void&#39;)
                        else:
                                parts.append(ctype_to_plain_string(function.rval))

                        if hasattr(function, &#39;args&#39;):
                                parts.append(&#39;taking&#39;)
                                for arg in function.args:
                                        parts.append(ctype_to_plain_string(arg))
                else:
                        parts.append(&#39;of_&#39; + &#39;_and_&#39;.join([ctype_to_plain_string(arg) for arg in _ctype.template.args]))

        if ctype.const_ref:
                parts.append(&#39;const&#39;)
        if hasattr(ctype, &#39;ref&#39;):
                parts.append(ref_to_string(ctype.ref))

        return &#39;_&#39;.join(parts)</code></pre>
</details>
</dd>
<dt id="gen.format_list_for_comment"><code class="name flex">
<span>def <span class="ident">format_list_for_comment</span></span>(<span>lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_list_for_comment(lst):
        ln = len(lst)

        if ln == 0:
                return &#39;&#39;
        if ln == 1:
                return lst[0]
        if ln == 2:
                return &#39;%s or %s&#39; % (lst[0], lst[1])

        return &#39;, &#39;.join(lst[:-1]) + &#39; or &#39; + lst[-1]</code></pre>
</details>
</dd>
<dt id="gen.get_clean_symbol_name"><code class="name flex">
<span>def <span class="ident">get_clean_symbol_name</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a string cleaned so that it may be used as a valid symbol name in the generator output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clean_symbol_name(name):
        &#34;&#34;&#34; Return a string cleaned so that it may be used as a valid symbol name in the generator output.&#34;&#34;&#34;

        parts = name.split(&#39; &#39;)

        def clean_symbol_name_part(part):
                for f_o, f_d in symbol_clean_rules.items():
                        part = part.replace(f_o, f_d)
                return part

        parts = [clean_symbol_name_part(part) for part in parts]
        return &#39;_&#39;.join(parts)</code></pre>
</details>
</dd>
<dt id="gen.get_ctype_default_bound_name"><code class="name flex">
<span>def <span class="ident">get_ctype_default_bound_name</span></span>(<span>ctype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ctype_default_bound_name(ctype):
        ctype = copy.deepcopy(ctype)
        ctype.scoped_typename.explicit_global = False
        return ctype_to_plain_string(ctype)</code></pre>
</details>
</dd>
<dt id="gen.get_fabgen_api"><code class="name flex">
<span>def <span class="ident">get_fabgen_api</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fabgen_api():
                return &#39;&#39;&#39;\
// FABgen .h

#pragma once

enum OwnershipPolicy { NonOwning, Copy, Owning };
&#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="gen.get_fully_qualified_ctype_name"><code class="name flex">
<span>def <span class="ident">get_fully_qualified_ctype_name</span></span>(<span>ctype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fully_qualified_ctype_name(ctype):
        parts = []

        if ctype.const:
                parts.append(&#39;const&#39;)
        if ctype.signed:
                parts.append(&#39;signed&#39;)
        if ctype.unsigned:
                parts.append(&#39;unsigned&#39;)

        if hasattr(ctype, &#39;template&#39;):
                if hasattr(ctype.template, &#39;args&#39;):
                        parts.append(ctype.name + &#39;&lt;%s&gt;&#39; % &#39;, &#39;.join([str(arg) for arg in ctype.template.args]))
                elif hasattr(ctype.template, &#39;function&#39;):
                        parts.append(ctype.name + &#39;&lt;%s&gt;&#39; % get_fully_qualified_function_signature(ctype.template.function))
        else:
                parts.append(repr(ctype.scoped_typename))

        if ctype.const_ref:
                parts.append(&#39;const&#39;)
        if hasattr(ctype, &#39;ref&#39;):
                parts.append(ctype.ref)

        return &#39; &#39;.join(parts)</code></pre>
</details>
</dd>
<dt id="gen.get_fully_qualified_function_signature"><code class="name flex">
<span>def <span class="ident">get_fully_qualified_function_signature</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fully_qualified_function_signature(func):
        out = &#39;&#39;
        #Get return type
        if hasattr(func, &#39;void_rval&#39;): # void return type
                out += &#39;void&#39;
        else:
                out += str(func.rval) # return type
        #Get all arguments from the Ctype function
        if hasattr(func, &#39;args&#39;):
                args = [str(arg) for arg in func.args]
                out += &#39;(%s)&#39; % &#39;, &#39;.join(args)
        else: #No arguments
                out += &#39;()&#39;

        return out #return a string of the form rtype [arg1,arg2...]</code></pre>
</details>
</dd>
<dt id="gen.get_symbol_default_bound_name"><code class="name flex">
<span>def <span class="ident">get_symbol_default_bound_name</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_symbol_default_bound_name(name):
        if isinstance(name, str):  # no namespace
                name = strip_namespace(name)
        else:
                name = name.naked_name()

        return get_clean_symbol_name(name)</code></pre>
</details>
</dd>
<dt id="gen.ref_to_string"><code class="name flex">
<span>def <span class="ident">ref_to_string</span></span>(<span>ref)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ref_to_string(ref):
        parts = []
        for e in ref:
                if ref == &#39;*&#39;:
                        parts.append(&#39;ptr&#39;)
                elif ref == &#39;&amp;&#39;:
                        parts.append(&#39;ref&#39;)
        return &#39;_&#39;.join(parts)</code></pre>
</details>
</dd>
<dt id="gen.strip_namespace"><code class="name flex">
<span>def <span class="ident">strip_namespace</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_namespace(name):
        parts = name.split(&#39;::&#39;)
        return parts[-1] if len(parts) &gt; 1 else name</code></pre>
</details>
</dd>
<dt id="gen.transform_var_ref_to"><code class="name flex">
<span>def <span class="ident">transform_var_ref_to</span></span>(<span>var, from_ref, to_ref)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_var_ref_to(var, from_ref, to_ref):
        if isinstance(var, _ScopedTypename):
                var = var.naked_name()
        return ctype_ref_to(from_ref, to_ref) + var</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gen.FABGen"><code class="flex name class">
<span>class <span class="ident">FABGen</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FABGen:
        def __init__(self):
                self.verbose = True
                self.embedded = False
                self.check_self_type_in_ops = False
                self.defines = []

        def apply_api_prefix(self, symbol):
                return apply_api_prefix(symbol)

        def get_language(self):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def parse_ctype(self, type):
                return parse(type, _CType)

        def parse_named_ctype(self, type):
                type = type.replace(&#39;* *&#39;, &#39;**&#39;)
                return parse(type, _NamedCType)

        def ctype_to_plain_string(self, ctype):
                return ctype_to_plain_string(ctype)

        get_symbol_doc_hook = lambda gen, name: &#34;&#34;

        def get_symbol_doc(self, name):
                return self.get_symbol_doc_hook(name)

        def output_header(self):
                common = &#34;// This file is automatically generated, do not modify manually!\n\n&#34;

                self._source += &#34;// FABgen output .cpp\n&#34;
                self._source += common
                self._source += &#39;#include &#34;fabgen.h&#34;\n\n&#39;

                self._header += &#39;// FABgen output .h\n&#39;
                self._header += common
                self._header += &#39;#pragma once\n\n&#39;
                self._header += &#39;#include &lt;cstdint&gt;\n\n&#39;
                self._header += &#39;#include &lt;cstddef&gt;\n\n&#39;

        def output_includes(self):
                self.add_include(&#39;cstdint&#39;, True)
                self.add_include(&#39;cassert&#39;, True)
                self.add_include(&#39;map&#39;, True)

                self._source += &#39;{{{__WRAPPER_INCLUDES__}}}\n&#39;

        def start(self, name):
                self._name = name
                self._header, self._source = &#34;&#34;, &#34;&#34;

                self.__system_includes, self.__user_includes = [], []

                self.__type_convs = {}
                self.__function_declarations = {}

                self._bound_types = []  # list of bound types
                self._bound_functions = []  # list of bound functions
                self._bound_variables = []  # list of bound variables
                self._enums = {}  # list of bound enumerations

                self._extern_types = []  # list of extern types

                self._custom_init_code = &#34;&#34;
                self._custom_free_code = &#34;&#34;

                self.output_header()
                self.output_includes()

                self._source += &#39;static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag);\n&#39;
                self._source += &#39;static void *_type_tag_cast(void *in_T0, uint32_t in_type_tag, uint32_t out_type_tag);\n\n&#39;

        def add_include(self, path, is_system=False):
                if is_system:
                        if path not in self.__system_includes:
                                self.__system_includes.append(path)
                else:
                        if path not in self.__user_includes:
                                self.__user_includes.append(path)

        def insert_code(self, code, in_source=True, in_header=True):
                if in_header:
                        self._header += code
                if in_source:
                        self._source += code

        def insert_binding_code(self, code, comment=None):
                parts = []
                if comment is not None:
                        parts.append(&#39;// %s\n&#39; % comment)
                parts.append(code)
                parts.append(&#39;\n&#39;)
                self._source += &#39;&#39;.join(parts)

        def add_custom_init_code(self, code):
                self._custom_init_code += code

        def add_custom_free_code(self, code):
                self._custom_free_code += code

        #
        def defined(self, symbol):
                return symbol in self.defines

        #
        def begin_type(self, conv, features, nobind=False):
                &#34;&#34;&#34;Declare a new type converter.&#34;&#34;&#34;
                if False:#self.verbose:
                        print(&#39;Binding type %s (%s)&#39; % (conv.bound_name, conv.ctype))

                self._header += conv.get_type_api(self._name)

                self._source += &#39;// %s type tag\n&#39; % conv.ctype
                self._source += &#39;static uint32_t %s = %s;\n\n&#39; % (conv.type_tag, hex(zlib.crc32(conv.bound_name.encode()) &amp; 0xffffffff))

                self._source += conv.get_type_api(self._name)

                conv.nobind = nobind
                conv._features = copy.deepcopy(features)

                self._bound_types.append(conv)
                self.__type_convs[repr(conv.ctype)] = conv

                feats = list(conv._features.values())
                for feat in feats:
                        if hasattr(feat, &#39;init_type_converter&#39;):
                                feat.init_type_converter(self, conv)  # init converter feature

                return conv

        def end_type(self, conv):
                type_glue = conv.get_type_glue(self, self._name)
                self._source += type_glue + &#39;\n&#39;

        def bind_type(self, conv, features={}):
                self.begin_type(conv, features)
                self.end_type(conv)
                return conv

        #
        def typedef(self, type, alias_of, to_c_storage_type=None, bound_name=None):
                conv = copy.deepcopy(self.__type_convs[alias_of])

                default_arg_storage_type = type if to_c_storage_type is None else to_c_storage_type

                if bound_name is not None:
                        conv.bound_name=bound_name
                conv.ctype = parse(type, _CType)
                conv.to_c_storage_ctype = parse(default_arg_storage_type, _CType)

                self.__type_convs[type] = conv

        #
        def bind_named_enum(self, name, symbols, storage_type=&#39;int&#39;, bound_name=None, prefix=&#39;&#39;, namespace=None):
                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)

                self.typedef(name, storage_type, bound_name=bound_name)

                if namespace is None:
                        namespace = name

                enum = {}
                for symbol in symbols:
                        enum[prefix + symbol] = &#39;%s::%s&#39; % (namespace, symbol)

                self._enums[bound_name] = enum

        #
        def begin_class(self, type, converter_class=None, noncopyable=False, moveable=False, bound_name=None, features={}, nobind=False):
                &#34;&#34;&#34;Begin a class declaration.&#34;&#34;&#34;
                if type in self.__type_convs:
                        return self.__type_convs[type]  # type already declared

                default_storage_type = type + &#39;*&#39;

                conv = self.default_class_converter(type, default_storage_type, bound_name) if converter_class is None else converter_class(type, default_storage_type, bound_name)
                conv = self.begin_type(conv, features, nobind)

                conv._non_copyable = noncopyable
                conv._moveable = moveable
                return conv

        def end_class(self, conv):
                &#34;&#34;&#34;End a class declaration.&#34;&#34;&#34;
                self.end_type(conv)

        #
        def bind_extern_type(self, type, bound_name=None, module=None):
                &#34;&#34;&#34;Bind an external type.&#34;&#34;&#34;
                if type in self.__type_convs:
                        return self.__type_convs[type]  # type already declared

                default_storage_type = type + &#39;*&#39;

                conv = self.default_extern_converter(type, default_storage_type, bound_name, module)

                if self.verbose:
                        print(&#39;Binding extern type %s (%s)&#39; % (conv.bound_name, conv.ctype))

                self._header += conv.get_type_api(self._name)
                self._source += conv.get_type_api(self._name)

                self._extern_types.append(conv)
                self.__type_convs[repr(conv.ctype)] = conv

                self._source += conv.get_type_glue(self, self._name) + &#39;\n&#39;
                return conv

        #
        def bind_ptr(self, type, converter_class=None, bound_name=None, features={}):
                if type in self.__type_convs:
                        return self.__type_convs[type]  # type already declared

                conv = self.default_ptr_converter(type, None, bound_name) if converter_class is None else converter_class(type, None, bound_name)
                self.bind_type(conv, features)

                return conv

        #
        def add_cast(self, src_conv, tgt_conv, cast_delegate):
                &#34;&#34;&#34;Declare a cast delegate from one type to another.&#34;&#34;&#34;
                src_conv._casts.append((tgt_conv, cast_delegate))

        #
        def __add_upcast(self, conv, base):
                self.add_cast(conv, base, lambda in_var, out_var: &#39;%s = (%s *)((%s *)%s);\n&#39; % (out_var, base.ctype, conv.ctype, in_var))
                for base_of_base in base._bases:
                        self.__add_upcast(conv, base_of_base)

        def add_base(self, conv, base):
                self.__add_upcast(conv, base)
                conv._bases.append(base)

        def add_bases(self, conv, bases):
                for base in bases:
                        self.add_base(conv, base)

        #
        def select_ctype_conv(self, ctype):
                &#34;&#34;&#34;Select a type converter.&#34;&#34;&#34;
                if repr(ctype) == &#39;void&#39;:
                        return None

                while True:
                        type = repr(ctype)
                        if type in self.__type_convs:
                                return self.__type_convs[type]

                        type = repr(ctype.non_const())
                        if type in self.__type_convs:
                                return self.__type_convs[type]

                        if ctype.get_ref() == &#39;&#39;:
                                break
                        #alt 
                        ctype = ctype.dereference_once()

                raise Exception(&#34;Unknown type %s (no converter available)&#34; % ctype)

        def get_conv(self, type):
                return self.__type_convs[type]

        #
        def decl_var(self, ctype, name, eol=&#39;;\n&#39;):
                return &#39;%s %s%s&#39; % (get_fully_qualified_ctype_name(ctype), name, eol)

        #
        def select_args_convs(self, args):
                return [{&#39;conv&#39;: self.select_ctype_conv(arg.ctype), &#39;ctype&#39;: arg.ctype} for i, arg in enumerate(args)]

        #
        def commit_from_c_vars(self, rval, ctx):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def rval_assign_arg_in_out(self, out_var, arg_in_out):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        #
        def proxy_call_error(self, msg, ctx):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        #
        def __ctype_to_ownership_policy(self, ctype):
                return &#39;Copy&#39; if ctype.get_ref() == &#39;&#39; else &#39;NonOwning&#39;

        # --
        def __expand_protos(self, protos):
                _protos = []

                for proto in protos:
                        _proto = (proto[0], [], proto[2])

                        for arg in proto[1]:
                                if arg.startswith(&#39;?&#39;):
                                        _protos.append(_proto)
                                        _proto = copy.deepcopy(_proto)
                                        arg = arg[1:]

                                _proto[1].append(arg)

                        _protos.append(_proto)

                return _protos

        def __prepare_protos(self, protos):
                &#34;&#34;&#34;Prepare a list of prototypes, select converter objects&#34;&#34;&#34;
                _protos = []

                for proto in protos:
                        assert len(proto) == 3, &#34;prototype incomplete. Expected 3 entries (type, [arguments], [features]), found %d&#34; % len(proto)

                        rval_type, args, features = proto

                        rval_ctype = parse(rval_type, _CType)
                        rval_conv = self.select_ctype_conv(rval_ctype)

                        if rval_conv is not None and rval_conv.from_c_storage_ctype is not None:
                                from_c_storage_ctype = rval_conv.from_c_storage_ctype
                        else:
                                from_c_storage_ctype = rval_ctype  # prepare the return value variable CType
                                if from_c_storage_ctype.get_ref() == &#39;&#39;:
                                        from_c_storage_ctype = from_c_storage_ctype.non_const()

                        _proto = {&#39;rval&#39;: {&#39;storage_ctype&#39;: from_c_storage_ctype, &#39;conv&#39;: rval_conv}, &#39;args&#39;: [], &#39;argsin&#39;: [], &#39;features&#39;: features}

                        if not type(args) is type([]):
                                args = [args]

                        for arg in args:
                                carg = self.parse_named_ctype(arg)
                                conv = self.select_ctype_conv(carg.ctype)
                                _proto[&#39;args&#39;].append({&#39;carg&#39;: carg, &#39;conv&#39;: conv, &#39;check_var&#39;: None})

                        # prepare argsin, a list of arguments that should be provided by the caller
                        _proto[&#39;argsin&#39;] = _proto[&#39;args&#39;]  # default to the full arg list

                        if &#39;arg_out&#39; in features:  # exclude output arguments from the argsin list
                                _proto[&#39;argsin&#39;] = [arg for arg in _proto[&#39;args&#39;] if arg[&#39;carg&#39;].name.naked_name() not in _proto[&#39;features&#39;][&#39;arg_out&#39;]]

                        _protos.append(_proto)

                # compute suggested_suffix if language doesn&#39;t support overload
                if len(_protos) &gt; 1:
                        # get the base one, usually the first one with the less args
                        id_base = 0
                        proto_base = _protos[id_base]
                        for id, proto in enumerate(_protos[1:]):
                                if len(proto[&#34;args&#34;]) &lt; len(proto_base[&#34;args&#34;]):
                                        proto_base = proto
                                        id_base = id + 1

                        suggested_suffixes = []
                        
                        for id, proto in enumerate(_protos):
                                if id == id_base:
                                        continue
                                
                                # check members difference
                                def get_suggested_suffix(with_type = False):
                                        suggested_suffix = &#34;&#34;
                                        for i, arg in enumerate(proto[&#34;args&#34;]):
                                                if i &gt;= len(proto_base[&#34;args&#34;]) or proto_base[&#34;args&#34;][i][&#34;carg&#34;].name != arg[&#34;carg&#34;].name or str(proto_base[&#34;args&#34;][i][&#34;carg&#34;].ctype) != str(arg[&#34;carg&#34;].ctype):
                                                        if suggested_suffix == &#34;&#34;:
                                                                suggested_suffix = &#34;With&#34;
                                                        if with_type:
                                                                if arg[&#34;conv&#34;].bound_name is not None:
                                                                        suggested_suffix += clean_name_with_title(str(arg[&#34;conv&#34;].bound_name))
                                                                else:
                                                                        suggested_suffix += clean_name_with_title(str(arg[&#39;carg&#39;].ctype))

                                                                if suggested_suffix.endswith(&#34;_nobind&#34;) and arg[&#34;conv&#34;].nobind:
                                                                        suggested_suffix = suggested_suffix[:-len(&#34;_nobind&#34;)]

                                                        suggested_suffix += clean_name_with_title(str(arg[&#34;carg&#34;].name))
                                        return suggested_suffix

                                suggested_suffix = get_suggested_suffix()
                                
                                # check if this suffix already exists
                                if suggested_suffix in suggested_suffixes:
                                        # recheck the suggested suffix, but with the type
                                        suggested_suffix = get_suggested_suffix(True)

                                suggested_suffixes.append(suggested_suffix)

                                proto[&#34;suggested_suffix&#34;] = suggested_suffix

                return _protos

        def __assert_conv_feature(self, conv, feature):
                assert feature in conv._features, &#34;Type converter for %s does not support the %s feature&#34; % (conv.ctype, feature)

        #
        def _prepare_to_c_self(self, conv, out_var, ctx=&#39;none&#39;, features=[]):
                out = &#39;&#39;
                if &#39;proxy&#39; in features:
                        proxy = conv._features[&#39;proxy&#39;]

                        out += &#39;        &#39; + self.decl_var(conv.to_c_storage_ctype, &#39;%s_wrapped&#39; % out_var)
                        out += &#39;        &#39; + conv.to_c_call(self.get_self(ctx), &#39;&amp;%s_wrapped&#39; % out_var)

                        out += &#39;        &#39; + self.decl_var(proxy.wrapped_conv.to_c_storage_ctype, out_var)
                        out += proxy.unwrap(&#39;%s_wrapped&#39; % out_var, out_var)
                else:
                        out += &#39;        &#39; + self.decl_var(conv.to_c_storage_ctype, out_var)
                        out += &#39;        &#39; + conv.to_c_call(self.get_self(ctx), &#39;&amp;%s&#39; % out_var)
                return out

        def _declare_to_c_var(self, ctype, var):
                return self.decl_var(ctype, var)

        def _convert_to_c_var(self, idx, conv, var, ctx=&#39;default&#39;, features=[]):
                out = conv.to_c_call(self.get_var(idx, ctx), &#39;&amp;%s&#39; % var)

                if &#39;validate_arg_in&#39; in features:
                        validator = features[&#39;validate_arg_in&#39;][idx]
                        if validator is not None:
                                out += validator(self, var, ctx)

                return out

        def prepare_to_c_var(self, idx, conv, var, ctx=&#39;default&#39;, features=[]):
                return self._declare_to_c_var(conv.to_c_storage_ctype, var) + self._convert_to_c_var(idx, conv, var, ctx, features)

        #
        def declare_from_c_var(self, out_var):
                return &#39;&#39;

        def prepare_from_c_var(self, rval):
                if rval[&#39;ownership&#39;] is None:
                        rval[&#39;ownership&#39;] = self.__ctype_to_ownership_policy(rval[&#39;ctype&#39;])

                # transform from {T&amp;, T*, T**, ...} to T* where T is conv.ctype
                expr = transform_var_ref_to(rval[&#39;var&#39;], rval[&#39;ctype&#39;].get_ref(), rval[&#39;conv&#39;].ctype.add_ref(&#39;*&#39;).get_ref())

                out_var = (rval[&#39;var&#39;] if isinstance(rval[&#39;var&#39;], str) else rval[&#39;var&#39;].naked_name()) + &#39;_out&#39;
                src = self.declare_from_c_var(out_var)
                if &#39;rval_transform&#39; in rval[&#39;conv&#39;]._features:
                        src += rval[&#39;conv&#39;]._features[&#39;rval_transform&#39;](self, rval[&#39;conv&#39;], expr, out_var, rval[&#39;ownership&#39;])
                else:
                        check_is_valid_pointer = rval[&#39;ctype&#39;].is_pointer() or rval[&#39;conv&#39;]._is_pointer

                        if check_is_valid_pointer:
                                src += &#39;if (!%s) {\n&#39; % rval[&#39;var&#39;]
                                src += self.rval_from_nullptr(out_var)
                                src += &#39;} else {\n&#39;

                        if rval[&#39;conv&#39;].is_type_class() and rval[&#39;is_arg_in_out&#39;]:  # if an object is used as arg_out then reuse the input argument directly 
                                src += self.rval_assign_arg_in_out(out_var, self.get_var(rval[&#39;arg_idx&#39;], rval[&#39;ctx&#39;]))
                        else:
                                src += self.rval_from_c_ptr(rval[&#39;conv&#39;], out_var, expr, rval[&#39;ownership&#39;])

                        if check_is_valid_pointer:
                                src += &#39;}\n&#39;

                return src

        #
        def _proto_call(self, self_conv, proto, expr_eval, ctx, fixed_arg_count=None):
                parts = []

                features = proto[&#39;features&#39;]

                enable_proxy = &#39;proxy&#39; in features
                if enable_proxy:
                        assert ctx != &#39;function&#39;, &#34;Proxy feature cannot be used for a function call&#34;

                        if self_conv is not None:
                                self.__assert_conv_feature(self_conv, &#39;proxy&#39;)

                # prepare C call self argument
                if self_conv:
                        if ctx in [&#39;getter&#39;, &#39;setter&#39;, &#39;method&#39;, &#39;arithmetic_op&#39;, &#39;inplace_arithmetic_op&#39;, &#39;comparison_op&#39;]:
                                parts.append(self._prepare_to_c_self(self_conv, &#39;_self&#39;, ctx, features))

                # prepare C call arguments
                args = proto[&#39;args&#39;]
                arg_out = features[&#39;arg_out&#39;] if &#39;arg_out&#39; in features else None

                c_call_args = []

                argin_idx = 0
                for idx, arg in enumerate(args):
                        conv = arg[&#39;conv&#39;]

                        var = &#39;arg%d&#39; % idx

                        if arg_out is not None and arg[&#39;carg&#39;].name.naked_name() in arg_out:
                                arg_ctype = conv.ctype
                                parts.append(self._declare_to_c_var(arg_ctype, var))
                        else:
                                arg_ctype = conv.to_c_storage_ctype
                                parts.append(self._declare_to_c_var(conv.to_c_storage_ctype, var))
                                parts.append(self._convert_to_c_var(argin_idx, conv, var, ctx, features))
                                argin_idx += 1

                        c_call_args.append(transform_var_ref_to(var, arg_ctype.get_ref(), arg[&#39;carg&#39;].ctype.get_ref()))

                if &#39;arg_in_out&#39; in features:  # add in_out vars to the arg_out list
                        if arg_out is None:
                                arg_out = []
                        arg_out = arg_out + features[&#39;arg_in_out&#39;]

                # c++ exception support
                if &#39;exception&#39; in features:
                        parts.append(&#39;try {\n&#39;)

                # declare return value
                rvals = []
                rvals_prepare_args = []

                if ctx == &#39;constructor&#39;:
                        rval_conv = proto[&#39;rval&#39;][&#39;conv&#39;]
                        from_c_storage_ctype = proto[&#39;rval&#39;][&#39;storage_ctype&#39;].add_ref(&#39;*&#39;)  # constructor returns a pointer

                        ownership = &#39;Owning&#39;  # constructor output is always owned by the VM

                        if enable_proxy:
                                proxy = rval_conv._features[&#39;proxy&#39;]

                                parts.append(self.decl_var(proxy.wrapped_conv.ctype.add_ref(&#39;*&#39;), &#39;rval_raw&#39;, &#39; = &#39;))
                                parts.append(&#39;new %s(%s);\n&#39; % (proxy.wrapped_conv.ctype, &#39;, &#39;.join(c_call_args)))

                                parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;))
                                parts.append(proxy.wrap(&#39;rval_raw&#39;, &#39;rval&#39;))
                        else:
                                if &#39;route&#39; in features:
                                        parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;, &#39; = &#39;))

                                        expr_eval = features[&#39;route&#39;]  # hijack the output expression
                                        parts.append(expr_eval(c_call_args) + &#39;\n&#39;)
                                else:
                                        if rval_conv._inline:
                                                if len(c_call_args) &gt; 0:
                                                        parts.append(&#39;%s _new_obj(%s);\n&#39; % (rval_conv.ctype, &#39;, &#39;.join(c_call_args)))  # construct new inline object on the stack
                                                else:
                                                        parts.append(&#39;%s _new_obj;\n&#39; % rval_conv.ctype)
                                                ownership = &#39;Copy&#39;  # inline objects are constructed on the heap then copy constructed to the VM memory block

                                        parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;, &#39; = &#39;))

                                        if rval_conv._inline:
                                                parts.append(&#39;&amp;_new_obj;\n&#39;)
                                        else:
                                                parts.append(&#39;new %s(%s);\n&#39; % (rval_conv.ctype, &#39;, &#39;.join(c_call_args)))

                        rvals_prepare_args.append({&#39;conv&#39;: rval_conv, &#39;ctype&#39;: from_c_storage_ctype, &#39;var&#39;: &#39;rval&#39;, &#39;is_arg_in_out&#39;: False, &#39;ctx&#39;: ctx, &#39;ownership&#39;: ownership})
                        rvals.append(&#39;rval&#39;)
                else:
                        rval_conv = proto[&#39;rval&#39;][&#39;conv&#39;]
                        from_c_storage_ctype = proto[&#39;rval&#39;][&#39;storage_ctype&#39;]

                        # return value is optional for a function call
                        if rval_conv:
                                parts.append(self.decl_var(from_c_storage_ctype, &#39;rval&#39;, &#39; = &#39;))

                        if &#39;route&#39; in features:
                                if self_conv:
                                        c_call_args = [&#39;_self&#39;] + c_call_args
                                expr_eval = features[&#39;route&#39;]  # hijack the output expression

                        parts.append(expr_eval(c_call_args) + &#39;\n&#39;)

                        if rval_conv:
                                ownership = None  # automatic ownership policy
                                if &#39;new_obj&#39; in features:
                                        ownership = &#39;Owning&#39;  # force ownership when the prototype is flagged to return a new object
                                elif &#39;copy_obj&#39; in features:
                                        ownership = &#39;Copy&#39;  # force copy ownership

                                rvals_prepare_args.append({&#39;conv&#39;: rval_conv, &#39;ctype&#39;: from_c_storage_ctype, &#39;var&#39;: &#39;rval&#39;, &#39;is_arg_in_out&#39;: False, &#39;ctx&#39;: ctx, &#39;ownership&#39;: ownership})
                                rvals.append(&#39;rval&#39;)

                # process arg_out
                if arg_out is not None:
                        arg_in_out = features[&#39;arg_in_out&#39;] if &#39;arg_in_out&#39; in features else []

                        for idx, arg in enumerate(args):
                                carg_name = arg[&#39;carg&#39;].name.naked_name()

                                if carg_name in arg_out:
                                        is_arg_in_out = carg_name in arg_in_out

                                        if is_arg_in_out:
                                                arg_ctype = arg[&#39;conv&#39;].to_c_storage_ctype
                                        else:
                                                arg_ctype = arg[&#39;conv&#39;].ctype

                                        rvals_prepare_args.append({&#39;conv&#39;: arg[&#39;conv&#39;], &#39;ctype&#39;: arg_ctype, &#39;var&#39;: &#39;arg%d&#39; % idx, &#39;is_arg_in_out&#39;: is_arg_in_out, &#39;arg_idx&#39;: idx, &#39;ctx&#39;: ctx, &#39;ownership&#39;: None})
                                        rvals.append(&#39;arg%d&#39; % idx)

                # check return values
                if &#39;check_rval&#39; in features:
                        parts.append(features[&#39;check_rval&#39;](rvals, ctx))

                # prepare return values ([EJ] once check is done so we don&#39;t leak)
                for rval in rvals_prepare_args:
                        parts.append(self.prepare_from_c_var(rval))

                parts.append(self.commit_from_c_vars(rvals, ctx))

                if &#39;exception&#39; in features:
                        parts.append(&#39;}\n&#39;)
                        parts.append(&#39;catch(...) {\n&#39;)
                        parts.append(self.proxy_call_error(features[&#39;exception&#39;], ctx))
                        parts.append(&#39;}\n&#39;)

                return &#39;&#39;.join(parts)

        def _bind_proxy(self, name, self_conv, protos, desc, expr_eval, ctx, fixed_arg_count=None):
                parts = []

                if self.verbose:
                        print(&#39;Binding proxy %s&#39; % name)

                protos = self.__expand_protos(protos)
                protos = self.__prepare_protos(protos)

                # categorize prototypes by number of argument they take
                def get_protos_per_arg_count(protos):
                        by_arg_count = {}
                        for proto in protos:
                                arg_count = len(proto[&#39;argsin&#39;])
                                if arg_count not in by_arg_count:
                                        by_arg_count[arg_count] = []
                                by_arg_count[arg_count].append(proto)
                        return by_arg_count


                protos_by_arg_count = get_protos_per_arg_count(protos)

                # prepare proxy function
                self.insert_code(&#39;// %s\n&#39; % desc, True, False)

                max_arg_count = max(protos_by_arg_count.keys())

                parts.append(self.open_proxy(name, max_arg_count, ctx))

                # check self
                if self.check_self_type_in_ops and ctx in [&#39;arithmetic_op&#39;, &#39;inplace_arithmetic_op&#39;, &#39;comparison_op&#39;]:
                        parts.append(&#39;if (!%s) {\n&#39; % self_conv.check_call(self.get_self(ctx)))
                        parts.append(self.proxy_call_error(&#39;incorrect type for argument 0 to %s, expected %s&#39; % (desc, self_conv.bound_name), ctx))
                        parts.append(&#39;}\n\n&#39;)

                # output dispatching logic
                def get_protos_per_arg_conv(protos, arg_idx):
                        per_arg_conv = {}
                        for proto in protos:
                                arg_conv = proto[&#39;argsin&#39;][arg_idx][&#39;conv&#39;]
                                if arg_conv not in per_arg_conv:
                                        per_arg_conv[arg_conv] = []
                                per_arg_conv[arg_conv].append(proto)
                        return per_arg_conv
                        

                has_fixed_argc = fixed_arg_count is not None

                if has_fixed_argc:
                        assert len(protos_by_arg_count) == 1 and fixed_arg_count in protos_by_arg_count

                for arg_count, protos_with_arg_count in protos_by_arg_count.items():
                        if not has_fixed_argc:
                                parts.append(&#39;  if (arg_count == %d) {\n&#39; % arg_count)

                        def output_arg_check_and_dispatch(protos, arg_idx, arg_limit):
                                parts = []
                                indent = &#39;      &#39; * (arg_idx+(2 if not has_fixed_argc else 1))

                                if arg_idx == arg_limit:
                                        assert len(protos) == 1  # there should only be exactly one prototype with a single signature
                                        parts.append(self._proto_call(self_conv, protos[0], expr_eval, ctx, fixed_arg_count))
                                        return &#39;&#39;.join(parts)

                                protos_per_arg_conv = get_protos_per_arg_conv(protos, arg_idx)

                                parts.append(indent)
                                for conv, protos_for_conv in protos_per_arg_conv.items():
                                        parts.append(&#39;if (%s) {\n&#39; % conv.check_call(self.get_var(arg_idx, ctx)))
                                        parts.append(output_arg_check_and_dispatch(protos_for_conv, arg_idx+1, arg_limit))
                                        parts.append(indent + &#39;} else &#39;)

                                parts.append(&#39;{\n&#39;)

                                expected_types = []
                                for proto in protos:
                                        proto_arg = proto[&#39;argsin&#39;][arg_idx]

                                        proto_arg_name = str(proto_arg[&#39;carg&#39;].name)
                                        proto_arg_bound_name = proto_arg[&#39;conv&#39;].bound_name

                                        expected_types.append(&#39;%s %s&#39; % (proto_arg_bound_name, proto_arg_name))

                                parts.append(self.set_error(&#39;runtime&#39;, &#39;incorrect type for argument %d to %s, expected %s&#39; % (arg_idx+1, desc, format_list_for_comment(expected_types))))
                                parts.append(indent + &#39;}\n&#39;)
                                return &#39;&#39;.join(parts)

                        parts.append(output_arg_check_and_dispatch(protos_with_arg_count, 0, arg_count))

                        if not has_fixed_argc:
                                parts.append(&#39;  } else &#39;)

                if not has_fixed_argc:
                        parts.append(&#39;{\n&#39;)
                        parts.append(self.set_error(&#39;runtime&#39;, &#39;incorrect number of arguments to %s&#39; % desc))
                        parts.append(&#39;  }\n&#39;)

                #
                parts.append(self.close_proxy(ctx))
                parts.append(&#39;\n&#39;)

                self._source += &#39;&#39;.join(parts)

        #
        def __do_bind_function_overloads(self, name, protos, bound_name=None):
                expr_eval = lambda args: &#39;%s(%s);&#39; % (name, &#39;, &#39;.join(args))

                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)
                proxy_name = apply_api_prefix(bound_name)

                self._bind_proxy(proxy_name, None, protos, &#39;function %s&#39; % bound_name, expr_eval, &#39;function&#39;)
                self._bound_functions.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def __commit_function_declarations(self):
                for name, decl in self.__function_declarations.items():
                        self.__do_bind_function_overloads(name, decl[&#39;protos&#39;], decl[&#39;bound_name&#39;])

        def bind_function(self, name, rval, args, features=[], bound_name=None):
                self.bind_function_overloads(name, [(rval, args, features)], bound_name)

        def bind_function_overloads(self, name, protos, bound_name=None):
                if not name in self.__function_declarations:
                        fn = self.__function_declarations[name] = {
                                &#39;protos&#39;: protos,
                                &#39;bound_name&#39;: bound_name
                        }
                else:
                        fn = self.__function_declarations[name]
                        assert(bound_name == fn[&#39;bound_name&#39;])  # ensure bound_name coherency
                        fn[&#39;protos&#39;] = fn[&#39;protos&#39;] + protos

        # reverse binding support
        def _get_rbind_call_signature(self, name, rval, args):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def _prepare_rbind_call(self, rval, args):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def _rbind_call(self, rval, args, success_var):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def _clean_rbind_call(self, rval, args):
                assert &#39;not implemented in this generator&#39;  # pragma: no cover

        def __get_rbind_call_signature(self, name, rval, args, output_default_args):
                return &#39;%s %s(%s%s, bool *success%s)&#39; % (rval, name, self._get_rbind_call_custom_args(), (&#39;, &#39; + &#39;, &#39;.join([str(arg) for arg in args])) if len(args) &gt; 0 else &#39;&#39;, &#39; = NULL&#39; if output_default_args else &#39;&#39;)

        def rbind_function(self, name, rval, args, internal=False):
                parts = []
                args = [self.parse_named_ctype(arg) for arg in args]

                if internal:
                        parts.append(&#39;static inline %s {\n&#39; % self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, True))
                else:
                        self._header += &#39;// C to Lua reverse binding call &#39; + name + &#39;\n&#39;
                        self._header += self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, True) + &#39;;\n\n&#39;
                        parts.append(&#39;%s {\n&#39; % self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, False))

                parts.append(self._prepare_rbind_call(rval, args))

                # prepare args
                for arg in args:
                        arg_conv = self.select_ctype_conv(arg.ctype)
                        parts.append(self.prepare_from_c_var({&#39;conv&#39;: arg_conv, &#39;ctype&#39;: arg.ctype, &#39;var&#39;: arg.name, &#39;is_arg_in_out&#39;: False, &#39;ownership&#39;: None}))

                parts.append(self.commit_from_c_vars([arg.name for arg in args], &#39;rbind_args&#39;))

                # call
                parts.append(&#39;bool _call_success_var;&#39;)
                parts.append(&#39;\n&#39; + self._rbind_call(rval, args, &#39;_call_success_var&#39;) + &#39;\n&#39;)
                parts.append(&#39;&#39;&#39;\
if (success)
        *success = _call_success_var;
&#39;&#39;&#39;)

                # rval
                if rval != &#39;void&#39;:
                        rval_conv = self.select_ctype_conv(self.parse_ctype(rval))

                        parts.append(self._declare_to_c_var(rval_conv.to_c_storage_ctype, &#39;_rbind_rval&#39;))
                        parts.append(&#39;&#39;&#39;\
if (%s) {
        %s
} else if (success != NULL) {
        *success = false;
}
&#39;&#39;&#39; % (rval_conv.check_call(self.get_var(0, &#39;rbind_rval&#39;)), self._convert_to_c_var(0, rval_conv, &#39;_rbind_rval&#39;, &#39;rbind_rval&#39;)))

                parts.append(self._clean_rbind_call(rval, args))

                if rval != &#39;void&#39;:
                        parts.append(&#39;return _rbind_rval;\n&#39;)

                parts.append(&#39;}\n&#39;)
                self._source += &#39;&#39;.join(parts)

        #
        def bind_constructor(self, conv, args, features=[]):
                self.bind_constructor_overloads(conv, [(args, features)])

        def bind_constructor_overloads(self, conv, proto_args):
                type = repr(conv.ctype)
                expr_eval = None  # unused for constructors

                protos = [(type, args[0], args[1]) for args in proto_args]
                proxy_name = apply_api_prefix(&#39;construct_%s&#39; % conv.bound_name)

                self._bind_proxy(proxy_name, conv, protos, &#39;%s constructor&#39; % conv.bound_name, expr_eval, &#39;constructor&#39;)
                conv.constructor = {&#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos}

        #
        def bind_method(self, conv, name, rval, args, features=[], bound_name=None):
                self.bind_method_overloads(conv, name, [(rval, args, features)], bound_name)

        def bind_method_overloads(self, conv, name, protos, bound_name=None):
                expr_eval = lambda args: &#39;_self-&gt;%s(%s);&#39; % (name, &#39;, &#39;.join(args))

                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)
                proxy_name = apply_api_prefix(&#39;method_%s_of_%s&#39; % (bound_name, conv.bound_name))

                self._bind_proxy(proxy_name, conv, protos, &#39;method %s of %s&#39; % (bound_name, conv.bound_name), expr_eval, &#39;method&#39;)
                conv.methods.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        #
        def bind_static_method(self, conv, name, rval, args, features=[], bound_name=None):
                self.bind_static_method_overloads(conv, name, [(rval, args, features)], bound_name)

        def bind_static_method_overloads(self, conv, name, protos, bound_name=None):
                expr_eval = lambda args: &#39;%s::%s(%s);&#39; % (conv.ctype, name, &#39;, &#39;.join(args))

                if bound_name is None:
                        bound_name = get_symbol_default_bound_name(name)
                proxy_name = apply_api_prefix(&#39;static_method_%s_of_%s&#39; % (bound_name, conv.bound_name))

                self._bind_proxy(proxy_name, conv, protos, &#39;static method %s of %s&#39; % (bound_name, conv.bound_name), expr_eval, &#39;static_method&#39;)
                conv.static_methods.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        #
        def bind_members(self, conv, members, features=[]):
                for member in members:
                        self.bind_member(conv, member, features)

        def bind_member(self, conv, member, features=[]):
                is_bitfield = member.endswith(&#39;:&#39;)
                if is_bitfield:
                        member = member[:-1]

                arg = parse(member, _NamedCType)

                # getter
                expr_eval = lambda args: &#39;_self-&gt;%s;&#39; % arg.name
                arg_ctype = arg.ctype if is_bitfield else arg.ctype.add_ref(&#39;&amp;&#39;)
                getter_protos = [(repr(arg_ctype), [], features)]
                getter_proxy_name = apply_api_prefix(&#39;get_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                self._bind_proxy(getter_proxy_name, conv, getter_protos, &#39;get member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;getter&#39;, 0)

                # setter
                if not arg.ctype.is_const():
                        expr_eval = lambda args: &#39;_self-&gt;%s = %s;&#39; % (arg.name, args[0])

                        setter_protos = [(&#39;void&#39;, [member], features)]
                        setter_proxy_name = apply_api_prefix(&#39;set_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                        self._bind_proxy(setter_proxy_name, conv, setter_protos, &#39;set member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;setter&#39;, 1)
                else:
                        setter_proxy_name = None

                conv.members.append({&#39;name&#39;: arg.name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name, &#39;is_bitfield&#39;: is_bitfield})

        #
        def bind_static_member(self, conv, member, features=[]):
                arg = parse(member, _NamedCType)

                # getter
                if &#39;proxy&#39; in features:
                        self.__assert_conv_feature(conv, &#39;proxy&#39;)
                        expr_eval = lambda args: &#39;&amp;%s::%s;&#39; % (conv._features[&#39;proxy&#39;].wrapped_conv.ctype, arg.name)
                else:
                        expr_eval = lambda args: &#39;&amp;%s::%s;&#39; % (conv.ctype, arg.name)

                getter_protos = [(repr(arg.ctype.add_ref(&#39;*&#39;)), [], features)]
                getter_proxy_name = apply_api_prefix(&#39;get_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))
                
                self._bind_proxy(getter_proxy_name, None, getter_protos, &#39;get static member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;getter&#39;, 0)

                # setter
                if not arg.ctype.is_const():
                        expr_eval = lambda args: &#39;%s::%s = %s;&#39; % (conv.ctype, arg.name, args[0])

                        setter_protos = [(&#39;void&#39;, [member], features)]
                        setter_proxy_name = apply_api_prefix(&#39;set_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                        self._bind_proxy(setter_proxy_name, None, setter_protos, &#39;set static member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;setter&#39;, 1)
                else:
                        setter_proxy_name = None

                conv.static_members.append({&#39;name&#39;: arg.name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name})

        def bind_static_members(self, conv, members, features=[]):
                for member in members:
                        self.bind_static_member(conv, member, features)

        #
        def bind_variable(self, var, features=[], bound_name=None, group=None):
                arg = self.parse_named_ctype(var)
                conv = self.select_ctype_conv(arg.ctype)

                if bound_name == None:
                        bound_name = get_symbol_default_bound_name(arg.name)

                # getter
                expr_eval = lambda args: &#39;&amp;%s;&#39; % arg.name

                getter_protos = [(repr(arg.ctype.add_ref(&#39;*&#39;)), [], features)]
                getter_proxy_name = apply_api_prefix(&#39;get_%s_variable&#39; % bound_name)

                self._bind_proxy(getter_proxy_name, None, getter_protos, &#39;get variable %s&#39; % arg.name, expr_eval, &#39;getter&#39;, 0)

                # setter
                if not(arg.ctype.is_const() or conv._non_copyable):
                        expr_eval = lambda args: &#39;%s = %s;&#39; % (arg.name, args[0])

                        setter_protos = [(&#39;void&#39;, [&#34;%s %s&#34; % (str(arg.ctype), bound_name)], features)]
                        setter_proxy_name = apply_api_prefix(&#39;set_%s_variable&#39; % bound_name)

                        self._bind_proxy(setter_proxy_name, None, setter_protos, &#39;set variable %s&#39; % arg.name, expr_eval, &#39;setter&#39;, 1)
                else:
                        setter_proxy_name = None

                self._bound_variables.append({&#39;name&#39;: arg.name, &#39;bound_name&#39;: bound_name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name, &#39;group&#39;: group})

        def bind_variables(self, vars, features=[], group=None):
                for var in vars:
                        self.bind_variable(var, features, None, group)

        #
        def bind_constant(self, type, name, value, group=None):
                self.insert_binding_code(&#39;static const %s %s = %s;\n&#39; % (type, name, value))
                self.bind_variable(&#39;const %s %s&#39; % (type, name), [], None, group)

        def bind_constants(self, type, names_values, group=None):
                for nv in names_values:
                        self.bind_constant(type, nv[0], nv[1], group)

        #
        def bind_arithmetic_op(self, conv, op, rval, args, features=[]):
                self.bind_arithmetic_op_overloads(conv, op, [(rval, args, features)])

        def bind_arithmetic_op_overloads(self, conv, op, protos):
                assert op in [&#39;-&#39;, &#39;+&#39;, &#39;*&#39;, &#39;/&#39;], &#39;Unsupported arithmetic operator &#39; + op

                expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
                proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))

                self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;arithmetic_op&#39;, 1)
                conv.arithmetic_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def bind_arithmetic_ops(self, conv, ops, rval, args, features=[]):
                for op in ops:
                        self.bind_arithmetic_op(conv, op, rval, args, features)

        def bind_arithmetic_ops_overloads(self, conv, ops, protos):
                for op in ops:
                        self.bind_arithmetic_op_overloads(conv, op, protos)

        #
        def bind_inplace_arithmetic_op(self, conv, op, args, features=[]):
                self.bind_inplace_arithmetic_op_overloads(conv, op, [(args, features)])

        def bind_inplace_arithmetic_op_overloads(self, conv, op, args):
                assert op in [&#39;-=&#39;, &#39;+=&#39;, &#39;*=&#39;, &#39;/=&#39;], &#39;Unsupported inplace arithmetic operator &#39; + op

                expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
                proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))
                protos = [(&#39;void&#39;, arg[0], arg[1]) for arg in args]

                self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;inplace_arithmetic_op&#39;, 1)
                conv.arithmetic_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def bind_inplace_arithmetic_ops(self, conv, ops, args, features=[]):
                for op in ops:
                        self.bind_inplace_arithmetic_op(conv, op, args, features)

        def bind_inplace_arithmetic_ops_overloads(self, conv, ops, args):
                for op in ops:
                        self.bind_inplace_arithmetic_op_overloads(conv, op, args)

        #
        def bind_comparison_op(self, conv, op, args, features=[]):
                self.bind_comparison_op_overloads(conv, op, [(args, features)])

        def bind_comparison_op_overloads(self, conv, op, args):
                assert op in [&#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;==&#39;, &#39;!=&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;], &#39;Unsupported comparison operator &#39; + op

                expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
                proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))
                protos = [(&#39;bool&#39;, arg[0], arg[1]) for arg in args]

                self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;comparison_op&#39;, 1)
                conv.comparison_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})

        def bind_comparison_ops(self, conv, ops, args, features=[]):
                for op in ops:
                        self.bind_comparison_op(conv, op, args, features)

        def bind_comparison_ops_overloads(self, conv, ops, protos):
                for op in ops:
                        self.bind_comparison_op_overloads(conv, op, protos)

        #
        def get_type_tag_cast_function(self):
                out = &#39;// type_tag based cast system\n&#39;

                def output_type_tag_cast_tree(expr):
                        out = []

                        i = 0
                        for conv in self._bound_types:
                                if len(conv._casts) == 0:
                                        continue

                                out.append(&#39;    &#39; if i == 0 else &#39; else &#39;)
                                out.append(&#39;if (in_type_tag == %s) {\n&#39; % conv.type_tag)

                                for j, cast in enumerate(conv._casts):
                                        out.append(&#39;    &#39; if j == 0 else &#39; else &#39;)
                                        out.append(&#39;if (out_type_tag == %s) {\n&#39; % cast[0].type_tag)
                                        out.append(expr(cast))
                                        out.append(&#39;}\n&#39;)

                                out.append(&#39;}\n&#39;)
                                i += 1

                        return &#39;&#39;.join(out)

                # can cast
                out += &#39;&#39;&#39;\
static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag) {
        if (out_type_tag == in_type_tag)
                return true;

        %s
        return false;
}\n\n&#39;&#39;&#39; % output_type_tag_cast_tree(lambda cast: &#39;     return true;\n&#39;)

                # cast
                out += &#39;&#39;&#39;\
static void *_type_tag_cast(void *in_ptr, uint32_t in_type_tag, uint32_t out_type_tag) {
        if (out_type_tag == in_type_tag)
                return in_ptr;

        void *out_ptr = NULL;
        %s

        return out_ptr;
}\n\n&#39;&#39;&#39; % output_type_tag_cast_tree(lambda cast: cast[1](&#39;in_ptr&#39;, &#39;out_ptr&#39;))

                return out

        def bind_cast_functions(self):
                upcasts = {}
                for conv in self._bound_types:
                        if not conv.nobind:
                                if conv not in upcasts:
                                        upcasts[conv] = []
                                for cast in conv._casts:
                                        if not cast[0].nobind and cast[0] not in upcasts[conv]:
                                                upcasts[conv].append(cast[0])

                for conv, casts in upcasts.items():
                        for cast in casts:
                                name = &#39;_Cast_%s_To_%s&#39; % (cast.bound_name, conv.bound_name)
                                self.insert_binding_code(&#39;static %s *%s(%s *o) { return (%s *)o; }&#39; % (repr(conv.ctype), name, repr(cast.ctype), repr(conv.ctype)))
                                self.bind_function(name, repr(conv.ctype) + &#39; *&#39;, [repr(cast.ctype) + &#39; *o&#39;], [], name[1:])

        def __get_stats(self):  # pragma: no cover
                out = &#39;Module statistics:\n&#39;

                out += &#39; - %d types\n&#39; % len(self.__type_convs)
                out += &#39; - %d functions\n&#39; % len(self._bound_functions)
                out += &#39; - %d enums\n&#39; % len(self._enums)
                out += &#39; - %d extern types\n&#39; % len(self._extern_types)

                method_count, static_method_count, member_count, static_member_count = 0, 0, 0, 0

                for name, conv in self.__type_convs.items():
                        method_count += len(conv.methods)
                        static_method_count += len(conv.static_methods)
                        member_count += len(conv.members)
                        static_member_count += len(conv.static_members)

                out += &#39; - %d methods\n&#39; % method_count
                out += &#39; - %d static methods\n&#39; % static_method_count
                out += &#39; - %d member\n&#39; % member_count
                out += &#39; - %d static member\n&#39; % static_member_count

                return &#34;&#34;

        def __print_stats(self):  # pragma: no cover
                print(self.__get_stats())

        def output_linker_api(self):
                link_func = self.apply_api_prefix(&#39;link_binding&#39;)

                self._header += &#39;&#39;&#39;\
/*
        pass the get_c_type_info function from another binding to this function to resolve external types declared in this binding.
        you will need to write a wrapper to cast the type_info * pointer to the correct type if you are using a binding prefix.
        this function returns the number of unresolved external symbols.
*/
size_t %s(%s *(*get_c_type_info)(const char *));\n
&#39;&#39;&#39; % (link_func, self.apply_api_prefix(&#39;type_info&#39;))

                self._source += &#39;&#39;&#39;\
size_t %s(%s *(*get_c_type_info)(const char *type)) {
        size_t unresolved = 0;\n
&#39;&#39;&#39; % (link_func, self.apply_api_prefix(&#39;type_info&#39;))

                for extern_type in self._extern_types:
                        self._source += &#39;&#39;&#39;\
        if (%s == nullptr) {
                if (%s *info = (*get_c_type_info)(&#34;%s&#34;)) {
                        %s = info-&gt;check;
                        %s = info-&gt;to_c;
                        %s = info-&gt;from_c;
                } else {
                        ++unresolved;
                }
        }

&#39;&#39;&#39; % (
                extern_type.check_func,
                self.apply_api_prefix(&#39;type_info&#39;),
                extern_type.ctype,
                extern_type.check_func,
                extern_type.to_c_func,
                extern_type.from_c_func
        )

                self._source += &#39;&#39;&#39;\
        return unresolved;
}

&#39;&#39;&#39;

        def finalize(self):
                # insert includes
                system_includes = &#39;&#39;
                if len(self.__system_includes) &gt; 0:
                        system_includes = &#39;&#39;.join([&#39;#include &lt;%s&gt;\n&#39; % path for path in self.__system_includes])

                user_includes = &#39;&#39;
                if len(self.__user_includes) &gt; 0:
                        user_includes = &#39;&#39;.join([&#39;#include &#34;%s&#34;\n&#39; % path for path in self.__user_includes])

                self._source = self._source.replace(&#39;{{{__WRAPPER_INCLUDES__}}}&#39;, system_includes + user_includes)

                # cast to
                self._source += self.get_type_tag_cast_function()
                self.bind_cast_functions()

                # commit all function declarations
                self.__commit_function_declarations()

                # statistics
                if self.verbose:  # pragma: no cover
                        self.__print_stats()

                # extern types linker API
                self.output_linker_api()

        def get_output(self):
                return {
                        &#39;bind_%s.h&#39; % self.get_language(): self._header,
                        &#39;bind_%s.cpp&#39; % self.get_language(): self._source
                }

        def _build_protos(self, protos):
                return self.__prepare_protos(self.__expand_protos(protos))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gen.FABGen.add_base"><code class="name flex">
<span>def <span class="ident">add_base</span></span>(<span>self, conv, base)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_base(self, conv, base):
        self.__add_upcast(conv, base)
        conv._bases.append(base)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.add_bases"><code class="name flex">
<span>def <span class="ident">add_bases</span></span>(<span>self, conv, bases)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_bases(self, conv, bases):
        for base in bases:
                self.add_base(conv, base)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.add_cast"><code class="name flex">
<span>def <span class="ident">add_cast</span></span>(<span>self, src_conv, tgt_conv, cast_delegate)</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a cast delegate from one type to another.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_cast(self, src_conv, tgt_conv, cast_delegate):
        &#34;&#34;&#34;Declare a cast delegate from one type to another.&#34;&#34;&#34;
        src_conv._casts.append((tgt_conv, cast_delegate))</code></pre>
</details>
</dd>
<dt id="gen.FABGen.add_custom_free_code"><code class="name flex">
<span>def <span class="ident">add_custom_free_code</span></span>(<span>self, code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_custom_free_code(self, code):
        self._custom_free_code += code</code></pre>
</details>
</dd>
<dt id="gen.FABGen.add_custom_init_code"><code class="name flex">
<span>def <span class="ident">add_custom_init_code</span></span>(<span>self, code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_custom_init_code(self, code):
        self._custom_init_code += code</code></pre>
</details>
</dd>
<dt id="gen.FABGen.add_include"><code class="name flex">
<span>def <span class="ident">add_include</span></span>(<span>self, path, is_system=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_include(self, path, is_system=False):
        if is_system:
                if path not in self.__system_includes:
                        self.__system_includes.append(path)
        else:
                if path not in self.__user_includes:
                        self.__user_includes.append(path)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.apply_api_prefix"><code class="name flex">
<span>def <span class="ident">apply_api_prefix</span></span>(<span>self, symbol)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_api_prefix(self, symbol):
        return apply_api_prefix(symbol)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.begin_class"><code class="name flex">
<span>def <span class="ident">begin_class</span></span>(<span>self, type, converter_class=None, noncopyable=False, moveable=False, bound_name=None, features={}, nobind=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Begin a class declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_class(self, type, converter_class=None, noncopyable=False, moveable=False, bound_name=None, features={}, nobind=False):
        &#34;&#34;&#34;Begin a class declaration.&#34;&#34;&#34;
        if type in self.__type_convs:
                return self.__type_convs[type]  # type already declared

        default_storage_type = type + &#39;*&#39;

        conv = self.default_class_converter(type, default_storage_type, bound_name) if converter_class is None else converter_class(type, default_storage_type, bound_name)
        conv = self.begin_type(conv, features, nobind)

        conv._non_copyable = noncopyable
        conv._moveable = moveable
        return conv</code></pre>
</details>
</dd>
<dt id="gen.FABGen.begin_type"><code class="name flex">
<span>def <span class="ident">begin_type</span></span>(<span>self, conv, features, nobind=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a new type converter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_type(self, conv, features, nobind=False):
        &#34;&#34;&#34;Declare a new type converter.&#34;&#34;&#34;
        if False:#self.verbose:
                print(&#39;Binding type %s (%s)&#39; % (conv.bound_name, conv.ctype))

        self._header += conv.get_type_api(self._name)

        self._source += &#39;// %s type tag\n&#39; % conv.ctype
        self._source += &#39;static uint32_t %s = %s;\n\n&#39; % (conv.type_tag, hex(zlib.crc32(conv.bound_name.encode()) &amp; 0xffffffff))

        self._source += conv.get_type_api(self._name)

        conv.nobind = nobind
        conv._features = copy.deepcopy(features)

        self._bound_types.append(conv)
        self.__type_convs[repr(conv.ctype)] = conv

        feats = list(conv._features.values())
        for feat in feats:
                if hasattr(feat, &#39;init_type_converter&#39;):
                        feat.init_type_converter(self, conv)  # init converter feature

        return conv</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_arithmetic_op"><code class="name flex">
<span>def <span class="ident">bind_arithmetic_op</span></span>(<span>self, conv, op, rval, args, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_arithmetic_op(self, conv, op, rval, args, features=[]):
        self.bind_arithmetic_op_overloads(conv, op, [(rval, args, features)])</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_arithmetic_op_overloads"><code class="name flex">
<span>def <span class="ident">bind_arithmetic_op_overloads</span></span>(<span>self, conv, op, protos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_arithmetic_op_overloads(self, conv, op, protos):
        assert op in [&#39;-&#39;, &#39;+&#39;, &#39;*&#39;, &#39;/&#39;], &#39;Unsupported arithmetic operator &#39; + op

        expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
        proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))

        self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;arithmetic_op&#39;, 1)
        conv.arithmetic_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_arithmetic_ops"><code class="name flex">
<span>def <span class="ident">bind_arithmetic_ops</span></span>(<span>self, conv, ops, rval, args, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_arithmetic_ops(self, conv, ops, rval, args, features=[]):
        for op in ops:
                self.bind_arithmetic_op(conv, op, rval, args, features)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_arithmetic_ops_overloads"><code class="name flex">
<span>def <span class="ident">bind_arithmetic_ops_overloads</span></span>(<span>self, conv, ops, protos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_arithmetic_ops_overloads(self, conv, ops, protos):
        for op in ops:
                self.bind_arithmetic_op_overloads(conv, op, protos)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_cast_functions"><code class="name flex">
<span>def <span class="ident">bind_cast_functions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_cast_functions(self):
        upcasts = {}
        for conv in self._bound_types:
                if not conv.nobind:
                        if conv not in upcasts:
                                upcasts[conv] = []
                        for cast in conv._casts:
                                if not cast[0].nobind and cast[0] not in upcasts[conv]:
                                        upcasts[conv].append(cast[0])

        for conv, casts in upcasts.items():
                for cast in casts:
                        name = &#39;_Cast_%s_To_%s&#39; % (cast.bound_name, conv.bound_name)
                        self.insert_binding_code(&#39;static %s *%s(%s *o) { return (%s *)o; }&#39; % (repr(conv.ctype), name, repr(cast.ctype), repr(conv.ctype)))
                        self.bind_function(name, repr(conv.ctype) + &#39; *&#39;, [repr(cast.ctype) + &#39; *o&#39;], [], name[1:])</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_comparison_op"><code class="name flex">
<span>def <span class="ident">bind_comparison_op</span></span>(<span>self, conv, op, args, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_comparison_op(self, conv, op, args, features=[]):
        self.bind_comparison_op_overloads(conv, op, [(args, features)])</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_comparison_op_overloads"><code class="name flex">
<span>def <span class="ident">bind_comparison_op_overloads</span></span>(<span>self, conv, op, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_comparison_op_overloads(self, conv, op, args):
        assert op in [&#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;==&#39;, &#39;!=&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;], &#39;Unsupported comparison operator &#39; + op

        expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
        proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))
        protos = [(&#39;bool&#39;, arg[0], arg[1]) for arg in args]

        self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;comparison_op&#39;, 1)
        conv.comparison_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_comparison_ops"><code class="name flex">
<span>def <span class="ident">bind_comparison_ops</span></span>(<span>self, conv, ops, args, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_comparison_ops(self, conv, ops, args, features=[]):
        for op in ops:
                self.bind_comparison_op(conv, op, args, features)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_comparison_ops_overloads"><code class="name flex">
<span>def <span class="ident">bind_comparison_ops_overloads</span></span>(<span>self, conv, ops, protos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_comparison_ops_overloads(self, conv, ops, protos):
        for op in ops:
                self.bind_comparison_op_overloads(conv, op, protos)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_constant"><code class="name flex">
<span>def <span class="ident">bind_constant</span></span>(<span>self, type, name, value, group=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_constant(self, type, name, value, group=None):
        self.insert_binding_code(&#39;static const %s %s = %s;\n&#39; % (type, name, value))
        self.bind_variable(&#39;const %s %s&#39; % (type, name), [], None, group)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_constants"><code class="name flex">
<span>def <span class="ident">bind_constants</span></span>(<span>self, type, names_values, group=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_constants(self, type, names_values, group=None):
        for nv in names_values:
                self.bind_constant(type, nv[0], nv[1], group)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_constructor"><code class="name flex">
<span>def <span class="ident">bind_constructor</span></span>(<span>self, conv, args, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_constructor(self, conv, args, features=[]):
        self.bind_constructor_overloads(conv, [(args, features)])</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_constructor_overloads"><code class="name flex">
<span>def <span class="ident">bind_constructor_overloads</span></span>(<span>self, conv, proto_args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_constructor_overloads(self, conv, proto_args):
        type = repr(conv.ctype)
        expr_eval = None  # unused for constructors

        protos = [(type, args[0], args[1]) for args in proto_args]
        proxy_name = apply_api_prefix(&#39;construct_%s&#39; % conv.bound_name)

        self._bind_proxy(proxy_name, conv, protos, &#39;%s constructor&#39; % conv.bound_name, expr_eval, &#39;constructor&#39;)
        conv.constructor = {&#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos}</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_extern_type"><code class="name flex">
<span>def <span class="ident">bind_extern_type</span></span>(<span>self, type, bound_name=None, module=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bind an external type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_extern_type(self, type, bound_name=None, module=None):
        &#34;&#34;&#34;Bind an external type.&#34;&#34;&#34;
        if type in self.__type_convs:
                return self.__type_convs[type]  # type already declared

        default_storage_type = type + &#39;*&#39;

        conv = self.default_extern_converter(type, default_storage_type, bound_name, module)

        if self.verbose:
                print(&#39;Binding extern type %s (%s)&#39; % (conv.bound_name, conv.ctype))

        self._header += conv.get_type_api(self._name)
        self._source += conv.get_type_api(self._name)

        self._extern_types.append(conv)
        self.__type_convs[repr(conv.ctype)] = conv

        self._source += conv.get_type_glue(self, self._name) + &#39;\n&#39;
        return conv</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_function"><code class="name flex">
<span>def <span class="ident">bind_function</span></span>(<span>self, name, rval, args, features=[], bound_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_function(self, name, rval, args, features=[], bound_name=None):
        self.bind_function_overloads(name, [(rval, args, features)], bound_name)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_function_overloads"><code class="name flex">
<span>def <span class="ident">bind_function_overloads</span></span>(<span>self, name, protos, bound_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_function_overloads(self, name, protos, bound_name=None):
        if not name in self.__function_declarations:
                fn = self.__function_declarations[name] = {
                        &#39;protos&#39;: protos,
                        &#39;bound_name&#39;: bound_name
                }
        else:
                fn = self.__function_declarations[name]
                assert(bound_name == fn[&#39;bound_name&#39;])  # ensure bound_name coherency
                fn[&#39;protos&#39;] = fn[&#39;protos&#39;] + protos</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_inplace_arithmetic_op"><code class="name flex">
<span>def <span class="ident">bind_inplace_arithmetic_op</span></span>(<span>self, conv, op, args, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_inplace_arithmetic_op(self, conv, op, args, features=[]):
        self.bind_inplace_arithmetic_op_overloads(conv, op, [(args, features)])</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_inplace_arithmetic_op_overloads"><code class="name flex">
<span>def <span class="ident">bind_inplace_arithmetic_op_overloads</span></span>(<span>self, conv, op, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_inplace_arithmetic_op_overloads(self, conv, op, args):
        assert op in [&#39;-=&#39;, &#39;+=&#39;, &#39;*=&#39;, &#39;/=&#39;], &#39;Unsupported inplace arithmetic operator &#39; + op

        expr_eval = lambda args: &#39;*_self %s %s;&#39; % (op, &#39;, &#39;.join(args))
        proxy_name = apply_api_prefix(&#39;%s_operator_of_%s&#39; % (get_clean_symbol_name(op), conv.bound_name))
        protos = [(&#39;void&#39;, arg[0], arg[1]) for arg in args]

        self._bind_proxy(proxy_name, conv, protos, &#39;%s operator of %s&#39; % (op, conv.bound_name), expr_eval, &#39;inplace_arithmetic_op&#39;, 1)
        conv.arithmetic_ops.append({&#39;op&#39;: op, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_inplace_arithmetic_ops"><code class="name flex">
<span>def <span class="ident">bind_inplace_arithmetic_ops</span></span>(<span>self, conv, ops, args, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_inplace_arithmetic_ops(self, conv, ops, args, features=[]):
        for op in ops:
                self.bind_inplace_arithmetic_op(conv, op, args, features)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_inplace_arithmetic_ops_overloads"><code class="name flex">
<span>def <span class="ident">bind_inplace_arithmetic_ops_overloads</span></span>(<span>self, conv, ops, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_inplace_arithmetic_ops_overloads(self, conv, ops, args):
        for op in ops:
                self.bind_inplace_arithmetic_op_overloads(conv, op, args)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_member"><code class="name flex">
<span>def <span class="ident">bind_member</span></span>(<span>self, conv, member, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_member(self, conv, member, features=[]):
        is_bitfield = member.endswith(&#39;:&#39;)
        if is_bitfield:
                member = member[:-1]

        arg = parse(member, _NamedCType)

        # getter
        expr_eval = lambda args: &#39;_self-&gt;%s;&#39; % arg.name
        arg_ctype = arg.ctype if is_bitfield else arg.ctype.add_ref(&#39;&amp;&#39;)
        getter_protos = [(repr(arg_ctype), [], features)]
        getter_proxy_name = apply_api_prefix(&#39;get_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

        self._bind_proxy(getter_proxy_name, conv, getter_protos, &#39;get member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;getter&#39;, 0)

        # setter
        if not arg.ctype.is_const():
                expr_eval = lambda args: &#39;_self-&gt;%s = %s;&#39; % (arg.name, args[0])

                setter_protos = [(&#39;void&#39;, [member], features)]
                setter_proxy_name = apply_api_prefix(&#39;set_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                self._bind_proxy(setter_proxy_name, conv, setter_protos, &#39;set member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;setter&#39;, 1)
        else:
                setter_proxy_name = None

        conv.members.append({&#39;name&#39;: arg.name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name, &#39;is_bitfield&#39;: is_bitfield})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_members"><code class="name flex">
<span>def <span class="ident">bind_members</span></span>(<span>self, conv, members, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_members(self, conv, members, features=[]):
        for member in members:
                self.bind_member(conv, member, features)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_method"><code class="name flex">
<span>def <span class="ident">bind_method</span></span>(<span>self, conv, name, rval, args, features=[], bound_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_method(self, conv, name, rval, args, features=[], bound_name=None):
        self.bind_method_overloads(conv, name, [(rval, args, features)], bound_name)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_method_overloads"><code class="name flex">
<span>def <span class="ident">bind_method_overloads</span></span>(<span>self, conv, name, protos, bound_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_method_overloads(self, conv, name, protos, bound_name=None):
        expr_eval = lambda args: &#39;_self-&gt;%s(%s);&#39; % (name, &#39;, &#39;.join(args))

        if bound_name is None:
                bound_name = get_symbol_default_bound_name(name)
        proxy_name = apply_api_prefix(&#39;method_%s_of_%s&#39; % (bound_name, conv.bound_name))

        self._bind_proxy(proxy_name, conv, protos, &#39;method %s of %s&#39; % (bound_name, conv.bound_name), expr_eval, &#39;method&#39;)
        conv.methods.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_named_enum"><code class="name flex">
<span>def <span class="ident">bind_named_enum</span></span>(<span>self, name, symbols, storage_type='int', bound_name=None, prefix='', namespace=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_named_enum(self, name, symbols, storage_type=&#39;int&#39;, bound_name=None, prefix=&#39;&#39;, namespace=None):
        if bound_name is None:
                bound_name = get_symbol_default_bound_name(name)

        self.typedef(name, storage_type, bound_name=bound_name)

        if namespace is None:
                namespace = name

        enum = {}
        for symbol in symbols:
                enum[prefix + symbol] = &#39;%s::%s&#39; % (namespace, symbol)

        self._enums[bound_name] = enum</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_ptr"><code class="name flex">
<span>def <span class="ident">bind_ptr</span></span>(<span>self, type, converter_class=None, bound_name=None, features={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_ptr(self, type, converter_class=None, bound_name=None, features={}):
        if type in self.__type_convs:
                return self.__type_convs[type]  # type already declared

        conv = self.default_ptr_converter(type, None, bound_name) if converter_class is None else converter_class(type, None, bound_name)
        self.bind_type(conv, features)

        return conv</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_static_member"><code class="name flex">
<span>def <span class="ident">bind_static_member</span></span>(<span>self, conv, member, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_static_member(self, conv, member, features=[]):
        arg = parse(member, _NamedCType)

        # getter
        if &#39;proxy&#39; in features:
                self.__assert_conv_feature(conv, &#39;proxy&#39;)
                expr_eval = lambda args: &#39;&amp;%s::%s;&#39; % (conv._features[&#39;proxy&#39;].wrapped_conv.ctype, arg.name)
        else:
                expr_eval = lambda args: &#39;&amp;%s::%s;&#39; % (conv.ctype, arg.name)

        getter_protos = [(repr(arg.ctype.add_ref(&#39;*&#39;)), [], features)]
        getter_proxy_name = apply_api_prefix(&#39;get_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))
        
        self._bind_proxy(getter_proxy_name, None, getter_protos, &#39;get static member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;getter&#39;, 0)

        # setter
        if not arg.ctype.is_const():
                expr_eval = lambda args: &#39;%s::%s = %s;&#39; % (conv.ctype, arg.name, args[0])

                setter_protos = [(&#39;void&#39;, [member], features)]
                setter_proxy_name = apply_api_prefix(&#39;set_%s_of_%s&#39; % (get_symbol_default_bound_name(arg.name), conv.bound_name))

                self._bind_proxy(setter_proxy_name, None, setter_protos, &#39;set static member %s of %s&#39; % (arg.name, conv.bound_name), expr_eval, &#39;setter&#39;, 1)
        else:
                setter_proxy_name = None

        conv.static_members.append({&#39;name&#39;: arg.name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_static_members"><code class="name flex">
<span>def <span class="ident">bind_static_members</span></span>(<span>self, conv, members, features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_static_members(self, conv, members, features=[]):
        for member in members:
                self.bind_static_member(conv, member, features)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_static_method"><code class="name flex">
<span>def <span class="ident">bind_static_method</span></span>(<span>self, conv, name, rval, args, features=[], bound_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_static_method(self, conv, name, rval, args, features=[], bound_name=None):
        self.bind_static_method_overloads(conv, name, [(rval, args, features)], bound_name)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_static_method_overloads"><code class="name flex">
<span>def <span class="ident">bind_static_method_overloads</span></span>(<span>self, conv, name, protos, bound_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_static_method_overloads(self, conv, name, protos, bound_name=None):
        expr_eval = lambda args: &#39;%s::%s(%s);&#39; % (conv.ctype, name, &#39;, &#39;.join(args))

        if bound_name is None:
                bound_name = get_symbol_default_bound_name(name)
        proxy_name = apply_api_prefix(&#39;static_method_%s_of_%s&#39; % (bound_name, conv.bound_name))

        self._bind_proxy(proxy_name, conv, protos, &#39;static method %s of %s&#39; % (bound_name, conv.bound_name), expr_eval, &#39;static_method&#39;)
        conv.static_methods.append({&#39;name&#39;: name, &#39;bound_name&#39;: bound_name, &#39;proxy_name&#39;: proxy_name, &#39;protos&#39;: protos})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_type"><code class="name flex">
<span>def <span class="ident">bind_type</span></span>(<span>self, conv, features={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_type(self, conv, features={}):
        self.begin_type(conv, features)
        self.end_type(conv)
        return conv</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_variable"><code class="name flex">
<span>def <span class="ident">bind_variable</span></span>(<span>self, var, features=[], bound_name=None, group=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_variable(self, var, features=[], bound_name=None, group=None):
        arg = self.parse_named_ctype(var)
        conv = self.select_ctype_conv(arg.ctype)

        if bound_name == None:
                bound_name = get_symbol_default_bound_name(arg.name)

        # getter
        expr_eval = lambda args: &#39;&amp;%s;&#39; % arg.name

        getter_protos = [(repr(arg.ctype.add_ref(&#39;*&#39;)), [], features)]
        getter_proxy_name = apply_api_prefix(&#39;get_%s_variable&#39; % bound_name)

        self._bind_proxy(getter_proxy_name, None, getter_protos, &#39;get variable %s&#39; % arg.name, expr_eval, &#39;getter&#39;, 0)

        # setter
        if not(arg.ctype.is_const() or conv._non_copyable):
                expr_eval = lambda args: &#39;%s = %s;&#39; % (arg.name, args[0])

                setter_protos = [(&#39;void&#39;, [&#34;%s %s&#34; % (str(arg.ctype), bound_name)], features)]
                setter_proxy_name = apply_api_prefix(&#39;set_%s_variable&#39; % bound_name)

                self._bind_proxy(setter_proxy_name, None, setter_protos, &#39;set variable %s&#39; % arg.name, expr_eval, &#39;setter&#39;, 1)
        else:
                setter_proxy_name = None

        self._bound_variables.append({&#39;name&#39;: arg.name, &#39;bound_name&#39;: bound_name, &#39;ctype&#39;: arg.ctype, &#39;getter&#39;: getter_proxy_name, &#39;setter&#39;: setter_proxy_name, &#39;group&#39;: group})</code></pre>
</details>
</dd>
<dt id="gen.FABGen.bind_variables"><code class="name flex">
<span>def <span class="ident">bind_variables</span></span>(<span>self, vars, features=[], group=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_variables(self, vars, features=[], group=None):
        for var in vars:
                self.bind_variable(var, features, None, group)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.commit_from_c_vars"><code class="name flex">
<span>def <span class="ident">commit_from_c_vars</span></span>(<span>self, rval, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit_from_c_vars(self, rval, ctx):
        assert &#39;not implemented in this generator&#39;  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="gen.FABGen.ctype_to_plain_string"><code class="name flex">
<span>def <span class="ident">ctype_to_plain_string</span></span>(<span>self, ctype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctype_to_plain_string(self, ctype):
        return ctype_to_plain_string(ctype)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.decl_var"><code class="name flex">
<span>def <span class="ident">decl_var</span></span>(<span>self, ctype, name, eol=';\n')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decl_var(self, ctype, name, eol=&#39;;\n&#39;):
        return &#39;%s %s%s&#39; % (get_fully_qualified_ctype_name(ctype), name, eol)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.declare_from_c_var"><code class="name flex">
<span>def <span class="ident">declare_from_c_var</span></span>(<span>self, out_var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_from_c_var(self, out_var):
        return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="gen.FABGen.defined"><code class="name flex">
<span>def <span class="ident">defined</span></span>(<span>self, symbol)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defined(self, symbol):
        return symbol in self.defines</code></pre>
</details>
</dd>
<dt id="gen.FABGen.end_class"><code class="name flex">
<span>def <span class="ident">end_class</span></span>(<span>self, conv)</span>
</code></dt>
<dd>
<div class="desc"><p>End a class declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_class(self, conv):
        &#34;&#34;&#34;End a class declaration.&#34;&#34;&#34;
        self.end_type(conv)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.end_type"><code class="name flex">
<span>def <span class="ident">end_type</span></span>(<span>self, conv)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_type(self, conv):
        type_glue = conv.get_type_glue(self, self._name)
        self._source += type_glue + &#39;\n&#39;</code></pre>
</details>
</dd>
<dt id="gen.FABGen.finalize"><code class="name flex">
<span>def <span class="ident">finalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize(self):
        # insert includes
        system_includes = &#39;&#39;
        if len(self.__system_includes) &gt; 0:
                system_includes = &#39;&#39;.join([&#39;#include &lt;%s&gt;\n&#39; % path for path in self.__system_includes])

        user_includes = &#39;&#39;
        if len(self.__user_includes) &gt; 0:
                user_includes = &#39;&#39;.join([&#39;#include &#34;%s&#34;\n&#39; % path for path in self.__user_includes])

        self._source = self._source.replace(&#39;{{{__WRAPPER_INCLUDES__}}}&#39;, system_includes + user_includes)

        # cast to
        self._source += self.get_type_tag_cast_function()
        self.bind_cast_functions()

        # commit all function declarations
        self.__commit_function_declarations()

        # statistics
        if self.verbose:  # pragma: no cover
                self.__print_stats()

        # extern types linker API
        self.output_linker_api()</code></pre>
</details>
</dd>
<dt id="gen.FABGen.get_conv"><code class="name flex">
<span>def <span class="ident">get_conv</span></span>(<span>self, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_conv(self, type):
        return self.__type_convs[type]</code></pre>
</details>
</dd>
<dt id="gen.FABGen.get_language"><code class="name flex">
<span>def <span class="ident">get_language</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_language(self):
        assert &#39;not implemented in this generator&#39;  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="gen.FABGen.get_output"><code class="name flex">
<span>def <span class="ident">get_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output(self):
        return {
                &#39;bind_%s.h&#39; % self.get_language(): self._header,
                &#39;bind_%s.cpp&#39; % self.get_language(): self._source
        }</code></pre>
</details>
</dd>
<dt id="gen.FABGen.get_symbol_doc"><code class="name flex">
<span>def <span class="ident">get_symbol_doc</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_symbol_doc(self, name):
        return self.get_symbol_doc_hook(name)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.get_symbol_doc_hook"><code class="name flex">
<span>def <span class="ident">get_symbol_doc_hook</span></span>(<span>gen, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">get_symbol_doc_hook = lambda gen, name: &#34;&#34;</code></pre>
</details>
</dd>
<dt id="gen.FABGen.get_type_tag_cast_function"><code class="name flex">
<span>def <span class="ident">get_type_tag_cast_function</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def get_type_tag_cast_function(self):
                out = &#39;// type_tag based cast system\n&#39;

                def output_type_tag_cast_tree(expr):
                        out = []

                        i = 0
                        for conv in self._bound_types:
                                if len(conv._casts) == 0:
                                        continue

                                out.append(&#39;    &#39; if i == 0 else &#39; else &#39;)
                                out.append(&#39;if (in_type_tag == %s) {\n&#39; % conv.type_tag)

                                for j, cast in enumerate(conv._casts):
                                        out.append(&#39;    &#39; if j == 0 else &#39; else &#39;)
                                        out.append(&#39;if (out_type_tag == %s) {\n&#39; % cast[0].type_tag)
                                        out.append(expr(cast))
                                        out.append(&#39;}\n&#39;)

                                out.append(&#39;}\n&#39;)
                                i += 1

                        return &#39;&#39;.join(out)

                # can cast
                out += &#39;&#39;&#39;\
static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag) {
        if (out_type_tag == in_type_tag)
                return true;

        %s
        return false;
}\n\n&#39;&#39;&#39; % output_type_tag_cast_tree(lambda cast: &#39;     return true;\n&#39;)

                # cast
                out += &#39;&#39;&#39;\
static void *_type_tag_cast(void *in_ptr, uint32_t in_type_tag, uint32_t out_type_tag) {
        if (out_type_tag == in_type_tag)
                return in_ptr;

        void *out_ptr = NULL;
        %s

        return out_ptr;
}\n\n&#39;&#39;&#39; % output_type_tag_cast_tree(lambda cast: cast[1](&#39;in_ptr&#39;, &#39;out_ptr&#39;))

                return out</code></pre>
</details>
</dd>
<dt id="gen.FABGen.insert_binding_code"><code class="name flex">
<span>def <span class="ident">insert_binding_code</span></span>(<span>self, code, comment=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_binding_code(self, code, comment=None):
        parts = []
        if comment is not None:
                parts.append(&#39;// %s\n&#39; % comment)
        parts.append(code)
        parts.append(&#39;\n&#39;)
        self._source += &#39;&#39;.join(parts)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.insert_code"><code class="name flex">
<span>def <span class="ident">insert_code</span></span>(<span>self, code, in_source=True, in_header=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_code(self, code, in_source=True, in_header=True):
        if in_header:
                self._header += code
        if in_source:
                self._source += code</code></pre>
</details>
</dd>
<dt id="gen.FABGen.output_header"><code class="name flex">
<span>def <span class="ident">output_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_header(self):
        common = &#34;// This file is automatically generated, do not modify manually!\n\n&#34;

        self._source += &#34;// FABgen output .cpp\n&#34;
        self._source += common
        self._source += &#39;#include &#34;fabgen.h&#34;\n\n&#39;

        self._header += &#39;// FABgen output .h\n&#39;
        self._header += common
        self._header += &#39;#pragma once\n\n&#39;
        self._header += &#39;#include &lt;cstdint&gt;\n\n&#39;
        self._header += &#39;#include &lt;cstddef&gt;\n\n&#39;</code></pre>
</details>
</dd>
<dt id="gen.FABGen.output_includes"><code class="name flex">
<span>def <span class="ident">output_includes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_includes(self):
        self.add_include(&#39;cstdint&#39;, True)
        self.add_include(&#39;cassert&#39;, True)
        self.add_include(&#39;map&#39;, True)

        self._source += &#39;{{{__WRAPPER_INCLUDES__}}}\n&#39;</code></pre>
</details>
</dd>
<dt id="gen.FABGen.output_linker_api"><code class="name flex">
<span>def <span class="ident">output_linker_api</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def output_linker_api(self):
                link_func = self.apply_api_prefix(&#39;link_binding&#39;)

                self._header += &#39;&#39;&#39;\
/*
        pass the get_c_type_info function from another binding to this function to resolve external types declared in this binding.
        you will need to write a wrapper to cast the type_info * pointer to the correct type if you are using a binding prefix.
        this function returns the number of unresolved external symbols.
*/
size_t %s(%s *(*get_c_type_info)(const char *));\n
&#39;&#39;&#39; % (link_func, self.apply_api_prefix(&#39;type_info&#39;))

                self._source += &#39;&#39;&#39;\
size_t %s(%s *(*get_c_type_info)(const char *type)) {
        size_t unresolved = 0;\n
&#39;&#39;&#39; % (link_func, self.apply_api_prefix(&#39;type_info&#39;))

                for extern_type in self._extern_types:
                        self._source += &#39;&#39;&#39;\
        if (%s == nullptr) {
                if (%s *info = (*get_c_type_info)(&#34;%s&#34;)) {
                        %s = info-&gt;check;
                        %s = info-&gt;to_c;
                        %s = info-&gt;from_c;
                } else {
                        ++unresolved;
                }
        }

&#39;&#39;&#39; % (
                extern_type.check_func,
                self.apply_api_prefix(&#39;type_info&#39;),
                extern_type.ctype,
                extern_type.check_func,
                extern_type.to_c_func,
                extern_type.from_c_func
        )

                self._source += &#39;&#39;&#39;\
        return unresolved;
}

&#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="gen.FABGen.parse_ctype"><code class="name flex">
<span>def <span class="ident">parse_ctype</span></span>(<span>self, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_ctype(self, type):
        return parse(type, _CType)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.parse_named_ctype"><code class="name flex">
<span>def <span class="ident">parse_named_ctype</span></span>(<span>self, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_named_ctype(self, type):
        type = type.replace(&#39;* *&#39;, &#39;**&#39;)
        return parse(type, _NamedCType)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.prepare_from_c_var"><code class="name flex">
<span>def <span class="ident">prepare_from_c_var</span></span>(<span>self, rval)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_from_c_var(self, rval):
        if rval[&#39;ownership&#39;] is None:
                rval[&#39;ownership&#39;] = self.__ctype_to_ownership_policy(rval[&#39;ctype&#39;])

        # transform from {T&amp;, T*, T**, ...} to T* where T is conv.ctype
        expr = transform_var_ref_to(rval[&#39;var&#39;], rval[&#39;ctype&#39;].get_ref(), rval[&#39;conv&#39;].ctype.add_ref(&#39;*&#39;).get_ref())

        out_var = (rval[&#39;var&#39;] if isinstance(rval[&#39;var&#39;], str) else rval[&#39;var&#39;].naked_name()) + &#39;_out&#39;
        src = self.declare_from_c_var(out_var)
        if &#39;rval_transform&#39; in rval[&#39;conv&#39;]._features:
                src += rval[&#39;conv&#39;]._features[&#39;rval_transform&#39;](self, rval[&#39;conv&#39;], expr, out_var, rval[&#39;ownership&#39;])
        else:
                check_is_valid_pointer = rval[&#39;ctype&#39;].is_pointer() or rval[&#39;conv&#39;]._is_pointer

                if check_is_valid_pointer:
                        src += &#39;if (!%s) {\n&#39; % rval[&#39;var&#39;]
                        src += self.rval_from_nullptr(out_var)
                        src += &#39;} else {\n&#39;

                if rval[&#39;conv&#39;].is_type_class() and rval[&#39;is_arg_in_out&#39;]:  # if an object is used as arg_out then reuse the input argument directly 
                        src += self.rval_assign_arg_in_out(out_var, self.get_var(rval[&#39;arg_idx&#39;], rval[&#39;ctx&#39;]))
                else:
                        src += self.rval_from_c_ptr(rval[&#39;conv&#39;], out_var, expr, rval[&#39;ownership&#39;])

                if check_is_valid_pointer:
                        src += &#39;}\n&#39;

        return src</code></pre>
</details>
</dd>
<dt id="gen.FABGen.prepare_to_c_var"><code class="name flex">
<span>def <span class="ident">prepare_to_c_var</span></span>(<span>self, idx, conv, var, ctx='default', features=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_to_c_var(self, idx, conv, var, ctx=&#39;default&#39;, features=[]):
        return self._declare_to_c_var(conv.to_c_storage_ctype, var) + self._convert_to_c_var(idx, conv, var, ctx, features)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.proxy_call_error"><code class="name flex">
<span>def <span class="ident">proxy_call_error</span></span>(<span>self, msg, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proxy_call_error(self, msg, ctx):
        assert &#39;not implemented in this generator&#39;  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="gen.FABGen.rbind_function"><code class="name flex">
<span>def <span class="ident">rbind_function</span></span>(<span>self, name, rval, args, internal=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def rbind_function(self, name, rval, args, internal=False):
                parts = []
                args = [self.parse_named_ctype(arg) for arg in args]

                if internal:
                        parts.append(&#39;static inline %s {\n&#39; % self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, True))
                else:
                        self._header += &#39;// C to Lua reverse binding call &#39; + name + &#39;\n&#39;
                        self._header += self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, True) + &#39;;\n\n&#39;
                        parts.append(&#39;%s {\n&#39; % self.__get_rbind_call_signature(apply_api_prefix(name), rval, args, False))

                parts.append(self._prepare_rbind_call(rval, args))

                # prepare args
                for arg in args:
                        arg_conv = self.select_ctype_conv(arg.ctype)
                        parts.append(self.prepare_from_c_var({&#39;conv&#39;: arg_conv, &#39;ctype&#39;: arg.ctype, &#39;var&#39;: arg.name, &#39;is_arg_in_out&#39;: False, &#39;ownership&#39;: None}))

                parts.append(self.commit_from_c_vars([arg.name for arg in args], &#39;rbind_args&#39;))

                # call
                parts.append(&#39;bool _call_success_var;&#39;)
                parts.append(&#39;\n&#39; + self._rbind_call(rval, args, &#39;_call_success_var&#39;) + &#39;\n&#39;)
                parts.append(&#39;&#39;&#39;\
if (success)
        *success = _call_success_var;
&#39;&#39;&#39;)

                # rval
                if rval != &#39;void&#39;:
                        rval_conv = self.select_ctype_conv(self.parse_ctype(rval))

                        parts.append(self._declare_to_c_var(rval_conv.to_c_storage_ctype, &#39;_rbind_rval&#39;))
                        parts.append(&#39;&#39;&#39;\
if (%s) {
        %s
} else if (success != NULL) {
        *success = false;
}
&#39;&#39;&#39; % (rval_conv.check_call(self.get_var(0, &#39;rbind_rval&#39;)), self._convert_to_c_var(0, rval_conv, &#39;_rbind_rval&#39;, &#39;rbind_rval&#39;)))

                parts.append(self._clean_rbind_call(rval, args))

                if rval != &#39;void&#39;:
                        parts.append(&#39;return _rbind_rval;\n&#39;)

                parts.append(&#39;}\n&#39;)
                self._source += &#39;&#39;.join(parts)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.rval_assign_arg_in_out"><code class="name flex">
<span>def <span class="ident">rval_assign_arg_in_out</span></span>(<span>self, out_var, arg_in_out)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rval_assign_arg_in_out(self, out_var, arg_in_out):
        assert &#39;not implemented in this generator&#39;  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="gen.FABGen.select_args_convs"><code class="name flex">
<span>def <span class="ident">select_args_convs</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_args_convs(self, args):
        return [{&#39;conv&#39;: self.select_ctype_conv(arg.ctype), &#39;ctype&#39;: arg.ctype} for i, arg in enumerate(args)]</code></pre>
</details>
</dd>
<dt id="gen.FABGen.select_ctype_conv"><code class="name flex">
<span>def <span class="ident">select_ctype_conv</span></span>(<span>self, ctype)</span>
</code></dt>
<dd>
<div class="desc"><p>Select a type converter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_ctype_conv(self, ctype):
        &#34;&#34;&#34;Select a type converter.&#34;&#34;&#34;
        if repr(ctype) == &#39;void&#39;:
                return None

        while True:
                type = repr(ctype)
                if type in self.__type_convs:
                        return self.__type_convs[type]

                type = repr(ctype.non_const())
                if type in self.__type_convs:
                        return self.__type_convs[type]

                if ctype.get_ref() == &#39;&#39;:
                        break
                #alt 
                ctype = ctype.dereference_once()

        raise Exception(&#34;Unknown type %s (no converter available)&#34; % ctype)</code></pre>
</details>
</dd>
<dt id="gen.FABGen.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, name):
        self._name = name
        self._header, self._source = &#34;&#34;, &#34;&#34;

        self.__system_includes, self.__user_includes = [], []

        self.__type_convs = {}
        self.__function_declarations = {}

        self._bound_types = []  # list of bound types
        self._bound_functions = []  # list of bound functions
        self._bound_variables = []  # list of bound variables
        self._enums = {}  # list of bound enumerations

        self._extern_types = []  # list of extern types

        self._custom_init_code = &#34;&#34;
        self._custom_free_code = &#34;&#34;

        self.output_header()
        self.output_includes()

        self._source += &#39;static bool _type_tag_can_cast(uint32_t in_type_tag, uint32_t out_type_tag);\n&#39;
        self._source += &#39;static void *_type_tag_cast(void *in_T0, uint32_t in_type_tag, uint32_t out_type_tag);\n\n&#39;</code></pre>
</details>
</dd>
<dt id="gen.FABGen.typedef"><code class="name flex">
<span>def <span class="ident">typedef</span></span>(<span>self, type, alias_of, to_c_storage_type=None, bound_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def typedef(self, type, alias_of, to_c_storage_type=None, bound_name=None):
        conv = copy.deepcopy(self.__type_convs[alias_of])

        default_arg_storage_type = type if to_c_storage_type is None else to_c_storage_type

        if bound_name is not None:
                conv.bound_name=bound_name
        conv.ctype = parse(type, _CType)
        conv.to_c_storage_ctype = parse(default_arg_storage_type, _CType)

        self.__type_convs[type] = conv</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gen.TypeConverter"><code class="flex name class">
<span>class <span class="ident">TypeConverter</span></span>
<span>(</span><span>type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeConverter:
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                self.ctype = parse(type, _CType)
                self.to_c_storage_ctype = parse(to_c_storage_type, _CType) if to_c_storage_type is not None else self.ctype.non_const()
                self.bound_name = get_ctype_default_bound_name(self.ctype) if bound_name is None else bound_name
                self.from_c_storage_ctype = parse(from_c_storage_type, _CType) if from_c_storage_type is not None else None  # if None the prototype return value type will be used to determine adequate storage at binding time

                if needs_c_storage_class:
                        self.c_storage_class = &#39;storage_%s&#39; % self.bound_name
                else:
                        self.c_storage_class = None

                self.type_tag = &#39;type_tag_&#39; + self.bound_name

                self.constructor = None
                self.members = []
                self.static_members = []
                self.methods = []
                self.static_methods = []
                self.arithmetic_ops = []
                self.comparison_ops = []

                self._non_copyable = False
                self._moveable = False
                self._inline = False
                self._supports_deep_compare = False
                self._is_pointer = False

                self._features = {}
                self._casts = []  # valid casts
                self._bases = []  # bases

                self.nobind = False

                self.check_func = apply_api_prefix(&#39;check_%s&#39; % self.bound_name)
                self.to_c_func = apply_api_prefix(&#39;to_c_%s&#39; % self.bound_name)
                self.from_c_func = apply_api_prefix(&#39;from_c_%s&#39; % self.bound_name)

        def is_type_class(self):
                return False

        def get_operator(self, op):
                for arithmetic_op in self.arithmetic_ops:
                        if arithmetic_op[&#39;op&#39;] == op:
                                return arithmetic_op

        def get_type_api(self, module_name):
                return &#39;&#39;

        def finalize_type(self):
                return &#39;&#39;

        def to_c_call(self, out_var, expr):
                assert &#39;not implemented in this converter&#39;  # pragma: no cover
        def from_c_call(self, out_var, expr, ownership):
                assert &#39;not implemented in this converter&#39;  # pragma: no cover

        def prepare_var_for_conv(self, var, input_ref):
                &#34;&#34;&#34;Transform a variable for use with the converter from_c/to_c methods.&#34;&#34;&#34;
                return transform_var_ref_to(var, input_ref, self.to_c_storage_ctype.get_ref())
        def prepare_var_from_conv(self, var, target_ref):
                &#34;&#34;&#34;Transform a converted variable back to its ctype reference.&#34;&#34;&#34;
                return transform_var_ref_to(var, self.to_c_storage_ctype.get_ref(), target_ref)

        def get_all_members(self):
                return collect_attr_from_conv_recursive([], self, &#39;members&#39;, lambda a,b: a[&#39;name&#39;] == b[&#39;name&#39;])
        def get_all_static_members(self):
                return collect_attr_from_conv_recursive([], self, &#39;static_members&#39;, lambda a,b: a[&#39;name&#39;] == b[&#39;name&#39;])
        def get_all_methods(self):
                return collect_attr_from_conv_recursive([], self, &#39;methods&#39;, lambda a,b: a[&#39;bound_name&#39;] == b[&#39;bound_name&#39;])
        def get_all_static_methods(self):
                return collect_attr_from_conv_recursive([], self, &#39;static_methods&#39;, lambda a,b: a[&#39;bound_name&#39;] == b[&#39;bound_name&#39;])

        def add_feature(self, key, val):
                self._features[key] = val</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gen.TypeConverter.add_feature"><code class="name flex">
<span>def <span class="ident">add_feature</span></span>(<span>self, key, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_feature(self, key, val):
        self._features[key] = val</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.finalize_type"><code class="name flex">
<span>def <span class="ident">finalize_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize_type(self):
        return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.from_c_call"><code class="name flex">
<span>def <span class="ident">from_c_call</span></span>(<span>self, out_var, expr, ownership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_c_call(self, out_var, expr, ownership):
        assert &#39;not implemented in this converter&#39;  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.get_all_members"><code class="name flex">
<span>def <span class="ident">get_all_members</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_members(self):
        return collect_attr_from_conv_recursive([], self, &#39;members&#39;, lambda a,b: a[&#39;name&#39;] == b[&#39;name&#39;])</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.get_all_methods"><code class="name flex">
<span>def <span class="ident">get_all_methods</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_methods(self):
        return collect_attr_from_conv_recursive([], self, &#39;methods&#39;, lambda a,b: a[&#39;bound_name&#39;] == b[&#39;bound_name&#39;])</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.get_all_static_members"><code class="name flex">
<span>def <span class="ident">get_all_static_members</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_static_members(self):
        return collect_attr_from_conv_recursive([], self, &#39;static_members&#39;, lambda a,b: a[&#39;name&#39;] == b[&#39;name&#39;])</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.get_all_static_methods"><code class="name flex">
<span>def <span class="ident">get_all_static_methods</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_static_methods(self):
        return collect_attr_from_conv_recursive([], self, &#39;static_methods&#39;, lambda a,b: a[&#39;bound_name&#39;] == b[&#39;bound_name&#39;])</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.get_operator"><code class="name flex">
<span>def <span class="ident">get_operator</span></span>(<span>self, op)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_operator(self, op):
        for arithmetic_op in self.arithmetic_ops:
                if arithmetic_op[&#39;op&#39;] == op:
                        return arithmetic_op</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.get_type_api"><code class="name flex">
<span>def <span class="ident">get_type_api</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_api(self, module_name):
        return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.is_type_class"><code class="name flex">
<span>def <span class="ident">is_type_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_type_class(self):
        return False</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.prepare_var_for_conv"><code class="name flex">
<span>def <span class="ident">prepare_var_for_conv</span></span>(<span>self, var, input_ref)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a variable for use with the converter from_c/to_c methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_var_for_conv(self, var, input_ref):
        &#34;&#34;&#34;Transform a variable for use with the converter from_c/to_c methods.&#34;&#34;&#34;
        return transform_var_ref_to(var, input_ref, self.to_c_storage_ctype.get_ref())</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.prepare_var_from_conv"><code class="name flex">
<span>def <span class="ident">prepare_var_from_conv</span></span>(<span>self, var, target_ref)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a converted variable back to its ctype reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_var_from_conv(self, var, target_ref):
        &#34;&#34;&#34;Transform a converted variable back to its ctype reference.&#34;&#34;&#34;
        return transform_var_ref_to(var, self.to_c_storage_ctype.get_ref(), target_ref)</code></pre>
</details>
</dd>
<dt id="gen.TypeConverter.to_c_call"><code class="name flex">
<span>def <span class="ident">to_c_call</span></span>(<span>self, out_var, expr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_c_call(self, out_var, expr):
        assert &#39;not implemented in this converter&#39;  # pragma: no cover</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gen.add_list_unique" href="#gen.add_list_unique">add_list_unique</a></code></li>
<li><code><a title="gen.apply_api_prefix" href="#gen.apply_api_prefix">apply_api_prefix</a></code></li>
<li><code><a title="gen.clean_name_with_title" href="#gen.clean_name_with_title">clean_name_with_title</a></code></li>
<li><code><a title="gen.collect_attr_from_conv_recursive" href="#gen.collect_attr_from_conv_recursive">collect_attr_from_conv_recursive</a></code></li>
<li><code><a title="gen.ctype_ref_to" href="#gen.ctype_ref_to">ctype_ref_to</a></code></li>
<li><code><a title="gen.ctype_to_plain_string" href="#gen.ctype_to_plain_string">ctype_to_plain_string</a></code></li>
<li><code><a title="gen.format_list_for_comment" href="#gen.format_list_for_comment">format_list_for_comment</a></code></li>
<li><code><a title="gen.get_clean_symbol_name" href="#gen.get_clean_symbol_name">get_clean_symbol_name</a></code></li>
<li><code><a title="gen.get_ctype_default_bound_name" href="#gen.get_ctype_default_bound_name">get_ctype_default_bound_name</a></code></li>
<li><code><a title="gen.get_fabgen_api" href="#gen.get_fabgen_api">get_fabgen_api</a></code></li>
<li><code><a title="gen.get_fully_qualified_ctype_name" href="#gen.get_fully_qualified_ctype_name">get_fully_qualified_ctype_name</a></code></li>
<li><code><a title="gen.get_fully_qualified_function_signature" href="#gen.get_fully_qualified_function_signature">get_fully_qualified_function_signature</a></code></li>
<li><code><a title="gen.get_symbol_default_bound_name" href="#gen.get_symbol_default_bound_name">get_symbol_default_bound_name</a></code></li>
<li><code><a title="gen.ref_to_string" href="#gen.ref_to_string">ref_to_string</a></code></li>
<li><code><a title="gen.strip_namespace" href="#gen.strip_namespace">strip_namespace</a></code></li>
<li><code><a title="gen.transform_var_ref_to" href="#gen.transform_var_ref_to">transform_var_ref_to</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gen.FABGen" href="#gen.FABGen">FABGen</a></code></h4>
<ul class="">
<li><code><a title="gen.FABGen.add_base" href="#gen.FABGen.add_base">add_base</a></code></li>
<li><code><a title="gen.FABGen.add_bases" href="#gen.FABGen.add_bases">add_bases</a></code></li>
<li><code><a title="gen.FABGen.add_cast" href="#gen.FABGen.add_cast">add_cast</a></code></li>
<li><code><a title="gen.FABGen.add_custom_free_code" href="#gen.FABGen.add_custom_free_code">add_custom_free_code</a></code></li>
<li><code><a title="gen.FABGen.add_custom_init_code" href="#gen.FABGen.add_custom_init_code">add_custom_init_code</a></code></li>
<li><code><a title="gen.FABGen.add_include" href="#gen.FABGen.add_include">add_include</a></code></li>
<li><code><a title="gen.FABGen.apply_api_prefix" href="#gen.FABGen.apply_api_prefix">apply_api_prefix</a></code></li>
<li><code><a title="gen.FABGen.begin_class" href="#gen.FABGen.begin_class">begin_class</a></code></li>
<li><code><a title="gen.FABGen.begin_type" href="#gen.FABGen.begin_type">begin_type</a></code></li>
<li><code><a title="gen.FABGen.bind_arithmetic_op" href="#gen.FABGen.bind_arithmetic_op">bind_arithmetic_op</a></code></li>
<li><code><a title="gen.FABGen.bind_arithmetic_op_overloads" href="#gen.FABGen.bind_arithmetic_op_overloads">bind_arithmetic_op_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_arithmetic_ops" href="#gen.FABGen.bind_arithmetic_ops">bind_arithmetic_ops</a></code></li>
<li><code><a title="gen.FABGen.bind_arithmetic_ops_overloads" href="#gen.FABGen.bind_arithmetic_ops_overloads">bind_arithmetic_ops_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_cast_functions" href="#gen.FABGen.bind_cast_functions">bind_cast_functions</a></code></li>
<li><code><a title="gen.FABGen.bind_comparison_op" href="#gen.FABGen.bind_comparison_op">bind_comparison_op</a></code></li>
<li><code><a title="gen.FABGen.bind_comparison_op_overloads" href="#gen.FABGen.bind_comparison_op_overloads">bind_comparison_op_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_comparison_ops" href="#gen.FABGen.bind_comparison_ops">bind_comparison_ops</a></code></li>
<li><code><a title="gen.FABGen.bind_comparison_ops_overloads" href="#gen.FABGen.bind_comparison_ops_overloads">bind_comparison_ops_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_constant" href="#gen.FABGen.bind_constant">bind_constant</a></code></li>
<li><code><a title="gen.FABGen.bind_constants" href="#gen.FABGen.bind_constants">bind_constants</a></code></li>
<li><code><a title="gen.FABGen.bind_constructor" href="#gen.FABGen.bind_constructor">bind_constructor</a></code></li>
<li><code><a title="gen.FABGen.bind_constructor_overloads" href="#gen.FABGen.bind_constructor_overloads">bind_constructor_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_extern_type" href="#gen.FABGen.bind_extern_type">bind_extern_type</a></code></li>
<li><code><a title="gen.FABGen.bind_function" href="#gen.FABGen.bind_function">bind_function</a></code></li>
<li><code><a title="gen.FABGen.bind_function_overloads" href="#gen.FABGen.bind_function_overloads">bind_function_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_inplace_arithmetic_op" href="#gen.FABGen.bind_inplace_arithmetic_op">bind_inplace_arithmetic_op</a></code></li>
<li><code><a title="gen.FABGen.bind_inplace_arithmetic_op_overloads" href="#gen.FABGen.bind_inplace_arithmetic_op_overloads">bind_inplace_arithmetic_op_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_inplace_arithmetic_ops" href="#gen.FABGen.bind_inplace_arithmetic_ops">bind_inplace_arithmetic_ops</a></code></li>
<li><code><a title="gen.FABGen.bind_inplace_arithmetic_ops_overloads" href="#gen.FABGen.bind_inplace_arithmetic_ops_overloads">bind_inplace_arithmetic_ops_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_member" href="#gen.FABGen.bind_member">bind_member</a></code></li>
<li><code><a title="gen.FABGen.bind_members" href="#gen.FABGen.bind_members">bind_members</a></code></li>
<li><code><a title="gen.FABGen.bind_method" href="#gen.FABGen.bind_method">bind_method</a></code></li>
<li><code><a title="gen.FABGen.bind_method_overloads" href="#gen.FABGen.bind_method_overloads">bind_method_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_named_enum" href="#gen.FABGen.bind_named_enum">bind_named_enum</a></code></li>
<li><code><a title="gen.FABGen.bind_ptr" href="#gen.FABGen.bind_ptr">bind_ptr</a></code></li>
<li><code><a title="gen.FABGen.bind_static_member" href="#gen.FABGen.bind_static_member">bind_static_member</a></code></li>
<li><code><a title="gen.FABGen.bind_static_members" href="#gen.FABGen.bind_static_members">bind_static_members</a></code></li>
<li><code><a title="gen.FABGen.bind_static_method" href="#gen.FABGen.bind_static_method">bind_static_method</a></code></li>
<li><code><a title="gen.FABGen.bind_static_method_overloads" href="#gen.FABGen.bind_static_method_overloads">bind_static_method_overloads</a></code></li>
<li><code><a title="gen.FABGen.bind_type" href="#gen.FABGen.bind_type">bind_type</a></code></li>
<li><code><a title="gen.FABGen.bind_variable" href="#gen.FABGen.bind_variable">bind_variable</a></code></li>
<li><code><a title="gen.FABGen.bind_variables" href="#gen.FABGen.bind_variables">bind_variables</a></code></li>
<li><code><a title="gen.FABGen.commit_from_c_vars" href="#gen.FABGen.commit_from_c_vars">commit_from_c_vars</a></code></li>
<li><code><a title="gen.FABGen.ctype_to_plain_string" href="#gen.FABGen.ctype_to_plain_string">ctype_to_plain_string</a></code></li>
<li><code><a title="gen.FABGen.decl_var" href="#gen.FABGen.decl_var">decl_var</a></code></li>
<li><code><a title="gen.FABGen.declare_from_c_var" href="#gen.FABGen.declare_from_c_var">declare_from_c_var</a></code></li>
<li><code><a title="gen.FABGen.defined" href="#gen.FABGen.defined">defined</a></code></li>
<li><code><a title="gen.FABGen.end_class" href="#gen.FABGen.end_class">end_class</a></code></li>
<li><code><a title="gen.FABGen.end_type" href="#gen.FABGen.end_type">end_type</a></code></li>
<li><code><a title="gen.FABGen.finalize" href="#gen.FABGen.finalize">finalize</a></code></li>
<li><code><a title="gen.FABGen.get_conv" href="#gen.FABGen.get_conv">get_conv</a></code></li>
<li><code><a title="gen.FABGen.get_language" href="#gen.FABGen.get_language">get_language</a></code></li>
<li><code><a title="gen.FABGen.get_output" href="#gen.FABGen.get_output">get_output</a></code></li>
<li><code><a title="gen.FABGen.get_symbol_doc" href="#gen.FABGen.get_symbol_doc">get_symbol_doc</a></code></li>
<li><code><a title="gen.FABGen.get_symbol_doc_hook" href="#gen.FABGen.get_symbol_doc_hook">get_symbol_doc_hook</a></code></li>
<li><code><a title="gen.FABGen.get_type_tag_cast_function" href="#gen.FABGen.get_type_tag_cast_function">get_type_tag_cast_function</a></code></li>
<li><code><a title="gen.FABGen.insert_binding_code" href="#gen.FABGen.insert_binding_code">insert_binding_code</a></code></li>
<li><code><a title="gen.FABGen.insert_code" href="#gen.FABGen.insert_code">insert_code</a></code></li>
<li><code><a title="gen.FABGen.output_header" href="#gen.FABGen.output_header">output_header</a></code></li>
<li><code><a title="gen.FABGen.output_includes" href="#gen.FABGen.output_includes">output_includes</a></code></li>
<li><code><a title="gen.FABGen.output_linker_api" href="#gen.FABGen.output_linker_api">output_linker_api</a></code></li>
<li><code><a title="gen.FABGen.parse_ctype" href="#gen.FABGen.parse_ctype">parse_ctype</a></code></li>
<li><code><a title="gen.FABGen.parse_named_ctype" href="#gen.FABGen.parse_named_ctype">parse_named_ctype</a></code></li>
<li><code><a title="gen.FABGen.prepare_from_c_var" href="#gen.FABGen.prepare_from_c_var">prepare_from_c_var</a></code></li>
<li><code><a title="gen.FABGen.prepare_to_c_var" href="#gen.FABGen.prepare_to_c_var">prepare_to_c_var</a></code></li>
<li><code><a title="gen.FABGen.proxy_call_error" href="#gen.FABGen.proxy_call_error">proxy_call_error</a></code></li>
<li><code><a title="gen.FABGen.rbind_function" href="#gen.FABGen.rbind_function">rbind_function</a></code></li>
<li><code><a title="gen.FABGen.rval_assign_arg_in_out" href="#gen.FABGen.rval_assign_arg_in_out">rval_assign_arg_in_out</a></code></li>
<li><code><a title="gen.FABGen.select_args_convs" href="#gen.FABGen.select_args_convs">select_args_convs</a></code></li>
<li><code><a title="gen.FABGen.select_ctype_conv" href="#gen.FABGen.select_ctype_conv">select_ctype_conv</a></code></li>
<li><code><a title="gen.FABGen.start" href="#gen.FABGen.start">start</a></code></li>
<li><code><a title="gen.FABGen.typedef" href="#gen.FABGen.typedef">typedef</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gen.TypeConverter" href="#gen.TypeConverter">TypeConverter</a></code></h4>
<ul class="">
<li><code><a title="gen.TypeConverter.add_feature" href="#gen.TypeConverter.add_feature">add_feature</a></code></li>
<li><code><a title="gen.TypeConverter.finalize_type" href="#gen.TypeConverter.finalize_type">finalize_type</a></code></li>
<li><code><a title="gen.TypeConverter.from_c_call" href="#gen.TypeConverter.from_c_call">from_c_call</a></code></li>
<li><code><a title="gen.TypeConverter.get_all_members" href="#gen.TypeConverter.get_all_members">get_all_members</a></code></li>
<li><code><a title="gen.TypeConverter.get_all_methods" href="#gen.TypeConverter.get_all_methods">get_all_methods</a></code></li>
<li><code><a title="gen.TypeConverter.get_all_static_members" href="#gen.TypeConverter.get_all_static_members">get_all_static_members</a></code></li>
<li><code><a title="gen.TypeConverter.get_all_static_methods" href="#gen.TypeConverter.get_all_static_methods">get_all_static_methods</a></code></li>
<li><code><a title="gen.TypeConverter.get_operator" href="#gen.TypeConverter.get_operator">get_operator</a></code></li>
<li><code><a title="gen.TypeConverter.get_type_api" href="#gen.TypeConverter.get_type_api">get_type_api</a></code></li>
<li><code><a title="gen.TypeConverter.is_type_class" href="#gen.TypeConverter.is_type_class">is_type_class</a></code></li>
<li><code><a title="gen.TypeConverter.prepare_var_for_conv" href="#gen.TypeConverter.prepare_var_for_conv">prepare_var_for_conv</a></code></li>
<li><code><a title="gen.TypeConverter.prepare_var_from_conv" href="#gen.TypeConverter.prepare_var_from_conv">prepare_var_from_conv</a></code></li>
<li><code><a title="gen.TypeConverter.to_c_call" href="#gen.TypeConverter.to_c_call">to_c_call</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>