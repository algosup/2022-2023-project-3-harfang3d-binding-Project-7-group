<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>rust API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rust</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
from os import stat_result
from pypeg2 import parse
import json
import re
import sys
import time
import importlib

import argparse

import gen
import lib


def route_lambda(name):
        return lambda args: &#34;%s(%s);&#34; % (name, &#34;, &#34;.join(args))


def clean_name(name):
        new_name = str(name).strip().replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;)
        if new_name in [&#34;break&#34;, &#34;default&#34;, &#34;func&#34;, &#34;interface&#34;, &#34;select&#34;, &#34;case&#34;, &#34;defer&#34;, &#34;rust&#34;, &#34;map&#34;, &#34;struct&#34;, &#34;chan&#34;, &#34;else&#34;, &#34;rustto&#34;, &#34;package&#34;, &#34;switch&#34;, &#34;const&#34;, &#34;fallthrough&#34;, &#34;if&#34;, &#34;range&#34;, &#34;type&#34;, &#34;continue&#34;, &#34;for&#34;, &#34;import&#34;, &#34;return&#34;, &#34;var&#34;]:
                return new_name + &#34;Rust&#34;
        return new_name


def clean_name_with_title(name):
        new_name = &#34;&#34;
        if &#34;_&#34; in name:
                # redo a special string.title()
                next_is_forced_uppercase = True
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;]:
                                new_name += c
                        elif c in [&#34;_&#34;, &#34;-&#34;]:
                                next_is_forced_uppercase = True
                        else:
                                if next_is_forced_uppercase:
                                        next_is_forced_uppercase = False
                                        new_name += c.capitalize()
                                else:
                                        new_name += c
        else:
                # make sur the first letter is capitalize
                first_letter_checked = False
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;] or first_letter_checked:
                                new_name += c
                        elif not first_letter_checked:
                                first_letter_checked = True
                                new_name += c.capitalize()
        return new_name.strip().replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;)


class RustTypeConverterCommon(gen.TypeConverter):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=None):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)
                self.base_type = type
                self.rust_to_c_type = None
                self.rust_type = None

        def get_type_api(self, module_name):
                out = &#34;// type API for %s\n&#34; % self.ctype
                if self.c_storage_class:
                        out += &#34;struct %s;\n&#34; % self.c_storage_class
                if self.c_storage_class:
                        out += &#34;void %s(int idx, void *obj, %s &amp;storage);\n&#34; % (
                                self.to_c_func, self.c_storage_class)
                else:
                        out += &#34;void %s(int idx, void *obj);\n&#34; % self.to_c_func
                out += &#34;int %s(void *obj, OwnershipPolicy);\n&#34; % self.from_c_func
                out += &#34;\n&#34;
                return out

        def to_c_call(self, out_var, expr):
                return &#34;&#34;

        def from_c_call(self, out_var, expr, ownership):
                return &#34;%s((void *)%s, %s);\n&#34; % (self.from_c_func, expr, ownership)


class DummyTypeConverter(gen.TypeConverter):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)

        def get_type_api(self, module_name):
                return &#34;&#34;

        def to_c_call(self, in_var, out_var_p, is_pointer):
                return &#34;&#34;

        def from_c_call(self, out_var, expr, ownership):
                return &#34;&#34;

        def check_call(self, in_var):
                return &#34;&#34;

        def get_type_glue(self, gen, module_name):
                return &#34;&#34;


class RustPtrTypeConverter(gen.TypeConverter):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)

        def get_type_api(self, module_name):
                return &#34;&#34;

        def to_c_call(self, in_var, out_var_p, is_pointer):
                return &#34;&#34;

        def from_c_call(self, out_var, expr, ownership):
                return &#34;&#34;

        def check_call(self, in_var):
                return &#34;&#34;

        def get_type_glue(self, gen, module_name):
                return &#34;&#34;


class RustClassTypeDefaultConverter(RustTypeConverterCommon):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)

        def is_type_class(self):
                return True

        def get_type_api(self, module_name):
                return &#34;&#34;

        def to_c_call(self, in_var, out_var_p, is_pointer):
                out = f&#34;{out_var_p.replace(&#39;&amp;&#39;, &#39;_&#39;)} := {in_var}.h\n&#34;
                return out

        def from_c_call(self, out_var, expr, ownership):
                return &#34;&#34;

        def check_call(self, in_var):
                return &#34;&#34;

        def get_type_glue(self, gen, module_name):
                return &#34;&#34;


class RustExternTypeConverter(RustTypeConverterCommon):
        def __init__(self, type, to_c_storage_type, bound_name, module):
                super().__init__(type, to_c_storage_type, bound_name)
                self.module = module

        def get_type_api(self, module_name):
                return &#39;&#39;

        def to_c_call(self, in_var, out_var_p):
                out = &#39;&#39;
                if self.c_storage_class:
                        c_storage_var = &#39;storage_%s&#39; % out_var_p.replace(&#39;&amp;&#39;, &#39;_&#39;)
                        out += &#39;%s %s;\n&#39; % (self.c_storage_class, c_storage_var)
                        out += &#39;(*%s)(%s, (void *)%s, %s);\n&#39; % (self.to_c_func,
                                                                                                         in_var, out_var_p, c_storage_var)
                else:
                        out += &#39;(*%s)(%s, (void *)%s);\n&#39; % (self.to_c_func,
                                                                                                 in_var, out_var_p)
                return out

        def from_c_call(self, out_var, expr, ownership):
                return &#34;%s = (*%s)((void *)%s, %s);\n&#34; % (out_var, self.from_c_func, expr, ownership)

        def check_call(self, in_var):
                return &#34;(*%s)(%s)&#34; % (self.check_func, in_var)

        def get_type_glue(self, gen, module_name):
                out = &#39;// extern type API for %s\n&#39; % self.ctype
                if self.c_storage_class:
                        out += &#39;struct %;\n&#39; % self.c_storage_class
                out += &#39;bool (*%s)(void *o) = nullptr;\n&#39; % self.check_func
                if self.c_storage_class:
                        out += &#39;void (*%s)(void *o, void *obj, %s &amp;storage) = nullptr;\n&#39; % (
                                self.to_c_func, self.c_storage_class)
                else:
                        out += &#39;void (*%s)(void *o, void *obj) = nullptr;\n&#39; % self.to_c_func
                out += &#39;int (*%s)(void *obj, OwnershipPolicy) = nullptr;\n&#39; % self.from_c_func
                out += &#39;\n&#39;
                return out


class RustGenerator(gen.FABGen):
        default_ptr_converter = RustPtrTypeConverter
        default_class_converter = RustClassTypeDefaultConverter
        default_extern_converter = RustExternTypeConverter

        def __init__(self):
                super().__init__()
                self.check_self_type_in_ops = True
                self.rust = &#34;&#34;
                self.rust_directives = f&#39;// rust wrapper header\n&#39; \
                        &#39;#![allow(dead_code)]\n&#39; \


        def get_language(self):
                return &#34;Rust&#34;

        def output_includes(self):
                pass

        def start(self, module_name):
                super().start(module_name)

                self._source += self.get_binding_api_declaration()

        def set_compilation_directives(self, directives):
                self.rust_directives = directives

        # kill a bunch of functions we don&#39;t care about
        def set_error(self, type, reason):
                return &#34;&#34;

        def get_self(self, ctx):
                return &#34;&#34;

        def get_var(self, i, ctx):
                return &#34;&#34;

        def open_proxy(self, name, max_arg_count, ctx):
                return &#34;&#34;

        def _proto_call(self, self_conv, proto, expr_eval, ctx, fixed_arg_count=None):
                return &#34;&#34;

        def _bind_proxy(self, name, self_conv, protos, desc, expr_eval, ctx, fixed_arg_count=None):
                return &#34;&#34;

        def close_proxy(self, ctx):
                return &#34;&#34;

        def proxy_call_error(self, msg, ctx):
                return &#34;&#34;

        def return_void_from_c(self):
                return &#34;&#34;

        def rval_from_nullptr(self, out_var):
                return &#34;&#34;

        def rval_from_c_ptr(self, conv, out_var, expr, ownership):
                return &#34;&#34;

        def commit_from_c_vars(self, rvals, ctx=&#34;default&#34;):
                return &#34;&#34;

        def rbind_function(self, name, rval, args, internal=False):
                return &#34;&#34;

        #
        def get_binding_api_declaration(self):
                type_info_name = gen.apply_api_prefix(&#34;type_info&#34;)

                out = &#39;&#39;&#39;\
struct %s {
        uint32_t type_tag;
        const char *c_type;
        const char *bound_name;

        bool (*check)(void* p);
        void (*to_c)(void *p, void *out);
        int (*from_c)(void *obj, OwnershipPolicy policy);
};\n
&#39;&#39;&#39; % type_info_name

                out += &#34;// return a type info from its type tag\n&#34;
                out += &#34;%s *%s(uint32_t type_tag);\n&#34; % (type_info_name,
                                                                                                 gen.apply_api_prefix(&#34;get_bound_type_info&#34;))

                out += &#34;// return a type info from its type name\n&#34;
                out += &#34;%s *%s(const char *type);\n&#34; % (type_info_name,
                                                                                                gen.apply_api_prefix(&#34;get_c_type_info&#34;))

                out += &#34;// returns the typetag of a userdata object, nullptr if not a Fabgen object\n&#34;
                out += &#34;uint32_t %s(void* p);\n\n&#34; % gen.apply_api_prefix(
                        &#34;get_wrapped_object_type_tag&#34;)

                return out

        def output_binding_api(self):
                type_info_name = gen.apply_api_prefix(&#34;type_info&#34;)
                self._source += &#34;&#34;&#34;\
%s *%s(uint32_t type_tag) {
        return nullptr;
}\n\n&#34;&#34;&#34; % (
                        type_info_name,
                        gen.apply_api_prefix(&#34;get_bound_type_info&#34;),
                )

                self._source += &#34;&#34;&#34;
%s *%s(const char *type) {
        return nullptr;
}\n\n&#34;&#34;&#34; % (
                        type_info_name,
                        gen.apply_api_prefix(&#34;get_c_type_info&#34;),
                )

                self._source += &#34;&#34;&#34;\
uint32_t %s(void* p) {
        return 0;
        //auto o = cast_to_wrapped_Object_safe(L, idx);
        //return o ? o-&gt;type_tag : 0;
}\n\n&#34;&#34;&#34; % gen.apply_api_prefix(&#34;get_wrapped_object_type_tag&#34;)

        #
        def get_output(self):
                return {&#34;wrapper.cpp&#34;: self.rust_c, &#34;wrapper.h&#34;: self.rust_h, &#34;bind.rs&#34;: self.rust_bind, &#34;translate_file.json&#34;: self.rust_translate_file}

        def _get_type(self, name):
                for type in self._bound_types:
                        if type:
                                return type
                return None

        def _get_conv(self, conv_name):
                if conv_name in self._FABGen__type_convs:
                        return self.get_conv(conv_name)
                return None

        def _get_conv_from_bound_name(self, bound_name):
                for name, conv in self._FABGen__type_convs.items():
                        if conv.bound_name == bound_name:
                                return conv
                return None

        def __get_is_type_class_or_pointer_with_class(self, conv):
                if conv.is_type_class() or \
                                (isinstance(conv, RustPtrTypeConverter) and self._get_conv(str(conv.ctype.scoped_typename)) is None):
                        return True
                return False

        def __get_stars(self, val, start_stars=0, add_start_for_ref=True):
                stars = &#34;*&#34; * start_stars
                if &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;):
                        stars += &#34;*&#34; * \
                                (len(val[&#34;carg&#34;].ctype.ref)
                                 if add_start_for_ref else val[&#34;carg&#34;].ctype.ref.count(&#39;*&#39;))
                elif &#34;storage_ctype&#34; in val and hasattr(val[&#34;storage_ctype&#34;], &#34;ref&#34;):
                        stars += &#34;*&#34; * (len(val[&#34;storage_ctype&#34;].ref)
                                                        if add_start_for_ref else val[&#34;storage_ctype&#34;].ref.count(&#39;*&#39;))
                elif hasattr(val[&#34;conv&#34;].ctype, &#34;ref&#34;):
                        stars += &#34;*&#34; * \
                                (len(val[&#34;conv&#34;].ctype.ref)
                                 if add_start_for_ref else val[&#34;conv&#34;].ctype.ref.count(&#39;*&#39;))
                return stars

        def __arg_from_cpp_to_c(self, val, retval_name, just_copy):
                src = &#34;&#34;
                # type class, not a pointer
                if val[&#39;conv&#39;] is not None and val[&#39;conv&#39;].is_type_class() and \
                                not val[&#39;conv&#39;].ctype.is_pointer() and (&#39;storage_ctype&#39; not in val or not hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) or not any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])):
                        # special shared ptr
                        if &#39;proxy&#39; in val[&#39;conv&#39;]._features:
                                src += f&#34;       if(!{retval_name})\n&#34; \
                                        &#34;               return nullptr;\n&#34;

                                src += &#34;        auto &#34; + \
                                        val[&#39;conv&#39;]._features[&#39;proxy&#39;].wrap(&#34;ret&#34;, &#34;retPointer&#34;)
                        # special std::future
                        elif val[&#34;conv&#34;] is not None and &#34;std::future&#34; in str(val[&#34;conv&#34;].ctype):
                                src += f&#34;       auto retPointer = new std::future&lt;int&gt;(std::move({retval_name}));\n&#34;
                        else:
                                # class, not pointer, but static
                                if just_copy:
                                        src += f&#34;       auto retPointer = {retval_name};\n&#34;
                                else:
                                        src += f&#34;       auto retPointer = new {val[&#39;conv&#39;].ctype}({retval_name});\n&#34;
                        retval_name = f&#34;({clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})(retPointer)&#34;
                else:
                        # special std::string (convert to const char*)
                        if val[&#34;conv&#34;] is not None and &#34;std::string&#34; in str(val[&#34;conv&#34;].ctype):
                                stars = self.__get_stars(val)
                                if len(stars) &gt; 0:  # rarely use but just in case
                                        retval_name = f&#34;new const char*(&amp;(*{retval_name}-&gt;begin()))&#34;
                                else:
                                        retval_name = f&#34;{retval_name}.c_str()&#34;
                        else:
                                retval_name = f&#34;{retval_name}&#34;

                # cast it
                # if it&#39;s an enum
                if val[&#34;conv&#34;].bound_name in self._enums.keys():
                        enum_conv = self._get_conv_from_bound_name(val[&#39;conv&#39;].bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                arg_bound_name = str(enum_conv.base_type)
                        else:
                                arg_bound_name = &#34;int&#34;
                        retval_name = f&#34;({arg_bound_name}){retval_name}&#34;
                # cast it, if it&#39;s a const
                elif &#39;storage_ctype&#39; in val and val[&#34;storage_ctype&#34;].const or \
                                &#39;carg&#39; in val and val[&#34;carg&#34;].ctype.const:
                        arg_bound_name = self.__get_arg_bound_name_to_c(val)
                        retval_name = f&#34;({arg_bound_name}){retval_name}&#34;

                return src, retval_name

        def __arg_from_c_to_cpp(self, val, retval_name, add_star=True):
                src = &#34;&#34;
                # check if there is special slice to convert
                if isinstance(val[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                        # special if string or const char*
                        if &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;].T_conv):  # or \
                                # &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;].T_conv):
                                src += f&#34;std::vector&lt;{val[&#39;conv&#39;].T_conv.ctype}&gt; {retval_name};\n&#34;\
                                        f&#34;for(int i_counter_c=0; i_counter_c &lt; {retval_name}ToCSize; ++i_counter_c)\n&#34;\
                                        f&#34;      {retval_name}.push_back(std::string({retval_name}ToCBuf[i_counter_c]));\n&#34;
                        # slice from class
                        elif self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;].T_conv):
                                src += f&#34;std::vector&lt;{val[&#39;conv&#39;].T_conv.ctype}&gt; {retval_name};\n&#34;\
                                        f&#34;for(int i_counter_c=0; i_counter_c &lt; {retval_name}ToCSize; ++i_counter_c)\n&#34;\
                                        f&#34;      {retval_name}.push_back(*(({val[&#39;conv&#39;].T_conv.ctype}**){retval_name}ToCBuf)[i_counter_c]);\n&#34;
                        else:
                                src += f&#34;std::vector&lt;{val[&#39;conv&#39;].T_conv.ctype}&gt; {retval_name}(({val[&#39;conv&#39;].T_conv.ctype}*){retval_name}ToCBuf, ({val[&#39;conv&#39;].T_conv.ctype}*){retval_name}ToCBuf + {retval_name}ToCSize);\n&#34;

                retval = &#34;&#34;
                # very special case, std::string &amp;
                if &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;]) and \
                                &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;]) and \
                                not val[&#34;carg&#34;].ctype.const:
                        src += f&#34;std::string {retval_name}_cpp(*{retval_name});\n&#34;
                        retval += f&#34;{retval_name}_cpp&#34;
                # std::function
                elif &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        func_name = val[&#34;conv&#34;].base_type.replace(
                                &#34;std::function&lt;&#34;, &#34;&#34;)[:-1]
                        first_parenthesis = func_name.find(&#34;(&#34;)
                        retval += f&#34;({func_name[:first_parenthesis]}(*){func_name[first_parenthesis:]}){retval_name}&#34;
                # classe or pointer on class
                else:
                        if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                stars = self.__get_stars(val, add_start_for_ref=False)
                                # for type pointer, there is a * in the ctype, so remove one
                                if isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):
                                        stars = stars[1:]

                                # if it&#39;s not a pointer, add a star anyway because we use pointer to use in rust
                                if (not val[&#34;conv&#34;].ctype.is_pointer() and (&#34;carg&#34; not in val or (&#34;carg&#34; in val and not val[&#34;carg&#34;].ctype.is_pointer()))):
                                        stars += &#34;*&#34;
                                        if add_star:
                                                retval += &#34;*&#34;

                                retval += f&#34;({val[&#39;conv&#39;].ctype}{stars}){retval_name}&#34;

                        elif &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;]) and not val[&#34;carg&#34;].ctype.const:
                                # add cast and *
                                retval = f&#34;({val[&#39;carg&#39;].ctype})(*{retval_name})&#34;
                        # cast, if it&#39;s an enum
                        elif val[&#34;conv&#34;].bound_name in self._enums.keys():
                                retval = f&#34;({val[&#39;conv&#39;].ctype}){retval_name}&#34;
                        else:
                                retval = retval_name

                return src, retval

        def __arg_from_c_to_rust(self, val, retval_name, non_owning=False):

                rval_ownership = self._FABGen__ctype_to_ownership_policy(
                        val[&#34;conv&#34;].ctype)

                src = &#34;&#34;
                # check if pointer
                if (&#39;carg&#39; in val and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                (&#39;carg&#39; not in val and &#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                (&#39;carg&#39; not in val and &#39;storage_ctype&#39; not in val and (val[&#39;conv&#39;]._is_pointer or val[&#39;conv&#39;].ctype.is_pointer())):
                        is_pointer = True
                else:
                        is_pointer = False

                # check if ref
                if (&#39;carg&#39; in val and (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;]))) or \
                                (&#39;carg&#39; not in val and &#39;storage_ctype&#39; in val and ((hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;])))):
                        is_ref = True
                else:
                        is_ref = False

                # check if need convert from c
                # if not a pointer
                if not is_pointer:
                        if val[&#39;conv&#39;].bound_name in self._enums.keys():  # if it&#39;s an enum
                                retval_name = f&#34;{val[&#39;conv&#39;].bound_name}({retval_name})&#34;
                        else:
                                conversion_ret = val[&#39;conv&#39;].from_c_call(retval_name, &#34;&#34;, &#34;&#34;)
                                if conversion_ret != &#34;&#34;:
                                        retval_name = conversion_ret

                                # if it&#39;s a class, not a pointer, only out, create the class special
                                if val[&#34;conv&#34;].is_type_class():
                                        retval_boundname = val[&#34;conv&#34;].bound_name
                                        retval_boundname = clean_name_with_title(retval_boundname)

                                        src += f&#34;       {retval_name}RUST := &amp;{retval_boundname}{{h:{retval_name}}}\n&#34;

                                        # check if owning to have the right to destroy it
                                        if rval_ownership != &#34;NonOwning&#34; and not is_ref and not non_owning:
                                                src += f&#34;       runtime.SetFinalizer({retval_name}RUST, func(cleanval *{retval_boundname}) {{\n&#34; \
                                                        f&#34;              C.{clean_name_with_title(self._name)}{retval_boundname}Free(cleanval.h)\n&#34; \
                                                        f&#34;      }})\n&#34;
                                        retval_name = f&#34;{retval_name}RUST&#34;

                # if pointer or ref
                elif is_pointer:
                        # special const char * and string
                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]) or \
                                        &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;]):
                                stars = self.__get_stars(val)

                                retval_name_from_c = &#34;*&#34;*len(stars) + retval_name
                                if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]):
                                        retval_name_from_c = &#34;*&#34;*(len(stars) - 1) + retval_name

                                conversion_ret = val[&#39;conv&#39;].from_c_call(
                                        retval_name_from_c, &#34;&#34;, &#34;&#34;)

                                if len(stars) &gt; 0:
                                        prefix = &#34;&amp;&#34; * len(stars)
                                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]):
                                                prefix = &#34;&amp;&#34; * (len(stars)-1)

                                        src += f&#34;{retval_name}RUST := string({conversion_ret})\n&#34;
                                        retval_name = prefix + retval_name + &#34;RUST&#34;
                                else:
                                        conversion_ret = retval_name

                        # if it&#39;s a class, a pointer, only out, create the class special
                        elif self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                retval_boundname = val[&#39;conv&#39;].bound_name
                                retval_boundname = clean_name_with_title(retval_boundname)
                                src += f&#34;var {retval_name}RUST *{retval_boundname}\n&#34; \
                                        f&#34;if {retval_name} != nil {{\n&#34; \
                                        f&#34;      {retval_name}RUST = &amp;{retval_boundname}{{h:{retval_name}}}\n&#34;

                                # check if owning to have the right to destroy it
                                if rval_ownership != &#34;NonOwning&#34; and not is_ref and not non_owning:
                                        src += f&#34;       runtime.SetFinalizer({retval_name}RUST, func(cleanval *{retval_boundname}) {{\n&#34; \
                                                f&#34;              C.{clean_name_with_title(self._name)}{retval_boundname}Free(cleanval.h)\n&#34;\
                                                f&#34;      }})\n&#34;
                                src += &#34;}\n&#34;
                                retval_name = f&#34;{retval_name}RUST&#34;
                        else:
                                retval_name = f&#34;({self.__get_arg_bound_name_to_rust(val)})(unsafe.Pointer({retval_name}))\n&#34;

                return src, retval_name

        def __arg_from_rust_to_c(self, val, arg_name):
                def convert_rust_to_c(val, arg_name, arg_out_name, start_stars=0):
                        stars = self.__get_stars(val, start_stars)

                        if val[&#34;conv&#34;].is_type_class():
                                c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                        else:
                                # get base conv (without pointer)
                                base_conv = self._get_conv(
                                        str(val[&#34;conv&#34;].ctype.scoped_typename))
                                if base_conv is None:
                                        if isinstance(val[&#34;conv&#34;], RustPtrTypeConverter):
                                                c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars[1:]}C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                                        else:
                                                c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}{str(val[&#39;conv&#39;].bound_name)})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                                elif hasattr(base_conv, &#34;rust_to_c_type&#34;) and base_conv.rust_to_c_type is not None:
                                        c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}{base_conv.rust_to_c_type})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                                else:
                                        c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}{base_conv.bound_name})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                        return c_call

                c_call = &#34;&#34;
                # if it&#39;s a pointer on something
                if isinstance(val[&#34;conv&#34;], RustPtrTypeConverter):
                        base_conv = self._get_conv(str(val[&#34;conv&#34;].ctype.scoped_typename))
                        if base_conv is None or base_conv.is_type_class():
                                c_call = f&#34;{clean_name(arg_name)}ToC := {clean_name(arg_name)}.h\n&#34;
                        else:
                                c_call = convert_rust_to_c(val, arg_name, f&#34;{arg_name}ToC&#34;)
                # if it&#39;s a class
                elif val[&#34;conv&#34;].is_type_class():
                        stars = self.__get_stars(val)
                        c_call = f&#34;{clean_name(arg_name)}ToC := {stars[1:]}{clean_name(arg_name)}.h\n&#34;
                # if it&#39;s an enum
                elif val[&#34;conv&#34;].bound_name in self._enums.keys():
                        enum_conv = self._get_conv_from_bound_name(val[&#34;conv&#34;].bound_name)
                        # if it&#39;s a ref to an enum
                        if len(self.__get_stars(val)) &gt; 0:
                                c_call = convert_rust_to_c(val, arg_name, f&#34;{arg_name}ToC&#34;)
                        else:
                                if enum_conv is not None and hasattr(enum_conv, &#34;rust_to_c_type&#34;) and enum_conv.rust_to_c_type is not None:
                                        arg_bound_name = enum_conv.rust_to_c_type
                                else:
                                        arg_bound_name = &#34;C.int&#34;

                                c_call = f&#34;{clean_name(arg_name)}ToC := {arg_bound_name}({clean_name(arg_name)})\n&#34;
                # special Slice
                elif isinstance(val[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                        c_call = &#34;&#34;
                        slice_name = clean_name(arg_name)
                        # special if string or const char*
                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;].T_conv) or \
                                        &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;].T_conv):
                                c_call += f&#34;var {slice_name}SpecialString []*C.char\n&#34;
                                c_call += f&#34;for _, s := range {slice_name} {{\n&#34;
                                c_call += f&#34;    {slice_name}SpecialString = append({slice_name}SpecialString, C.CString(s))\n&#34;
                                c_call += f&#34;}}\n&#34;
                                slice_name = f&#34;{slice_name}SpecialString&#34;

                        # if it&#39;s a class, get a list of pointer to c class
                        elif self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;].T_conv):
                                c_call += f&#34;var {slice_name}Pointer  []C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].T_conv.bound_name)}\n&#34;
                                c_call += f&#34;for _, s := range {slice_name} {{\n&#34;
                                c_call += f&#34;    {slice_name}Pointer = append({slice_name}Pointer, s.h)\n&#34;
                                c_call += f&#34;}}\n&#34;
                                slice_name = f&#34;{slice_name}Pointer&#34;

                        c_call += f&#34;{slice_name}ToC := (*reflect.SliceHeader)(unsafe.Pointer(&amp;{slice_name}))\n&#34;
                        c_call += f&#34;{slice_name}ToCSize := C.size_t({slice_name}ToC.Len)\n&#34;

                        c_call += convert_rust_to_c(
                                {&#34;conv&#34;: val[&#34;conv&#34;].T_conv}, f&#34;{slice_name}ToC.Data&#34;, f&#34;{slice_name}ToCBuf&#34;, 1)
                # std function
                elif &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        c_call += f&#34;{clean_name(arg_name)}ToC := (C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})({clean_name(arg_name)})\n&#34;
                else:
                        how_many_stars = 0
                        # compute how many stars (to handle specifically the const char *)
                        if &#34;carg&#34; in val:
                                if hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;]) and not val[&#34;carg&#34;].ctype.const:
                                        how_many_stars = len(val[&#34;carg&#34;].ctype.ref)
                                elif val[&#34;carg&#34;].ctype.is_pointer():
                                        how_many_stars = 1
                        else:
                                if hasattr(val[&#34;conv&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;conv&#34;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;]) and not val[&#34;carg&#34;].ctype.const:
                                        how_many_stars = len(val[&#34;conv&#34;].ctype.ref)
                                elif val[&#34;conv&#34;].ctype.is_pointer():
                                        how_many_stars = 1

                        is_pointer = True
                        if how_many_stars == 0 or \
                                        (how_many_stars == 1 and &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;])):
                                is_pointer = False
                        c_call = val[&#34;conv&#34;].to_c_call(clean_name(
                                arg_name), f&#34;{clean_name(arg_name)}ToC&#34;, is_pointer)
                return c_call

        def __get_arg_bound_name_to_rust(self, val):
                if val[&#34;conv&#34;].is_type_class():
                        arg_bound_name = val[&#34;conv&#34;].bound_name
                else:
                        # check the convert from the base (in case of ptr) or a string
                        if (&#39;carg&#39; in val and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        (&#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):

                                if hasattr(val[&#34;conv&#34;], &#34;rust_type&#34;) and val[&#34;conv&#34;].rust_type is not None:
                                        arg_bound_name = str(val[&#34;conv&#34;].rust_type)
                                else:
                                        base_conv = self._get_conv(
                                                str(val[&#39;conv&#39;].ctype.scoped_typename))
                                        if base_conv is None:
                                                arg_bound_name = str(val[&#34;conv&#34;].bound_name)
                                        else:
                                                if hasattr(base_conv, &#34;rust_type&#34;) and base_conv.rust_type is not None:
                                                        arg_bound_name = base_conv.rust_type
                                                else:
                                                        arg_bound_name = base_conv.bound_name
                        else:
                                if val[&#39;conv&#39;].bound_name in self._enums.keys():  # if it&#39;s an enum
                                        arg_bound_name = f&#34;{val[&#39;conv&#39;].bound_name}&#34;
                                elif hasattr(val[&#34;conv&#34;], &#34;rust_type&#34;) and val[&#34;conv&#34;].rust_type is not None:
                                        arg_bound_name = val[&#34;conv&#34;].rust_type
                                else:
                                        arg_bound_name = val[&#34;conv&#34;].bound_name

                if arg_bound_name.endswith(&#34;_nobind&#34;) and val[&#34;conv&#34;].nobind:
                        arg_bound_name = arg_bound_name[:-len(&#34;_nobind&#34;)]

                # if it&#39;s a pointer and not a string not a const
                if ((&#39;carg&#39; in val and (not val[&#34;carg&#34;].ctype.const and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;]))))) or
                                (&#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or
                                isinstance(val[&#39;conv&#39;], RustPtrTypeConverter)):
                        # find how many * we need to add
                        stars = &#34;*mut &#34;
                        if &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;):
                                stars += &#34;*mut &#34; * (len(val[&#34;carg&#34;].ctype.ref) - 1)
                        if &#34;storage_ctype&#34; in val and hasattr(val[&#34;storage_ctype&#34;], &#34;ref&#34;):
                                stars += &#34;*mut &#34; * (len(val[&#34;storage_ctype&#34;].ref) - 1)

                        # special const char *
                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]):
                                stars = stars[1:]

                        # Harfang class doesn&#39;t need to be a pointer in rust (because it&#39;s a struct containing a wrap pointer C)
                        if not self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                arg_bound_name = stars + arg_bound_name

                # std function
                if &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        arg_bound_name = &#34;unsafe.Pointer&#34;

                # class or slice, clean the name with title
                if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]) or \
                                isinstance(val[&#39;conv&#39;], lib.rust.stl.RustSliceToStdVectorConverter):
                        arg_bound_name = clean_name_with_title(arg_bound_name)

                # i&#39;f it&#39;s a class, it&#39;s a pointer
                if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                        arg_bound_name = &#34;*mut &#34; + arg_bound_name

                return arg_bound_name

        def __get_arg_bound_name_to_c(self, val):
                arg_bound_name = &#34;&#34;

                # check to add const
                if &#39;storage_ctype&#39; in val and val[&#34;storage_ctype&#34;].const or \
                                &#39;carg&#39; in val and val[&#34;carg&#34;].ctype.const:
                        arg_bound_name += &#34;const &#34;

                # if class or pointer with class
                if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]) or \
                                &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        arg_bound_name += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)} &#34;
                else:
                        # check the convert from the base (in case of ptr)
                        if (&#39;carg&#39; in val and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        (&#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):
                                # check if it&#39;s an enum
                                if val[&#39;conv&#39;].bound_name in self._enums.keys():
                                        enum_conv = self._get_conv_from_bound_name(
                                                val[&#39;conv&#39;].bound_name)
                                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                                arg_bound_name = str(enum_conv.base_type)
                                        else:
                                                arg_bound_name = &#34;int&#34;
                                else:
                                        # sometimes typedef is weird and don&#39;t give valid value, so check it
                                        base_conv = self._get_conv(str(val[&#39;conv&#39;].bound_name))
                                        if base_conv is None:
                                                # check with typedef
                                                if hasattr(val[&#39;conv&#39;], &#34;base_type&#34;) and val[&#39;conv&#39;].base_type is not None:
                                                        arg_bound_name = str(val[&#39;conv&#39;].base_type)
                                                else:
                                                        if &#39;storage_ctype&#39; in val:
                                                                arg_bound_name += f&#34;{val[&#39;storage_ctype&#39;]} &#34;
                                                        else:
                                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].ctype} &#34;

                                                # if it&#39;s a ptr type, remove a star
                                                if isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):
                                                        arg_bound_name = arg_bound_name.replace(
                                                                &#34;*&#34;, &#34;&#34;).replace(&#34;&amp;&#34;, &#34;&#34;)
                                        else:
                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].bound_name} &#34;

                                # add a star (only if it&#39;s not a const char * SPECIAL CASE)
                                if &#34;RustConstCharPtrConverter&#34; not in str(val[&#34;conv&#34;]):
                                        arg_bound_name += &#34;*&#34;

                                if &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and not val[&#34;carg&#34;].ctype.const:
                                        arg_bound_name += &#34;*&#34; * (len(val[&#34;carg&#34;].ctype.ref) - 1)
                                if &#34;storage_ctype&#34; in val and hasattr(val[&#34;storage_ctype&#34;], &#34;ref&#34;):
                                        arg_bound_name += &#34;*&#34; * (len(val[&#34;storage_ctype&#34;].ref) - 1)
                        else:
                                # check if it&#39;s an enum
                                if val[&#39;conv&#39;].bound_name in self._enums.keys():
                                        enum_conv = self._get_conv_from_bound_name(
                                                val[&#39;conv&#39;].bound_name)
                                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                                arg_bound_name = str(enum_conv.base_type)
                                        else:
                                                arg_bound_name = &#34;int&#34;
                                else:
                                        # sometimes typedef is weird and don&#39;t give valid value, so check it
                                        base_conv = self._get_conv(str(val[&#39;conv&#39;].bound_name))
                                        if base_conv is None:
                                                if hasattr(val[&#39;conv&#39;], &#34;base_type&#34;) and val[&#39;conv&#39;].base_type is not None:
                                                        arg_bound_name = str(val[&#39;conv&#39;].base_type)
                                                else:
                                                        if &#39;storage_ctype&#39; in val:
                                                                arg_bound_name += f&#34;{val[&#39;storage_ctype&#39;]} &#34;
                                                        else:
                                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].ctype} &#34;
                                        else:
                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].bound_name} &#34;
                return arg_bound_name

        def __extract_sequence(self, conv, is_in_header=False):
                rust = &#34;&#34;

                cleanClassname = clean_name_with_title(conv.bound_name)

                internal_conv = conv._features[&#34;sequence&#34;].wrapped_conv

                arg_bound_name = self.__get_arg_bound_name_to_c(
                        {&#34;conv&#34;: internal_conv})

                # special std::string (convert to const char*)
                c_arg_bound_name = arg_bound_name.replace(&#34;std::string&#34;, &#34;const char*&#34;)
                c_arg_bound_name = c_arg_bound_name.replace(&#34;const const&#34;, &#34;const&#34;)

                # GET
                if is_in_header:
                        rust += &#34;extern &#34;
                rust += f&#34;{c_arg_bound_name} {clean_name_with_title(self._name)}{cleanClassname}GetOperator({clean_name_with_title(self._name)}{cleanClassname} h, int id)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += f&#34;{{\n&#34; \
                                        &#34;       bool error;\n&#34; \
                                        f&#34;      {internal_conv.ctype} v;\n      &#34;
                        rust += conv._features[&#39;sequence&#39;].get_item(
                                f&#34;(({conv.ctype}*)h)&#34;, &#34;id&#34;, &#34;v&#34;, &#34;error&#34;)

                        src, retval_c = self.__arg_from_cpp_to_c(
                                {&#34;conv&#34;: internal_conv}, &#34;v&#34;, False)
                        rust += src
                        rust += f&#34;      return {retval_c};\n}}\n&#34;

                # SET
                if is_in_header:
                        rust += &#34;extern &#34;
                rust += f&#34;void {clean_name_with_title(self._name)}{cleanClassname}SetOperator({clean_name_with_title(self._name)}{cleanClassname} h, int id, {c_arg_bound_name} v)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += f&#34;{{\n&#34; \
                                        &#34;       bool error;\n&#34;

                        src, inval = self.__arg_from_c_to_cpp(
                                {&#34;conv&#34;: internal_conv}, &#34;v&#34;, False)
                        rust += src

                        rust += conv._features[&#39;sequence&#39;].set_item(
                                f&#34;(({conv.ctype}*)h)&#34;, &#34;id&#34;, inval, &#34;error&#34;)
                        rust += f&#34;\n}}\n&#34;

                # LEN
                if is_in_header:
                        rust += &#34;extern &#34;
                rust += f&#34;int {clean_name_with_title(self._name)}{cleanClassname}LenOperator({clean_name_with_title(self._name)}{cleanClassname} h)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += f&#34;{{\n&#34; \
                                        &#34;       int size;\n     &#34;
                        rust += conv._features[&#39;sequence&#39;].get_size(
                                f&#34;(({conv.ctype}*)h)&#34;, &#34;size&#34;)
                        rust += f&#34;      return size;\n}}\n&#34;

                return rust

        def __extract_get_set_member(self, classname, convClass, member, static=False, name=None, bound_name=None, is_global=False, is_in_header=False):
                rust = &#34;&#34;
                conv = self.select_ctype_conv(member[&#34;ctype&#34;])

                if &#34;bound_name&#34; in member:
                        bound_name = str(member[&#34;bound_name&#34;])
                elif bound_name is None:
                        bound_name = str(member[&#34;name&#34;])
                if name is None:
                        name = bound_name
                name = clean_name_with_title(name)

                c_name = str(member[&#34;name&#34;])

                cleanClassname = clean_name_with_title(classname)

                # special Slice
                if isinstance(conv, lib.rust.stl.RustSliceToStdVectorConverter):
                        arg_bound_name = self.__get_arg_bound_name_to_c(
                                {&#34;conv&#34;: conv.T_conv})
                else:
                        arg_bound_name = self.__get_arg_bound_name_to_c({&#34;conv&#34;: conv})

                # special std::string (convert to const char*)
                c_arg_bound_name = arg_bound_name.replace(&#34;std::string&#34;, &#34;const char*&#34;)
                c_arg_bound_name = c_arg_bound_name.replace(&#34;const const&#34;, &#34;const&#34;)

                # GET
                if is_in_header:
                        rust += &#34;extern &#34;

                rust += f&#34;{c_arg_bound_name} {clean_name_with_title(self._name)}{cleanClassname}Get{name.replace(&#39;:&#39;, &#39;&#39;)}(&#34;
                if not static and not is_global:
                        rust += f&#34;{clean_name_with_title(self._name)}{cleanClassname} h&#34;
                rust += &#34;)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += &#34;{&#34;
                        # check if the value is a ref
                        prefix = &#34;&#34;
                        if (hasattr(conv.ctype, &#34;ref&#34;) and conv.ctype.ref in [&#34;&amp;&#34;, &#34;*&amp;&#34;]) or \
                                        conv.is_type_class():
                                prefix = &#34;&amp;&#34;

                        if static or is_global:
                                if convClass is not None:
                                        rust += f&#34;      auto ret = {prefix}{convClass.ctype}::{c_name};\n&#34;
                                else:
                                        rust += f&#34;      auto ret = {prefix}{classname}::{c_name};\n&#34;
                        else:
                                if convClass is not None and &#34;proxy&#34; in convClass._features:
                                        rust += f&#34;\n    auto v = _type_tag_cast(h, {convClass.type_tag}, {convClass._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;
                                        rust += f&#34;      auto ret = {prefix}(({convClass._features[&#39;proxy&#39;].wrapped_conv.ctype}*)v)-&gt;{c_name};\n&#34;
                                else:
                                        rust += f&#34;      auto ret = {prefix}(({convClass.ctype}*)h)-&gt;{c_name};\n&#34;

                        src, retval_c = self.__arg_from_cpp_to_c(
                                {&#34;conv&#34;: conv}, &#34;ret&#34;, True)
                        rust += src
                        rust += f&#34;return {retval_c};\n}}\n&#34;

                # SET
                # add set only if the member is not const
                if not (member[&#34;ctype&#34;].const or conv._non_copyable):
                        if is_in_header:
                                rust += &#34;extern &#34;

                        rust += f&#34;void {clean_name_with_title(self._name)}{cleanClassname}Set{name.replace(&#39;:&#39;, &#39;&#39;)}(&#34;
                        if not static and not is_global:
                                rust += f&#34;{clean_name_with_title(self._name)}{cleanClassname} h, &#34;
                        rust += f&#34;{c_arg_bound_name} v)&#34;

                        if is_in_header:
                                rust += &#34;;\n&#34;
                        else:

                                src, inval = self.__arg_from_c_to_cpp({&#34;conv&#34;: conv}, &#34;v&#34;)
                                rust += src

                                if static or is_global:
                                        if convClass is not None:
                                                rust += f&#34;{{ {convClass.ctype}::{c_name} = {inval};\n}}\n&#34;
                                        else:
                                                rust += f&#34;{{ {classname}::{c_name} = {inval};\n}}\n&#34;
                                else:
                                        if convClass is not None and &#34;proxy&#34; in convClass._features:
                                                rust += f&#34;{{\n  auto w = _type_tag_cast(h, {convClass.type_tag}, {convClass._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;
                                                rust += f&#34;      (({convClass._features[&#39;proxy&#39;].wrapped_conv.bound_name}*)w)-&gt;{c_name} = {inval};\n}}\n&#34;
                                        else:
                                                rust += f&#34;{{ (({convClass.ctype}*)h)-&gt;{c_name} = {inval};}}\n&#34;
                return rust

        def __extract_method(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_in_header=False, is_constructor=False, overload_op=None):
                rust = &#34;&#34;

                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name
                wrap_name = bound_name

                cpp_function_name = name
                if &#34;name&#34; in method:
                        cpp_function_name = method[&#34;name&#34;]

                uid = classname + bound_name if classname else bound_name

                protos = self._build_protos(method[&#34;protos&#34;])
                for id_proto, proto in enumerate(protos):
                        retval = &#34;void&#34;

                        if str(proto[&#34;rval&#34;][&#34;storage_ctype&#34;]) != &#34;void&#34;:
                                retval = self.__get_arg_bound_name_to_c(proto[&#34;rval&#34;])

                                # special std::string (convert to const char*)
                                retval = retval.replace(&#34;std::string&#34;, &#34;const char*&#34;)
                                retval = retval.replace(&#34;const const&#34;, &#34;const&#34;)

                        if is_in_header:
                                rust += &#34;extern &#34;
                        rust += f&#34;{retval} {clean_name_with_title(self._name)}{clean_name_with_title(wrap_name)}&#34;

                        # not global, add the Name of the class to be sure to avoid double name function name
                        if not is_global or (not is_constructor and is_global and convClass is not None):
                                rust += f&#34;{clean_name_with_title(convClass.bound_name)}&#34;

                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        rust += &#34;(&#34;

                        has_previous_arg = False
                        # not global, member class, include the &#34;this&#34; pointer first
                        if not is_global or (not is_constructor and is_global and convClass is not None):
                                has_previous_arg = True
                                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(convClass.bound_name)} this_&#34;

                        if len(proto[&#34;args&#34;]):
                                for argin in proto[&#34;args&#34;]:
                                        if has_previous_arg:
                                                rust += &#34; ,&#34;

                                        # get arg name
                                        # special Slice
                                        if isinstance(argin[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                                                arg_bound_name = self.__get_arg_bound_name_to_c(
                                                        {&#34;conv&#34;: argin[&#34;conv&#34;].T_conv})
                                        else:
                                                arg_bound_name = self.__get_arg_bound_name_to_c(argin)

                                        # special std::string (convert to const char*)
                                        arg_bound_name = arg_bound_name.replace(
                                                &#34;std::string&#34;, &#34;const char*&#34;)
                                        arg_bound_name = arg_bound_name.replace(
                                                &#34;const const&#34;, &#34;const&#34;)

                                        # special Slice
                                        if isinstance(argin[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                                                rust += f&#34;size_t {clean_name(argin[&#39;carg&#39;].name)}ToCSize, {arg_bound_name} *{clean_name(argin[&#39;carg&#39;].name)}ToCBuf&#34;
                                        else:
                                                # normal argument
                                                rust += f&#34;{arg_bound_name} {argin[&#39;carg&#39;].name}&#34;
                                        has_previous_arg = True

                        rust += &#34;)&#34;

                        if is_in_header:
                                rust += &#34;;\n&#34;
                        else:
                                rust += &#34;{\n&#34;

                                args = []
                                # if another route is set
                                if &#34;route&#34; in proto[&#34;features&#34;] and convClass is not None and not is_constructor:
                                        args.append(f&#34;({convClass.ctype}*)this_&#34;)

                                # convert arg to cpp
                                if len(proto[&#34;args&#34;]):
                                        # if the function is global but have a convclass,
                                        # special case, which include the class has arg in first arg
                                        if not is_constructor and is_global and convClass is not None:
                                                src, retval_c = self.__arg_from_c_to_cpp(
                                                        {&#34;conv&#34;: convClass}, &#34;this_&#34;)
                                                rust += src
                                                args.append(retval_c)

                                        # other normal args
                                        for argin in proto[&#34;args&#34;]:
                                                # special Slice
                                                if isinstance(argin[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                                                        src, retval_c = self.__arg_from_c_to_cpp(
                                                                argin, clean_name(str(argin[&#34;carg&#34;].name)))
                                                else:
                                                        src, retval_c = self.__arg_from_c_to_cpp(
                                                                argin, str(argin[&#34;carg&#34;].name))
                                                rust += src
                                                args.append(retval_c)

                                if is_constructor:
                                        # constructor, make our own return
                                        retval = &#34;void&#34;
                                        # if another route is set
                                        if &#34;route&#34; in proto[&#34;features&#34;]:
                                                rust += f&#34;      return (void*){proto[&#39;features&#39;][&#39;route&#39;](args)}\n&#34;
                                        elif &#34;proxy&#34; in convClass._features:
                                                rust += &#34;       auto &#34; + convClass._features[&#34;proxy&#34;].wrap(
                                                        f&#34;new {convClass._features[&#39;proxy&#39;].wrapped_conv.bound_name}({&#39;,&#39;.join(args)})&#34;, &#34;v&#34;)
                                                rust += &#34;       return v;\n&#34;
                                        else:
                                                rust += f&#34;      return (void*)(new {convClass.ctype}({&#39;,&#39;.join(args)}));\n&#34;
                                else:
                                        # if there is return value
                                        if retval != &#34;void&#34;:
                                                rust += &#34;       auto ret = &#34;

                                        # special comparison
                                        if overload_op is not None:
                                                rust += f&#34;(*({convClass.ctype}*)this_)&#34;
                                                rust += overload_op
                                                rust += f&#34;({args[0]});\n&#34;
                                        # classic call to function
                                        else:
                                                # transform &amp; to *
                                                if hasattr(proto[&#34;rval&#34;][&#34;storage_ctype&#34;], &#34;ref&#34;) and any(s in proto[&#34;rval&#34;][&#34;storage_ctype&#34;].ref for s in [&#34;&amp;&#34;]):
                                                        rust += &#34;&amp;&#34;

                                                # if another route is set
                                                if &#34;route&#34; in proto[&#34;features&#34;]:
                                                        rust += proto[&#34;features&#34;][&#34;route&#34;](args) + &#34;\n&#34;
                                                else:
                                                        # not global, member class, include the &#34;this&#34; pointer first
                                                        if not is_global:
                                                                rust += f&#34;(*({convClass.ctype}*)this_)&#34;
                                                                if convClass.ctype.is_pointer():
                                                                        rust += &#34;-&gt;&#34;
                                                                else:
                                                                        rust += &#34;.&#34;

                                                        # cpp function name
                                                        rust += cpp_function_name

                                                        # add function&#39;s arguments
                                                        rust += f&#34;({&#39;,&#39;.join(args)});\n&#34;

                                                # return arg out
                                                if &#34;arg_out&#34; in proto[&#34;features&#34;] or &#34;arg_in_out&#34; in proto[&#34;features&#34;]:
                                                        for arg in proto[&#39;args&#39;]:
                                                                if (&#39;arg_out&#39; in proto[&#39;features&#39;] and str(arg[&#39;carg&#39;].name) in proto[&#39;features&#39;][&#39;arg_out&#39;]) or \
                                                                                (&#39;arg_in_out&#39; in proto[&#39;features&#39;] and str(arg[&#39;carg&#39;].name) in proto[&#39;features&#39;][&#39;arg_in_out&#39;]):
                                                                        # FOR NOW ONLY FOR THE STD::STRING
                                                                        if &#34;RustStringConverter&#34; in str(arg[&#34;conv&#34;]) and \
                                                                                        &#34;carg&#34; in arg and hasattr(arg[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in arg[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;]):
                                                                                # it&#39;s a pointer (or there is a bug)
                                                                                retval_cpp = f&#34;(&amp;({str(arg[&#39;carg&#39;].name)}_cpp))&#34;
                                                                                src, retval_cpp = self.__arg_from_cpp_to_c(
                                                                                        arg, retval_cpp, static)
                                                                                rust += src
                                                                                rust += f&#34;      {str(arg[&#39;carg&#39;].name)} = {retval_cpp};\n&#34;

                                if retval != &#34;void&#34;:
                                        src, retval_c = self.__arg_from_cpp_to_c(
                                                proto[&#34;rval&#34;], &#34;ret&#34;, static)
                                        rust += src
                                        rust += f&#34;return {retval_c};\n&#34;
                                rust += &#34;}\n&#34;

                return rust

        def __extract_get_set_member_rust(self, classname, member, static=False, name=None, bound_name=None, is_global=False, implicit_cast=None):
                rust = &#34;&#34;
                conv = self.select_ctype_conv(member[&#34;ctype&#34;])

                if &#34;bound_name&#34; in member:
                        bound_name = str(member[&#34;bound_name&#34;])
                elif bound_name is None:
                        bound_name = str(member[&#34;name&#34;])
                if name is None:
                        name = bound_name

                name = name.replace(&#34;:&#34;, &#34;&#34;)
                name = clean_name_with_title(name)

                arg_bound_name = self.__get_arg_bound_name_to_rust({&#34;conv&#34;: conv})

                def create_get_set(do_static):
                        # GET
                        rust = &#34;&#34;

                        # if it&#39;s a const, just write it once
                        if is_global and member[&#34;ctype&#34;].const:
                                rust += f&#34;// {name} ...\n&#34;
                                if self.__get_is_type_class_or_pointer_with_class(conv):
                                        rust += f&#34;static {clean_name(name)} : {arg_bound_name.replace(&#39;*&#39;,&#39;&#39;)} = {arg_bound_name.replace(&#39;*&#39;, &#39;&#39;)}{clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{name}()\n&#34;
                                elif implicit_cast is not None:
                                        rust += f&#34;static {clean_name(name)} : *{implicit_cast} = {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{name}() as {implicit_cast}\n&#34;
                                else:
                                        rust += f&#34;static {clean_name(name)} : {arg_bound_name} = {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{name}() as {arg_bound_name}\n&#34;
                        else:
                                rust += &#34;// &#34;
                                if do_static:
                                        rust += f&#34;{clean_name_with_title(classname)}&#34;
                                rust += f&#34;{clean_name_with_title(self._name)}Get{name} ...\n&#34;
                                rust += f&#34;pub fn {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{clean_name_with_title(member[&#39;name&#39;].naked_name())}({clean_name_with_title(classname).lower()}: *mut {clean_name_with_title(classname)}) -&gt; {self.select_ctype_conv(member[&#39;ctype&#39;]).rust_type};\n&#34;

                        # SET
                        # add set only if the member is not const
                        if not member[&#34;ctype&#34;].const:
                                rust += f&#34;// &#34;
                                if do_static:
                                        rust += f&#34;{clean_name_with_title(classname)}&#34;
                                rust += f&#34;{clean_name_with_title(self._name)}Set{name} ...\n&#34; \
                                        f&#34;pub fn {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Set{clean_name_with_title(member[&#39;name&#39;].naked_name())}({clean_name_with_title(classname).lower()}: *mut {clean_name_with_title(classname)},value : {self.select_ctype_conv(member[&#39;ctype&#39;]).rust_type});\n&#34;
                        return rust

                # create twice, with and without static, to use it with the class and standalone
                if not is_global:
                        rust += create_get_set(False)
                if static or is_global:
                        rust += create_get_set(True)

                return rust

        def __extract_rust_signature(self, classname, proto, is_global, name_rust):
                rust = &#34;pub fn &#34;
                if not is_global:
                        rust += f&#34;(pointer *{clean_name_with_title(classname)}) &#34;
                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(name_rust)}&#34;

                # add bounding_name to the overload function
                if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                        rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                # if automatic suffix generated
                elif &#34;suggested_suffix&#34; in proto:
                        rust += proto[&#34;suggested_suffix&#34;]

                # add input(s) declaration
                rust += &#34;(&#34;
                if len(proto[&#34;args&#34;]):
                        has_previous_arg = False
                        for argin in proto[&#34;args&#34;]:
                                if has_previous_arg:
                                        rust += &#34; ,&#34;

                                # check if the input is in feature constant group, overrite the type
                                if &#34;features&#34; in proto and &#34;constants_group&#34; in proto[&#34;features&#34;] and str(argin[&#34;carg&#34;].name) in proto[&#34;features&#34;][&#34;constants_group&#34;]:
                                        rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {proto[&#39;features&#39;][&#39;constants_group&#39;][str(argin[&#39;carg&#39;].name)]}&#34;
                                else:
                                        rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {self.__get_arg_bound_name_to_rust(argin)}&#34;
                                has_previous_arg = True

                rust += &#34;)&#34;

                # add output(s) declaration
                # has_previous_ret_arg = False
                if proto[&#34;rval&#34;][&#34;conv&#34;]:
                        rust += &#34; -&gt; &#34;
                        rust += self.__get_arg_bound_name_to_rust(proto[&#34;rval&#34;])
                rust += &#34;;&#34;
                return rust

        def __extract_method_signature_rust(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False):
                rust = &#34;&#34;

                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name

                if bound_name == &#34;OpenVRStateToViewState&#34;:
                        bound_name = bound_name

                name_rust = clean_name_with_title(name)
                if is_constructor:
                        name_rust = &#34;new_&#34; + name_rust

                uid = classname + bound_name if classname else bound_name

                protos = self._build_protos(method[&#34;protos&#34;])
                for id_proto, proto in enumerate(protos):
                        retval = &#34;&#34;

                        if proto[&#34;rval&#34;][&#34;conv&#34;]:
                                retval = proto[&#34;rval&#34;][&#34;conv&#34;].bound_name

                        rust += &#34;// &#34; + clean_name_with_title(name_rust)
                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        # get doc
                        if classname == &#34;&#34; or is_constructor:
                                doc = self.get_symbol_doc(bound_name)
                        else:
                                doc = self.get_symbol_doc(classname + &#34;_&#34; + bound_name)

                        if doc == &#34;&#34;:
                                rust += &#34; ...\n&#34;
                        else:
                                rust += &#34; &#34; + re.sub(r&#39;(\[)(.*?)(\])&#39;, r&#39;\1harfang.\2\3&#39;, doc) + &#34;\n&#34;
                        rust += self.__extract_rust_signature(
                                classname, proto, is_global, name_rust)

                        rust += &#34;\n\n&#34;

                return rust

        def __extract_method_rust(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False):
                rust = &#34;&#34;

                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name

                if bound_name == &#34;OpenVRStateToViewState&#34;:
                        bound_name = bound_name

                name_rust = clean_name_with_title(name)
                if is_constructor:
                        name_rust = &#34;Constructor&#34; + name_rust

                uid = classname + bound_name if classname else bound_name

                protos = self._build_protos(method[&#34;protos&#34;])
                for id_proto, proto in enumerate(protos):
                        retval = &#34;&#34;

                        if proto[&#34;rval&#34;][&#34;conv&#34;]:
                                retval = proto[&#34;rval&#34;][&#34;conv&#34;].bound_name

                        rust += &#34;//&#34; + clean_name_with_title(name_rust)
                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        # get doc
                        if classname == &#34;&#34; or is_constructor:
                                doc = self.get_symbol_doc(bound_name)
                        else:
                                doc = self.get_symbol_doc(classname + &#34;_&#34; + bound_name)

                        if doc == &#34;&#34;:
                                rust += &#34; ...\n&#34;
                        else:
                                rust += &#34; &#34; + re.sub(r&#39;(\[)(.*?)(\])&#39;, r&#39;\1harfang.\2\3&#39;, doc) + &#34;\n&#34;

                        rust += &#34;pub fn &#34;
                        if not is_global:
                                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(name_rust)}{clean_name_with_title(classname)}&#34;
                        else:
                                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(name_rust)}&#34;

                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        # add input(s) declaration
                        if  is_constructor:
                                rust += &#34;(&#34;
                                has_previous_arg = False
                        else:
                                rust += &#34;(_this : *mut &#34; + clean_name_with_title(classname) + &#34; &#34;
                                has_previous_arg = True
                                
                        if len(proto[&#34;args&#34;]):
                                for argin in proto[&#34;args&#34;]:
                                        if has_previous_arg:
                                                rust += &#34; ,&#34;

                                        # check if the input is in feature constant group, overrite the type
                                        if &#34;features&#34; in proto and &#34;constants_group&#34; in proto[&#34;features&#34;] and str(argin[&#34;carg&#34;].name) in proto[&#34;features&#34;][&#34;constants_group&#34;]:
                                                rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {proto[&#39;features&#39;][&#39;constants_group&#39;][str(argin[&#39;carg&#39;].name)]}&#34;
                                        else:
                                                rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {self.__get_arg_bound_name_to_rust(argin)}&#34;
                                        has_previous_arg = True

                        rust += &#34;)&#34;

                        # add output(s) declaration
                        if proto[&#34;rval&#34;][&#34;conv&#34;]:
                                rust += &#34; -&gt;&#34;
                                rust += self.__get_arg_bound_name_to_rust(proto[&#34;rval&#34;])
                        
                        rust += &#34;;\n&#34;

                return rust

        # VERY SPECIAL
        # check in every methods,
        # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
        def _check_arg_out_add_constructor_if_needed(self, method):
                def check_if_val_have_constructor(val):
                        # if it&#39;s a arg out and a class
                        if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                # find the constructor without arg
                                type_conv = None
                                for arg_conv in self._bound_types:
                                        if str(arg_conv.ctype) == str(val[&#34;conv&#34;].ctype):
                                                type_conv = arg_conv
                                                if hasattr(arg_conv, &#34;constructor&#34;) and arg_conv.constructor is not None:
                                                        proto_args = self._build_protos(
                                                                arg_conv.constructor[&#34;protos&#34;])
                                                        break
                                else:
                                        proto_args = None

                                # if no proto constructor with no args, add one
                                if proto_args is None and type_conv is not None:
                                        self.bind_constructor(type_conv, [])

                # check all protos
                protos = self._build_protos(method[&#34;protos&#34;])
                for proto in protos:
                        # convert arg in to c
                        if len(proto[&#34;args&#34;]):
                                for arg in proto[&#34;args&#34;]:
                                        # if arg out only, declare this value
                                        if &#34;arg_out&#34; in proto[&#34;features&#34;] and str(arg[&#34;carg&#34;].name) in proto[&#34;features&#34;][&#34;arg_out&#34;]:
                                                if arg[&#34;carg&#34;].ctype.is_pointer() or (hasattr(arg[&#34;carg&#34;].ctype, &#34;ref&#34;) and arg[&#34;carg&#34;].ctype.ref == &#34;&amp;&#34;):
                                                        check_if_val_have_constructor(arg)

        # returns the header code to the binder
        def _write_header(self):
                # .h
                rust_h = &#39;#pragma once\n&#39; \
                        &#39;#ifdef __cplusplus\n&#39;\
                        &#39;extern &#34;C&#34; {\n&#39;\
                        &#39;#endif\n&#39;

                rust_h += &#39;#include &lt;stdint.h&gt;\n&#39; \
                        &#39;#include &lt;stdbool.h&gt;\n&#39; \
                        &#39;#include &lt;stddef.h&gt;\n&#39; \
                        &#39;#include &lt;memory.h&gt;\n&#39; \
                        &#39;#include &lt;string.h&gt;\n&#39; \
                        &#39;#include &lt;stdlib.h&gt;\n&#39; \
                        &#39;#include &#34;fabgen.h&#34;\n\n&#39;

                # enum
                for bound_name, enum in self._enums.items():
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                arg_bound_name = str(enum_conv.base_type)
                        else:
                                arg_bound_name = &#34;int&#34;

                        rust_h += f&#34;extern {arg_bound_name} Get{bound_name}(const int id);\n&#34;

                # write all typedef first
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        cleanBoundName = clean_name_with_title(conv.bound_name)
                        if self.__get_is_type_class_or_pointer_with_class(conv):
                                rust_h += f&#34;typedef void* {clean_name_with_title(self._name)}{cleanBoundName};\n&#34;

                        if &#34;RustStdFunctionConverter&#34; in str(conv):
                                func_name = conv.base_type.replace(&#34;std::function&lt;&#34;, &#34;&#34;).replace(
                                        &#34;&amp;&#34;, &#34;*&#34;)[:-1]  # [:-1] to remove the &gt; of std::function
                                first_parenthesis = func_name.find(&#34;(&#34;)
                                # get all args boundname in c
                                args = func_name[first_parenthesis+1:-1].split(&#34;,&#34;)
                                args_boundname = []
                                for arg in args:
                                        if len(arg):
                                                ctype = parse(arg, gen._CType)
                                                conv = self.select_ctype_conv(ctype)
                                                args_boundname.append(self.__get_arg_bound_name_to_c(
                                                        {&#34;conv&#34;: conv, &#34;carg&#34;: type(&#39;carg&#39;, (object,), {&#39;ctype&#39;: ctype})()}))

                                rust_h += f&#34;typedef {func_name[:first_parenthesis]} (*{clean_name_with_title(self._name)}{cleanBoundName})({&#39;,&#39;.join(args_boundname)});\n&#34;

                # write the rest of the classes
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        cleanBoundName = clean_name_with_title(conv.bound_name)

                        if &#34;sequence&#34; in conv._features:
                                rust_h += self.__extract_sequence(conv, is_in_header=True)

                        # static members
                        rust_h += self.extract_conv_and_bases(conv.static_members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member, static=True, is_in_header=True),
                                                                                                  [base_class.static_members for base_class in conv._bases])

                        # members
                        rust_h += self.extract_conv_and_bases(conv.members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member, is_in_header=True),
                                                                                                  [base_class.members for base_class in conv._bases])

                        # constructors
                        if conv.constructor:
                                rust_h += self.__extract_method(cleanBoundName, conv, conv.constructor,
                                                                                                bound_name=f&#34;constructor_{conv.bound_name}&#34;, is_in_header=True, is_global=True, is_constructor=True)

                        # destructor for all type class
                        if self.__get_is_type_class_or_pointer_with_class(conv):
                                rust_h += f&#34;extern void {clean_name_with_title(self._name)}{cleanBoundName}Free({clean_name_with_title(self._name)}{cleanBoundName});\n&#34;

                        # arithmetic operators
                        rust_h += self.extract_conv_and_bases(conv.arithmetic_ops,
                                                                                                  lambda arithmetic: self.__extract_method(
                                                                                                          conv.bound_name, conv, arithmetic, is_in_header=True, name=arithmetic[&#39;op&#39;], bound_name=gen.get_clean_symbol_name(arithmetic[&#39;op&#39;])),
                                                                                                  [base_class.arithmetic_ops for base_class in conv._bases])

                        # comparison_ops
                        rust_h += self.extract_conv_and_bases(conv.comparison_ops,
                                                                                                  lambda comparison: self.__extract_method(
                                                                                                          conv.bound_name, conv, comparison, is_in_header=True, name=comparison[&#39;op&#39;], bound_name=gen.get_clean_symbol_name(comparison[&#39;op&#39;])),
                                                                                                  [base_class.comparison_ops for base_class in conv._bases])

                        # static methods
                        rust_h += self.extract_conv_and_bases(conv.static_methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method, static=True, is_in_header=True),
                                                                                                  [base_class.static_methods for base_class in conv._bases])
                        # methods
                        rust_h += self.extract_conv_and_bases(conv.methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method, is_in_header=True),
                                                                                                  [base_class.methods for base_class in conv._bases])

                # functions
                for func in self._bound_functions:
                        rust_h += self.__extract_method(&#34;&#34;, None, func,
                                                                                        name=func[&#34;name&#34;], is_global=True, is_in_header=True)

                # global variables
                for var in self._bound_variables:
                        rust_h += self.__extract_get_set_member(
                                &#34;&#34;, None, var, is_global=True, is_in_header=True)

                rust_h += &#39;#ifdef __cplusplus\n&#39; \
                        &#39;}\n&#39; \
                        &#39;#endif\n&#39;
                return rust_h

        # returns the c code for the wrapper
        def _write_C_code(self):
                rust_c = &#39;// rust wrapper c\n&#39; \
                        &#39;#include \&#34;wrapper.h\&#34;\n&#39; \
                        &#39;#include &lt;memory&gt;\n&#39;

                if len(self._FABGen__system_includes) &gt; 0:
                        rust_c += &#34;&#34;.join([&#39;#include &#34;%s&#34;\n\n&#39; %
                                                          path for path in self._FABGen__system_includes])
                if len(self._FABGen__user_includes) &gt; 0:
                        rust_c += &#34;&#34;.join([&#39;#include &#34;%s&#34;\n\n&#39; %
                                                          path for path in self._FABGen__user_includes])

                rust_c += self._source

                # enum
                for bound_name, enum in self._enums.items():
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                arg_bound_name = str(enum_conv.base_type)
                        else:
                                arg_bound_name = &#34;int&#34;

                        enum_vars = []
                        for name, value in enum.items():
                                enum_vars.append(f&#34;({arg_bound_name}){value}&#34;)
                        rust_c += f&#34;static const {arg_bound_name} {clean_name_with_title(self._name)}{bound_name} [] = {{ {&#39;, &#39;.join(enum_vars)} }};\n&#34;
                        rust_c += f&#34;{arg_bound_name} Get{bound_name}(const int id) {{ return {clean_name_with_title(self._name)}{bound_name}[id];}}\n&#34;

                #  classes
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        cleanBoundName = clean_name_with_title(conv.bound_name)
                        if conv.is_type_class():
                                rust_c += f&#34;// bind {clean_name_with_title(self._name)}{cleanBoundName} methods\n&#34;

                        if &#34;sequence&#34; in conv._features:
                                rust_c += self.__extract_sequence(conv)

                        # static members
                        rust_c += self.extract_conv_and_bases(conv.static_members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member, static=True),
                                                                                                  [base_class.static_members for base_class in conv._bases])

                        # members
                        rust_c += self.extract_conv_and_bases(conv.members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member),
                                                                                                  [base_class.members for base_class in conv._bases])

                        # constructors
                        if conv.constructor:
                                rust_c += self.__extract_method(conv.bound_name, conv, conv.constructor,
                                                                                                bound_name=f&#34;constructor_{conv.bound_name}&#34;, is_global=True, is_constructor=True)

                        # destructor for all type class
                        if self.__get_is_type_class_or_pointer_with_class(conv):
                                # delete
                                rust_c += f&#34;void {clean_name_with_title(self._name)}{cleanBoundName}Free({clean_name_with_title(self._name)}{cleanBoundName} h){{&#34; \
                                        f&#34;delete ({conv.ctype}*)h;&#34; \
                                        f&#34;}}\n&#34;

                        # arithmetic operators
                        rust_c += self.extract_conv_and_bases(conv.arithmetic_ops,
                                                                                                  lambda arithmetic: self.__extract_method(conv.bound_name, conv, arithmetic, name=arithmetic[&#39;op&#39;], bound_name=gen.get_clean_symbol_name(
                                                                                                          arithmetic[&#39;op&#39;]), overload_op=arithmetic[&#34;op&#34;]),
                                                                                                  [base_class.arithmetic_ops for base_class in conv._bases])

                        # comparison_ops
                        rust_c += self.extract_conv_and_bases(conv.comparison_ops,
                                                                                                  lambda comparison: self.__extract_method(conv.bound_name, conv, comparison, name=comparison[&#34;op&#34;], bound_name=gen.get_clean_symbol_name(
                                                                                                          comparison[&#34;op&#34;]), overload_op=comparison[&#34;op&#34;]),
                                                                                                  [base_class.comparison_ops for base_class in conv._bases])

                        # static methods
                        rust_c += self.extract_conv_and_bases(conv.static_methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method, static=True),
                                                                                                  [base_class.static_methods for base_class in conv._bases])
                        # methods
                        rust_c += self.extract_conv_and_bases(conv.methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method),
                                                                                                  [base_class.methods for base_class in conv._bases])

                # functions
                for func in self._bound_functions:
                        rust_c += self.__extract_method(&#34;&#34;, None,
                                                                                        func, name=func[&#34;name&#34;], is_global=True)

                # global variables
                for var in self._bound_variables:
                        rust_c += self.__extract_get_set_member(
                                &#34;&#34;, None, var, is_global=True, static=True)
                return rust_c

        def _write_rust_enums(self):
                rust_bind = f&#34;// {self._name} enums ...\n&#34;
                for bound_name, enum in self._enums.items():
                        rust_bind += f&#34;// {bound_name} ...\n&#34;
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;rust_type&#34;) and enum_conv.rust_type is not None:
                                arg_bound_name = enum_conv.rust_type
                        else:
                                arg_bound_name = &#34;i32&#34;
                        rust_bind += f&#34;type {bound_name} = {arg_bound_name};\n&#34;
                return rust_bind

        def _write_rust_extern(self):
                rust_bind = f&#34;#[link(name = \&#34;{self._name}\&#34;)]\n&#34;
                rust_bind += &#34;extern \&#34;C\&#34; { \n\n&#34;

                for type in self._bound_types:
                        if type.nobind:
                                continue
                        if type.is_type_class():
                                rust_bind += f&#34;// bind {clean_name_with_title(self._name)}{clean_name_with_title(type.bound_name)} methods\n&#34;

                        # constructors
                        if type.constructor:
                                rust_bind += self.__extract_method_rust(type.bound_name, type, type.constructor,
                                                                                                                bound_name=f&#34;{type.bound_name}&#34;, is_global=True, is_constructor=True)

                        # static members
                        rust_bind += self.extract_conv_and_bases(type.static_members,
                                                                                                         lambda member: self.__extract_get_set_member_rust(
                                                                                                                 type.bound_name, member, static=True),
                                                                                                         [base_class.static_members for base_class in type._bases])

                        # members
                        rust_bind += self.extract_conv_and_bases(type.members,
                                                                                                         lambda member: self.__extract_get_set_member_rust(
                                                                                                                 type.bound_name, member, static=False),
                                                                                                         [base_class.members for base_class in type._bases])

                        # arithmetic operators
                        rust_bind += self.extract_conv_and_bases(type.arithmetic_ops,
                                                                                                         lambda arithmetic: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, arithmetic, bound_name=gen.get_clean_symbol_name(arithmetic[&#39;op&#39;])),
                                                                                                         [base_class.arithmetic_ops for base_class in type._bases])
                        # comparison_ops
                        rust_bind += self.extract_conv_and_bases(type.comparison_ops,
                                                                                                         lambda comparison: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, comparison, bound_name=gen.get_clean_symbol_name(comparison[&#39;op&#39;])),
                                                                                                         [base_class.comparison_ops for base_class in type._bases])

                        # static methods
                        rust_bind += self.extract_conv_and_bases(type.static_methods,
                                                                                                         lambda method: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, method, static=True),
                                                                                                         [base_class.static_methods for base_class in type._bases])
                        # methods
                        rust_bind += self.extract_conv_and_bases(type.methods,
                                                                                                         lambda method: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, method),
                                                                                                         [base_class.methods for base_class in type._bases])

                # functions
                for func in self._bound_functions:
                        rust_bind += self.__extract_method_signature_rust(
                                &#34;&#34;, None, func, is_global=True)

                # global variables
                # sort by group if needed
                bound_variables_groups = {}
                for var in self._bound_variables:
                        if &#34;group&#34; in var and var[&#34;group&#34;] is not None:
                                group_name = clean_name_with_title(var[&#34;group&#34;])
                                if group_name not in bound_variables_groups:
                                        bound_variables_groups[group_name] = []
                                bound_variables_groups[group_name].append(var)

                # add bound variables groups
                for group_name, var_group in bound_variables_groups.items():
                        rust_bind += f&#34;// {group_name} ...\n&#34;
                        var_conv = self.select_ctype_conv(var_group[0][&#34;ctype&#34;])
                        if var_conv is not None and hasattr(var_conv, &#34;rust_type&#34;) and var_conv.rust_type is not None:
                                rust_bind += f&#34;type {group_name} {var_conv.rust_type}\n&#34;
                        else:
                                rust_bind += f&#34;type {group_name} int\n&#34;

                        for id, var in enumerate(var_group):
                                rust_bind += self.__extract_get_set_member_rust(
                                        &#34;&#34;, var, is_global=True, implicit_cast=group_name)

                # add bound variables without group
                for var in self._bound_variables:
                        if &#34;group&#34; not in var or var[&#34;group&#34;] is None:
                                rust_bind += self.__extract_get_set_member_rust(
                                        &#34;&#34;, var, is_global=True)

                for bound_name, enum in self._enums.items():
                        rust_bind += f&#34;// {bound_name} ...\n&#34;
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;rust_type&#34;) and enum_conv.rust_type is not None:
                                arg_bound_name = enum_conv.rust_type
                        else:
                                arg_bound_name = &#34;i32&#34;
                                #enums are the only methods that aren&#39;t using the _name prefix, it doesn&#39;t work if you add them, i have no idea why
                        rust_bind += f&#34;pub fn Get{bound_name}(id : {arg_bound_name}) -&gt; {bound_name};\n&#34;
                        

                rust_bind += &#34;}\n&#34;
                return rust_bind

        def _write_rust_binder_header(self):
                rust_bind = f&#39;// This Crate was automatically generated by FABGen\n&#39; \
                        &#39;// Do not modify this file manually\n\n&#39;
                rust_bind += self.rust_directives
                rust_bind += &#39;use std::ffi::c_void;\n&#39;
                with open(&#34;lib/rust/WrapperConverter.rs_&#34;, &#34;r&#34;) as file:
                        lines = file.readlines()
                        rust_bind += &#34;&#34;.join(lines)
                        rust_bind += &#34;\n&#34;

                return rust_bind

        # helper to add from itself and from parent class
        def extract_conv_and_bases(self, convs_to_extract, extract_func, bases_convs_to_extract):
                rust = &#34;&#34;
                saved_names = []
                for conv_to_extract in convs_to_extract:
                        if &#34;name&#34; in conv_to_extract:
                                saved_names.append(conv_to_extract[&#34;name&#34;])
                        elif &#34;op&#34; in conv_to_extract:
                                saved_names.append(conv_to_extract[&#34;op&#34;])
                        rust += extract_func(conv_to_extract)
                # add static member get set for base class
                for base_convs_to_extract in bases_convs_to_extract:
                        for conv_to_extract in base_convs_to_extract:
                                # add only if it&#39;s not already in the current class
                                n = &#34;&#34;
                                if &#34;name&#34; in conv_to_extract:
                                        n = conv_to_extract[&#34;name&#34;]
                                elif &#34;op&#34; in conv_to_extract:
                                        n = conv_to_extract[&#34;op&#34;]
                                if n not in saved_names:
                                        saved_names.append(n)
                                        rust += extract_func(conv_to_extract)
                return rust

        def bind_method_translate(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False):
                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name

                name_rust = name
                if is_constructor:
                        name_rust = &#34;new_&#34; + name_rust

                protos = self._build_protos(method[&#34;protos&#34;])
                return_protos_name = []
                for id_proto, proto in enumerate(protos):
                        method_name_rust = f&#34;{clean_name_with_title(name_rust)}&#34;

                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                method_name_rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                method_name_rust += proto[&#34;suggested_suffix&#34;]

                        return_protos_name.append(method_name_rust)
                return name, return_protos_name

        def _write_json_translate(self):
                rust_translate_file = {}

                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        rust_translate_file[conv.bound_name] = {
                                &#34;name&#34;: clean_name_with_title(conv.bound_name)}

                        # members
                        members = {}
                        for member in conv.static_members + conv.members:
                                bound_name = None
                                if &#34;bound_name&#34; in member:
                                        bound_name = str(member[&#34;bound_name&#34;])
                                elif bound_name is None:
                                        bound_name = str(member[&#34;name&#34;])

                                name = bound_name.replace(&#34;:&#34;, &#34;&#34;)
                                name = clean_name_with_title(name)
                                members[bound_name] = [f&#34;Get{name}&#34;, f&#34;Set{name}&#34;]

                        if len(members):
                                rust_translate_file[conv.bound_name][&#34;members&#34;] = members

                        # functions
                        functions = {}

                        # constructors
                        if conv.constructor:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, conv.constructor, bound_name=f&#34;{conv.bound_name}&#34;, is_global=True, is_constructor=True)
                                functions[name] = protos_name

                        for method in conv.static_methods + conv.methods:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, method)
                                functions[name] = protos_name

                        for arithmetic in conv.arithmetic_ops:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, arithmetic, bound_name=gen.get_clean_symbol_name(arithmetic[&#39;op&#39;]))
                                functions[name] = protos_name
                        for comparison in conv.comparison_ops:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, comparison, bound_name=gen.get_clean_symbol_name(comparison[&#39;op&#39;]))
                                functions[name] = protos_name

                        if len(functions):
                                rust_translate_file[conv.bound_name][&#34;functions&#34;] = functions

                # enum
                for bound_name, enum in self._enums.items():
                        rust_translate_file[bound_name] = bound_name
                # rust_bind += &#34;var (\n&#34;
                        for id, name in enumerate(enum.keys()):
                                rust_translate_file[name] = clean_name(name)

                # functions
                for func in self._bound_functions:
                        name, protos_name = self.bind_method_translate(
                                &#34;&#34;, None, func, is_global=True)
                        rust_translate_file[name] = protos_name

                # global variables
                for member in self._bound_variables:
                        bound_name = None
                        if &#34;bound_name&#34; in member:
                                bound_name = str(member[&#34;bound_name&#34;])
                        elif bound_name is None:
                                bound_name = str(member[&#34;name&#34;])

                        name = bound_name.replace(&#34;:&#34;, &#34;&#34;)
                        name = clean_name_with_title(name)
                        rust_translate_file[bound_name] = [f&#34;Get{name}&#34;, f&#34;Set{name}&#34;]

        def _write_rust_struct(self):
                rust_struct = &#34;&#34;

                for conv in self._bound_types:
                        if conv.nobind:
                                continue
                        if conv.is_type_class():
                                rust_struct += f&#34;pub type {clean_name_with_title(conv.bound_name)} = c_void;\n\n&#34;
                return rust_struct

        def finalize(self):

                # add class global
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        if conv.is_type_class():
                                # add equal of deep copy
                                if conv._supports_deep_compare:
                                        rust = &#34;&#34;
                                        if &#34;proxy&#34; in conv._features:
                                                rust += f&#34;bool _{conv.bound_name}_Equal({conv.ctype} *a, {conv.ctype} *b){{\n&#34;
                                                rust += f&#34;      auto cast_a = _type_tag_cast(a, {conv.type_tag}, {conv._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;
                                                rust += f&#34;      auto cast_b = _type_tag_cast(b, {conv.type_tag}, {conv._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;

                                                wrapped_conv = conv._features[&#34;proxy&#34;].wrapped_conv
                                                if wrapped_conv.is_type_class():
                                                        rust += f&#34;      return ({wrapped_conv.bound_name}*)cast_a == ({wrapped_conv.bound_name}*)cast_b;\n&#34;
                                                else:
                                                        # check the convert from the base (in case of ptr)
                                                        if wrapped_conv.ctype.is_pointer() or (hasattr(wrapped_conv.ctype, &#34;ref&#34;) and any(s in wrapped_conv.ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])):
                                                                base_conv = self._get_conv(
                                                                        str(wrapped_conv.ctype.scoped_typename))
                                                                if base_conv is None:
                                                                        type_bound_name = str(
                                                                                wrapped_conv.bound_name)
                                                                else:
                                                                        type_bound_name = str(base_conv.ctype)
                                                        else:
                                                                type_bound_name = str(wrapped_conv.ctype)
                                                        rust += f&#34;      return ({type_bound_name}*)cast_a == ({type_bound_name}*)cast_b;\n&#34;
                                        else:
                                                rust += f&#34;bool _{conv.bound_name}_Equal({conv.bound_name} *a, {conv.bound_name} *b){{\n&#34;
                                                rust += f&#34;      return *a == *b;\n&#34;
                                        rust += &#34;}\n&#34;

                                        self.insert_code(rust)
                                        if &#34;proxy&#34; in conv._features:
                                                self.bind_method(conv, &#34;Equal&#34;, &#34;bool&#34;, [
                                                                                 f&#34;{conv.ctype} *b&#34;], {&#34;route&#34;: route_lambda(f&#34;_{conv.bound_name}_Equal&#34;)})
                                        else:
                                                self.bind_method(conv, &#34;Equal&#34;, &#34;bool&#34;, [
                                                                                 f&#34;{conv.bound_name} *b&#34;], {&#34;route&#34;: route_lambda(f&#34;_{conv.bound_name}_Equal&#34;)})

                                # VERY SPECIAL
                                # check in every methods,
                                # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
                                for method in conv.static_methods+conv.methods:
                                        self._check_arg_out_add_constructor_if_needed(method)

                        # add down cast
                        for base in conv._bases:
                                self.add_cast(base, conv, lambda in_var, out_var: &#34;%s = (%s *)((%s *)%s);\n&#34; %
                                                          (out_var, conv.ctype, base.ctype, in_var))

                # VERY SPECIAL
                # check in every methods,
                # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
                for func in self._FABGen__function_declarations.values():
                        self._check_arg_out_add_constructor_if_needed(func)

                super().finalize()

                self.output_binding_api()

                self.rust_h = self._write_header()
                self.rust_c = self._write_C_code()
                self.rust_bind = self._write_rust_binder_header()
                self.rust_bind += self._write_rust_struct()
                self.rust_bind += self._write_rust_enums()
                self.rust_bind += self._write_rust_extern()
                self.rust_translate_file = json.dumps(
                        self._write_json_translate(), indent=4, sort_keys=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="rust.clean_name"><code class="name flex">
<span>def <span class="ident">clean_name</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_name(name):
        new_name = str(name).strip().replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;)
        if new_name in [&#34;break&#34;, &#34;default&#34;, &#34;func&#34;, &#34;interface&#34;, &#34;select&#34;, &#34;case&#34;, &#34;defer&#34;, &#34;rust&#34;, &#34;map&#34;, &#34;struct&#34;, &#34;chan&#34;, &#34;else&#34;, &#34;rustto&#34;, &#34;package&#34;, &#34;switch&#34;, &#34;const&#34;, &#34;fallthrough&#34;, &#34;if&#34;, &#34;range&#34;, &#34;type&#34;, &#34;continue&#34;, &#34;for&#34;, &#34;import&#34;, &#34;return&#34;, &#34;var&#34;]:
                return new_name + &#34;Rust&#34;
        return new_name</code></pre>
</details>
</dd>
<dt id="rust.clean_name_with_title"><code class="name flex">
<span>def <span class="ident">clean_name_with_title</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_name_with_title(name):
        new_name = &#34;&#34;
        if &#34;_&#34; in name:
                # redo a special string.title()
                next_is_forced_uppercase = True
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;]:
                                new_name += c
                        elif c in [&#34;_&#34;, &#34;-&#34;]:
                                next_is_forced_uppercase = True
                        else:
                                if next_is_forced_uppercase:
                                        next_is_forced_uppercase = False
                                        new_name += c.capitalize()
                                else:
                                        new_name += c
        else:
                # make sur the first letter is capitalize
                first_letter_checked = False
                for c in name:
                        if c in [&#34;*&#34;, &#34;&amp;&#34;] or first_letter_checked:
                                new_name += c
                        elif not first_letter_checked:
                                first_letter_checked = True
                                new_name += c.capitalize()
        return new_name.strip().replace(&#34;_&#34;, &#34;&#34;).replace(&#34;:&#34;, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="rust.route_lambda"><code class="name flex">
<span>def <span class="ident">route_lambda</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def route_lambda(name):
        return lambda args: &#34;%s(%s);&#34; % (name, &#34;, &#34;.join(args))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rust.DummyTypeConverter"><code class="flex name class">
<span>class <span class="ident">DummyTypeConverter</span></span>
<span>(</span><span>type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DummyTypeConverter(gen.TypeConverter):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)

        def get_type_api(self, module_name):
                return &#34;&#34;

        def to_c_call(self, in_var, out_var_p, is_pointer):
                return &#34;&#34;

        def from_c_call(self, out_var, expr, ownership):
                return &#34;&#34;

        def check_call(self, in_var):
                return &#34;&#34;

        def get_type_glue(self, gen, module_name):
                return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gen.TypeConverter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rust.DummyTypeConverter.check_call"><code class="name flex">
<span>def <span class="ident">check_call</span></span>(<span>self, in_var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_call(self, in_var):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.DummyTypeConverter.from_c_call"><code class="name flex">
<span>def <span class="ident">from_c_call</span></span>(<span>self, out_var, expr, ownership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_c_call(self, out_var, expr, ownership):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.DummyTypeConverter.get_type_api"><code class="name flex">
<span>def <span class="ident">get_type_api</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_api(self, module_name):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.DummyTypeConverter.get_type_glue"><code class="name flex">
<span>def <span class="ident">get_type_glue</span></span>(<span>self, gen, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_glue(self, gen, module_name):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.DummyTypeConverter.to_c_call"><code class="name flex">
<span>def <span class="ident">to_c_call</span></span>(<span>self, in_var, out_var_p, is_pointer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_c_call(self, in_var, out_var_p, is_pointer):
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rust.RustClassTypeDefaultConverter"><code class="flex name class">
<span>class <span class="ident">RustClassTypeDefaultConverter</span></span>
<span>(</span><span>type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RustClassTypeDefaultConverter(RustTypeConverterCommon):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)

        def is_type_class(self):
                return True

        def get_type_api(self, module_name):
                return &#34;&#34;

        def to_c_call(self, in_var, out_var_p, is_pointer):
                out = f&#34;{out_var_p.replace(&#39;&amp;&#39;, &#39;_&#39;)} := {in_var}.h\n&#34;
                return out

        def from_c_call(self, out_var, expr, ownership):
                return &#34;&#34;

        def check_call(self, in_var):
                return &#34;&#34;

        def get_type_glue(self, gen, module_name):
                return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rust.RustTypeConverterCommon" href="#rust.RustTypeConverterCommon">RustTypeConverterCommon</a></li>
<li>gen.TypeConverter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rust.RustClassTypeDefaultConverter.check_call"><code class="name flex">
<span>def <span class="ident">check_call</span></span>(<span>self, in_var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_call(self, in_var):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustClassTypeDefaultConverter.from_c_call"><code class="name flex">
<span>def <span class="ident">from_c_call</span></span>(<span>self, out_var, expr, ownership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_c_call(self, out_var, expr, ownership):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustClassTypeDefaultConverter.get_type_api"><code class="name flex">
<span>def <span class="ident">get_type_api</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_api(self, module_name):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustClassTypeDefaultConverter.get_type_glue"><code class="name flex">
<span>def <span class="ident">get_type_glue</span></span>(<span>self, gen, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_glue(self, gen, module_name):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustClassTypeDefaultConverter.is_type_class"><code class="name flex">
<span>def <span class="ident">is_type_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_type_class(self):
        return True</code></pre>
</details>
</dd>
<dt id="rust.RustClassTypeDefaultConverter.to_c_call"><code class="name flex">
<span>def <span class="ident">to_c_call</span></span>(<span>self, in_var, out_var_p, is_pointer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_c_call(self, in_var, out_var_p, is_pointer):
        out = f&#34;{out_var_p.replace(&#39;&amp;&#39;, &#39;_&#39;)} := {in_var}.h\n&#34;
        return out</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rust.RustExternTypeConverter"><code class="flex name class">
<span>class <span class="ident">RustExternTypeConverter</span></span>
<span>(</span><span>type, to_c_storage_type, bound_name, module)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RustExternTypeConverter(RustTypeConverterCommon):
        def __init__(self, type, to_c_storage_type, bound_name, module):
                super().__init__(type, to_c_storage_type, bound_name)
                self.module = module

        def get_type_api(self, module_name):
                return &#39;&#39;

        def to_c_call(self, in_var, out_var_p):
                out = &#39;&#39;
                if self.c_storage_class:
                        c_storage_var = &#39;storage_%s&#39; % out_var_p.replace(&#39;&amp;&#39;, &#39;_&#39;)
                        out += &#39;%s %s;\n&#39; % (self.c_storage_class, c_storage_var)
                        out += &#39;(*%s)(%s, (void *)%s, %s);\n&#39; % (self.to_c_func,
                                                                                                         in_var, out_var_p, c_storage_var)
                else:
                        out += &#39;(*%s)(%s, (void *)%s);\n&#39; % (self.to_c_func,
                                                                                                 in_var, out_var_p)
                return out

        def from_c_call(self, out_var, expr, ownership):
                return &#34;%s = (*%s)((void *)%s, %s);\n&#34; % (out_var, self.from_c_func, expr, ownership)

        def check_call(self, in_var):
                return &#34;(*%s)(%s)&#34; % (self.check_func, in_var)

        def get_type_glue(self, gen, module_name):
                out = &#39;// extern type API for %s\n&#39; % self.ctype
                if self.c_storage_class:
                        out += &#39;struct %;\n&#39; % self.c_storage_class
                out += &#39;bool (*%s)(void *o) = nullptr;\n&#39; % self.check_func
                if self.c_storage_class:
                        out += &#39;void (*%s)(void *o, void *obj, %s &amp;storage) = nullptr;\n&#39; % (
                                self.to_c_func, self.c_storage_class)
                else:
                        out += &#39;void (*%s)(void *o, void *obj) = nullptr;\n&#39; % self.to_c_func
                out += &#39;int (*%s)(void *obj, OwnershipPolicy) = nullptr;\n&#39; % self.from_c_func
                out += &#39;\n&#39;
                return out</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rust.RustTypeConverterCommon" href="#rust.RustTypeConverterCommon">RustTypeConverterCommon</a></li>
<li>gen.TypeConverter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rust.RustExternTypeConverter.check_call"><code class="name flex">
<span>def <span class="ident">check_call</span></span>(<span>self, in_var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_call(self, in_var):
        return &#34;(*%s)(%s)&#34; % (self.check_func, in_var)</code></pre>
</details>
</dd>
<dt id="rust.RustExternTypeConverter.from_c_call"><code class="name flex">
<span>def <span class="ident">from_c_call</span></span>(<span>self, out_var, expr, ownership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_c_call(self, out_var, expr, ownership):
        return &#34;%s = (*%s)((void *)%s, %s);\n&#34; % (out_var, self.from_c_func, expr, ownership)</code></pre>
</details>
</dd>
<dt id="rust.RustExternTypeConverter.get_type_api"><code class="name flex">
<span>def <span class="ident">get_type_api</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_api(self, module_name):
        return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="rust.RustExternTypeConverter.get_type_glue"><code class="name flex">
<span>def <span class="ident">get_type_glue</span></span>(<span>self, gen, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_glue(self, gen, module_name):
        out = &#39;// extern type API for %s\n&#39; % self.ctype
        if self.c_storage_class:
                out += &#39;struct %;\n&#39; % self.c_storage_class
        out += &#39;bool (*%s)(void *o) = nullptr;\n&#39; % self.check_func
        if self.c_storage_class:
                out += &#39;void (*%s)(void *o, void *obj, %s &amp;storage) = nullptr;\n&#39; % (
                        self.to_c_func, self.c_storage_class)
        else:
                out += &#39;void (*%s)(void *o, void *obj) = nullptr;\n&#39; % self.to_c_func
        out += &#39;int (*%s)(void *obj, OwnershipPolicy) = nullptr;\n&#39; % self.from_c_func
        out += &#39;\n&#39;
        return out</code></pre>
</details>
</dd>
<dt id="rust.RustExternTypeConverter.to_c_call"><code class="name flex">
<span>def <span class="ident">to_c_call</span></span>(<span>self, in_var, out_var_p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_c_call(self, in_var, out_var_p):
        out = &#39;&#39;
        if self.c_storage_class:
                c_storage_var = &#39;storage_%s&#39; % out_var_p.replace(&#39;&amp;&#39;, &#39;_&#39;)
                out += &#39;%s %s;\n&#39; % (self.c_storage_class, c_storage_var)
                out += &#39;(*%s)(%s, (void *)%s, %s);\n&#39; % (self.to_c_func,
                                                                                                 in_var, out_var_p, c_storage_var)
        else:
                out += &#39;(*%s)(%s, (void *)%s);\n&#39; % (self.to_c_func,
                                                                                         in_var, out_var_p)
        return out</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rust.RustGenerator"><code class="flex name class">
<span>class <span class="ident">RustGenerator</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RustGenerator(gen.FABGen):
        default_ptr_converter = RustPtrTypeConverter
        default_class_converter = RustClassTypeDefaultConverter
        default_extern_converter = RustExternTypeConverter

        def __init__(self):
                super().__init__()
                self.check_self_type_in_ops = True
                self.rust = &#34;&#34;
                self.rust_directives = f&#39;// rust wrapper header\n&#39; \
                        &#39;#![allow(dead_code)]\n&#39; \


        def get_language(self):
                return &#34;Rust&#34;

        def output_includes(self):
                pass

        def start(self, module_name):
                super().start(module_name)

                self._source += self.get_binding_api_declaration()

        def set_compilation_directives(self, directives):
                self.rust_directives = directives

        # kill a bunch of functions we don&#39;t care about
        def set_error(self, type, reason):
                return &#34;&#34;

        def get_self(self, ctx):
                return &#34;&#34;

        def get_var(self, i, ctx):
                return &#34;&#34;

        def open_proxy(self, name, max_arg_count, ctx):
                return &#34;&#34;

        def _proto_call(self, self_conv, proto, expr_eval, ctx, fixed_arg_count=None):
                return &#34;&#34;

        def _bind_proxy(self, name, self_conv, protos, desc, expr_eval, ctx, fixed_arg_count=None):
                return &#34;&#34;

        def close_proxy(self, ctx):
                return &#34;&#34;

        def proxy_call_error(self, msg, ctx):
                return &#34;&#34;

        def return_void_from_c(self):
                return &#34;&#34;

        def rval_from_nullptr(self, out_var):
                return &#34;&#34;

        def rval_from_c_ptr(self, conv, out_var, expr, ownership):
                return &#34;&#34;

        def commit_from_c_vars(self, rvals, ctx=&#34;default&#34;):
                return &#34;&#34;

        def rbind_function(self, name, rval, args, internal=False):
                return &#34;&#34;

        #
        def get_binding_api_declaration(self):
                type_info_name = gen.apply_api_prefix(&#34;type_info&#34;)

                out = &#39;&#39;&#39;\
struct %s {
        uint32_t type_tag;
        const char *c_type;
        const char *bound_name;

        bool (*check)(void* p);
        void (*to_c)(void *p, void *out);
        int (*from_c)(void *obj, OwnershipPolicy policy);
};\n
&#39;&#39;&#39; % type_info_name

                out += &#34;// return a type info from its type tag\n&#34;
                out += &#34;%s *%s(uint32_t type_tag);\n&#34; % (type_info_name,
                                                                                                 gen.apply_api_prefix(&#34;get_bound_type_info&#34;))

                out += &#34;// return a type info from its type name\n&#34;
                out += &#34;%s *%s(const char *type);\n&#34; % (type_info_name,
                                                                                                gen.apply_api_prefix(&#34;get_c_type_info&#34;))

                out += &#34;// returns the typetag of a userdata object, nullptr if not a Fabgen object\n&#34;
                out += &#34;uint32_t %s(void* p);\n\n&#34; % gen.apply_api_prefix(
                        &#34;get_wrapped_object_type_tag&#34;)

                return out

        def output_binding_api(self):
                type_info_name = gen.apply_api_prefix(&#34;type_info&#34;)
                self._source += &#34;&#34;&#34;\
%s *%s(uint32_t type_tag) {
        return nullptr;
}\n\n&#34;&#34;&#34; % (
                        type_info_name,
                        gen.apply_api_prefix(&#34;get_bound_type_info&#34;),
                )

                self._source += &#34;&#34;&#34;
%s *%s(const char *type) {
        return nullptr;
}\n\n&#34;&#34;&#34; % (
                        type_info_name,
                        gen.apply_api_prefix(&#34;get_c_type_info&#34;),
                )

                self._source += &#34;&#34;&#34;\
uint32_t %s(void* p) {
        return 0;
        //auto o = cast_to_wrapped_Object_safe(L, idx);
        //return o ? o-&gt;type_tag : 0;
}\n\n&#34;&#34;&#34; % gen.apply_api_prefix(&#34;get_wrapped_object_type_tag&#34;)

        #
        def get_output(self):
                return {&#34;wrapper.cpp&#34;: self.rust_c, &#34;wrapper.h&#34;: self.rust_h, &#34;bind.rs&#34;: self.rust_bind, &#34;translate_file.json&#34;: self.rust_translate_file}

        def _get_type(self, name):
                for type in self._bound_types:
                        if type:
                                return type
                return None

        def _get_conv(self, conv_name):
                if conv_name in self._FABGen__type_convs:
                        return self.get_conv(conv_name)
                return None

        def _get_conv_from_bound_name(self, bound_name):
                for name, conv in self._FABGen__type_convs.items():
                        if conv.bound_name == bound_name:
                                return conv
                return None

        def __get_is_type_class_or_pointer_with_class(self, conv):
                if conv.is_type_class() or \
                                (isinstance(conv, RustPtrTypeConverter) and self._get_conv(str(conv.ctype.scoped_typename)) is None):
                        return True
                return False

        def __get_stars(self, val, start_stars=0, add_start_for_ref=True):
                stars = &#34;*&#34; * start_stars
                if &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;):
                        stars += &#34;*&#34; * \
                                (len(val[&#34;carg&#34;].ctype.ref)
                                 if add_start_for_ref else val[&#34;carg&#34;].ctype.ref.count(&#39;*&#39;))
                elif &#34;storage_ctype&#34; in val and hasattr(val[&#34;storage_ctype&#34;], &#34;ref&#34;):
                        stars += &#34;*&#34; * (len(val[&#34;storage_ctype&#34;].ref)
                                                        if add_start_for_ref else val[&#34;storage_ctype&#34;].ref.count(&#39;*&#39;))
                elif hasattr(val[&#34;conv&#34;].ctype, &#34;ref&#34;):
                        stars += &#34;*&#34; * \
                                (len(val[&#34;conv&#34;].ctype.ref)
                                 if add_start_for_ref else val[&#34;conv&#34;].ctype.ref.count(&#39;*&#39;))
                return stars

        def __arg_from_cpp_to_c(self, val, retval_name, just_copy):
                src = &#34;&#34;
                # type class, not a pointer
                if val[&#39;conv&#39;] is not None and val[&#39;conv&#39;].is_type_class() and \
                                not val[&#39;conv&#39;].ctype.is_pointer() and (&#39;storage_ctype&#39; not in val or not hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) or not any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])):
                        # special shared ptr
                        if &#39;proxy&#39; in val[&#39;conv&#39;]._features:
                                src += f&#34;       if(!{retval_name})\n&#34; \
                                        &#34;               return nullptr;\n&#34;

                                src += &#34;        auto &#34; + \
                                        val[&#39;conv&#39;]._features[&#39;proxy&#39;].wrap(&#34;ret&#34;, &#34;retPointer&#34;)
                        # special std::future
                        elif val[&#34;conv&#34;] is not None and &#34;std::future&#34; in str(val[&#34;conv&#34;].ctype):
                                src += f&#34;       auto retPointer = new std::future&lt;int&gt;(std::move({retval_name}));\n&#34;
                        else:
                                # class, not pointer, but static
                                if just_copy:
                                        src += f&#34;       auto retPointer = {retval_name};\n&#34;
                                else:
                                        src += f&#34;       auto retPointer = new {val[&#39;conv&#39;].ctype}({retval_name});\n&#34;
                        retval_name = f&#34;({clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})(retPointer)&#34;
                else:
                        # special std::string (convert to const char*)
                        if val[&#34;conv&#34;] is not None and &#34;std::string&#34; in str(val[&#34;conv&#34;].ctype):
                                stars = self.__get_stars(val)
                                if len(stars) &gt; 0:  # rarely use but just in case
                                        retval_name = f&#34;new const char*(&amp;(*{retval_name}-&gt;begin()))&#34;
                                else:
                                        retval_name = f&#34;{retval_name}.c_str()&#34;
                        else:
                                retval_name = f&#34;{retval_name}&#34;

                # cast it
                # if it&#39;s an enum
                if val[&#34;conv&#34;].bound_name in self._enums.keys():
                        enum_conv = self._get_conv_from_bound_name(val[&#39;conv&#39;].bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                arg_bound_name = str(enum_conv.base_type)
                        else:
                                arg_bound_name = &#34;int&#34;
                        retval_name = f&#34;({arg_bound_name}){retval_name}&#34;
                # cast it, if it&#39;s a const
                elif &#39;storage_ctype&#39; in val and val[&#34;storage_ctype&#34;].const or \
                                &#39;carg&#39; in val and val[&#34;carg&#34;].ctype.const:
                        arg_bound_name = self.__get_arg_bound_name_to_c(val)
                        retval_name = f&#34;({arg_bound_name}){retval_name}&#34;

                return src, retval_name

        def __arg_from_c_to_cpp(self, val, retval_name, add_star=True):
                src = &#34;&#34;
                # check if there is special slice to convert
                if isinstance(val[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                        # special if string or const char*
                        if &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;].T_conv):  # or \
                                # &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;].T_conv):
                                src += f&#34;std::vector&lt;{val[&#39;conv&#39;].T_conv.ctype}&gt; {retval_name};\n&#34;\
                                        f&#34;for(int i_counter_c=0; i_counter_c &lt; {retval_name}ToCSize; ++i_counter_c)\n&#34;\
                                        f&#34;      {retval_name}.push_back(std::string({retval_name}ToCBuf[i_counter_c]));\n&#34;
                        # slice from class
                        elif self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;].T_conv):
                                src += f&#34;std::vector&lt;{val[&#39;conv&#39;].T_conv.ctype}&gt; {retval_name};\n&#34;\
                                        f&#34;for(int i_counter_c=0; i_counter_c &lt; {retval_name}ToCSize; ++i_counter_c)\n&#34;\
                                        f&#34;      {retval_name}.push_back(*(({val[&#39;conv&#39;].T_conv.ctype}**){retval_name}ToCBuf)[i_counter_c]);\n&#34;
                        else:
                                src += f&#34;std::vector&lt;{val[&#39;conv&#39;].T_conv.ctype}&gt; {retval_name}(({val[&#39;conv&#39;].T_conv.ctype}*){retval_name}ToCBuf, ({val[&#39;conv&#39;].T_conv.ctype}*){retval_name}ToCBuf + {retval_name}ToCSize);\n&#34;

                retval = &#34;&#34;
                # very special case, std::string &amp;
                if &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;]) and \
                                &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;]) and \
                                not val[&#34;carg&#34;].ctype.const:
                        src += f&#34;std::string {retval_name}_cpp(*{retval_name});\n&#34;
                        retval += f&#34;{retval_name}_cpp&#34;
                # std::function
                elif &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        func_name = val[&#34;conv&#34;].base_type.replace(
                                &#34;std::function&lt;&#34;, &#34;&#34;)[:-1]
                        first_parenthesis = func_name.find(&#34;(&#34;)
                        retval += f&#34;({func_name[:first_parenthesis]}(*){func_name[first_parenthesis:]}){retval_name}&#34;
                # classe or pointer on class
                else:
                        if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                stars = self.__get_stars(val, add_start_for_ref=False)
                                # for type pointer, there is a * in the ctype, so remove one
                                if isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):
                                        stars = stars[1:]

                                # if it&#39;s not a pointer, add a star anyway because we use pointer to use in rust
                                if (not val[&#34;conv&#34;].ctype.is_pointer() and (&#34;carg&#34; not in val or (&#34;carg&#34; in val and not val[&#34;carg&#34;].ctype.is_pointer()))):
                                        stars += &#34;*&#34;
                                        if add_star:
                                                retval += &#34;*&#34;

                                retval += f&#34;({val[&#39;conv&#39;].ctype}{stars}){retval_name}&#34;

                        elif &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;]) and not val[&#34;carg&#34;].ctype.const:
                                # add cast and *
                                retval = f&#34;({val[&#39;carg&#39;].ctype})(*{retval_name})&#34;
                        # cast, if it&#39;s an enum
                        elif val[&#34;conv&#34;].bound_name in self._enums.keys():
                                retval = f&#34;({val[&#39;conv&#39;].ctype}){retval_name}&#34;
                        else:
                                retval = retval_name

                return src, retval

        def __arg_from_c_to_rust(self, val, retval_name, non_owning=False):

                rval_ownership = self._FABGen__ctype_to_ownership_policy(
                        val[&#34;conv&#34;].ctype)

                src = &#34;&#34;
                # check if pointer
                if (&#39;carg&#39; in val and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                (&#39;carg&#39; not in val and &#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                (&#39;carg&#39; not in val and &#39;storage_ctype&#39; not in val and (val[&#39;conv&#39;]._is_pointer or val[&#39;conv&#39;].ctype.is_pointer())):
                        is_pointer = True
                else:
                        is_pointer = False

                # check if ref
                if (&#39;carg&#39; in val and (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;]))) or \
                                (&#39;carg&#39; not in val and &#39;storage_ctype&#39; in val and ((hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;])))):
                        is_ref = True
                else:
                        is_ref = False

                # check if need convert from c
                # if not a pointer
                if not is_pointer:
                        if val[&#39;conv&#39;].bound_name in self._enums.keys():  # if it&#39;s an enum
                                retval_name = f&#34;{val[&#39;conv&#39;].bound_name}({retval_name})&#34;
                        else:
                                conversion_ret = val[&#39;conv&#39;].from_c_call(retval_name, &#34;&#34;, &#34;&#34;)
                                if conversion_ret != &#34;&#34;:
                                        retval_name = conversion_ret

                                # if it&#39;s a class, not a pointer, only out, create the class special
                                if val[&#34;conv&#34;].is_type_class():
                                        retval_boundname = val[&#34;conv&#34;].bound_name
                                        retval_boundname = clean_name_with_title(retval_boundname)

                                        src += f&#34;       {retval_name}RUST := &amp;{retval_boundname}{{h:{retval_name}}}\n&#34;

                                        # check if owning to have the right to destroy it
                                        if rval_ownership != &#34;NonOwning&#34; and not is_ref and not non_owning:
                                                src += f&#34;       runtime.SetFinalizer({retval_name}RUST, func(cleanval *{retval_boundname}) {{\n&#34; \
                                                        f&#34;              C.{clean_name_with_title(self._name)}{retval_boundname}Free(cleanval.h)\n&#34; \
                                                        f&#34;      }})\n&#34;
                                        retval_name = f&#34;{retval_name}RUST&#34;

                # if pointer or ref
                elif is_pointer:
                        # special const char * and string
                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]) or \
                                        &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;]):
                                stars = self.__get_stars(val)

                                retval_name_from_c = &#34;*&#34;*len(stars) + retval_name
                                if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]):
                                        retval_name_from_c = &#34;*&#34;*(len(stars) - 1) + retval_name

                                conversion_ret = val[&#39;conv&#39;].from_c_call(
                                        retval_name_from_c, &#34;&#34;, &#34;&#34;)

                                if len(stars) &gt; 0:
                                        prefix = &#34;&amp;&#34; * len(stars)
                                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]):
                                                prefix = &#34;&amp;&#34; * (len(stars)-1)

                                        src += f&#34;{retval_name}RUST := string({conversion_ret})\n&#34;
                                        retval_name = prefix + retval_name + &#34;RUST&#34;
                                else:
                                        conversion_ret = retval_name

                        # if it&#39;s a class, a pointer, only out, create the class special
                        elif self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                retval_boundname = val[&#39;conv&#39;].bound_name
                                retval_boundname = clean_name_with_title(retval_boundname)
                                src += f&#34;var {retval_name}RUST *{retval_boundname}\n&#34; \
                                        f&#34;if {retval_name} != nil {{\n&#34; \
                                        f&#34;      {retval_name}RUST = &amp;{retval_boundname}{{h:{retval_name}}}\n&#34;

                                # check if owning to have the right to destroy it
                                if rval_ownership != &#34;NonOwning&#34; and not is_ref and not non_owning:
                                        src += f&#34;       runtime.SetFinalizer({retval_name}RUST, func(cleanval *{retval_boundname}) {{\n&#34; \
                                                f&#34;              C.{clean_name_with_title(self._name)}{retval_boundname}Free(cleanval.h)\n&#34;\
                                                f&#34;      }})\n&#34;
                                src += &#34;}\n&#34;
                                retval_name = f&#34;{retval_name}RUST&#34;
                        else:
                                retval_name = f&#34;({self.__get_arg_bound_name_to_rust(val)})(unsafe.Pointer({retval_name}))\n&#34;

                return src, retval_name

        def __arg_from_rust_to_c(self, val, arg_name):
                def convert_rust_to_c(val, arg_name, arg_out_name, start_stars=0):
                        stars = self.__get_stars(val, start_stars)

                        if val[&#34;conv&#34;].is_type_class():
                                c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                        else:
                                # get base conv (without pointer)
                                base_conv = self._get_conv(
                                        str(val[&#34;conv&#34;].ctype.scoped_typename))
                                if base_conv is None:
                                        if isinstance(val[&#34;conv&#34;], RustPtrTypeConverter):
                                                c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars[1:]}C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                                        else:
                                                c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}{str(val[&#39;conv&#39;].bound_name)})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                                elif hasattr(base_conv, &#34;rust_to_c_type&#34;) and base_conv.rust_to_c_type is not None:
                                        c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}{base_conv.rust_to_c_type})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                                else:
                                        c_call = f&#34;{clean_name(arg_out_name).replace(&#39;&amp;&#39;, &#39;_&#39;)} := ({stars}{base_conv.bound_name})(unsafe.Pointer({clean_name(arg_name)}))\n&#34;
                        return c_call

                c_call = &#34;&#34;
                # if it&#39;s a pointer on something
                if isinstance(val[&#34;conv&#34;], RustPtrTypeConverter):
                        base_conv = self._get_conv(str(val[&#34;conv&#34;].ctype.scoped_typename))
                        if base_conv is None or base_conv.is_type_class():
                                c_call = f&#34;{clean_name(arg_name)}ToC := {clean_name(arg_name)}.h\n&#34;
                        else:
                                c_call = convert_rust_to_c(val, arg_name, f&#34;{arg_name}ToC&#34;)
                # if it&#39;s a class
                elif val[&#34;conv&#34;].is_type_class():
                        stars = self.__get_stars(val)
                        c_call = f&#34;{clean_name(arg_name)}ToC := {stars[1:]}{clean_name(arg_name)}.h\n&#34;
                # if it&#39;s an enum
                elif val[&#34;conv&#34;].bound_name in self._enums.keys():
                        enum_conv = self._get_conv_from_bound_name(val[&#34;conv&#34;].bound_name)
                        # if it&#39;s a ref to an enum
                        if len(self.__get_stars(val)) &gt; 0:
                                c_call = convert_rust_to_c(val, arg_name, f&#34;{arg_name}ToC&#34;)
                        else:
                                if enum_conv is not None and hasattr(enum_conv, &#34;rust_to_c_type&#34;) and enum_conv.rust_to_c_type is not None:
                                        arg_bound_name = enum_conv.rust_to_c_type
                                else:
                                        arg_bound_name = &#34;C.int&#34;

                                c_call = f&#34;{clean_name(arg_name)}ToC := {arg_bound_name}({clean_name(arg_name)})\n&#34;
                # special Slice
                elif isinstance(val[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                        c_call = &#34;&#34;
                        slice_name = clean_name(arg_name)
                        # special if string or const char*
                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;].T_conv) or \
                                        &#34;RustStringConverter&#34; in str(val[&#34;conv&#34;].T_conv):
                                c_call += f&#34;var {slice_name}SpecialString []*C.char\n&#34;
                                c_call += f&#34;for _, s := range {slice_name} {{\n&#34;
                                c_call += f&#34;    {slice_name}SpecialString = append({slice_name}SpecialString, C.CString(s))\n&#34;
                                c_call += f&#34;}}\n&#34;
                                slice_name = f&#34;{slice_name}SpecialString&#34;

                        # if it&#39;s a class, get a list of pointer to c class
                        elif self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;].T_conv):
                                c_call += f&#34;var {slice_name}Pointer  []C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].T_conv.bound_name)}\n&#34;
                                c_call += f&#34;for _, s := range {slice_name} {{\n&#34;
                                c_call += f&#34;    {slice_name}Pointer = append({slice_name}Pointer, s.h)\n&#34;
                                c_call += f&#34;}}\n&#34;
                                slice_name = f&#34;{slice_name}Pointer&#34;

                        c_call += f&#34;{slice_name}ToC := (*reflect.SliceHeader)(unsafe.Pointer(&amp;{slice_name}))\n&#34;
                        c_call += f&#34;{slice_name}ToCSize := C.size_t({slice_name}ToC.Len)\n&#34;

                        c_call += convert_rust_to_c(
                                {&#34;conv&#34;: val[&#34;conv&#34;].T_conv}, f&#34;{slice_name}ToC.Data&#34;, f&#34;{slice_name}ToCBuf&#34;, 1)
                # std function
                elif &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        c_call += f&#34;{clean_name(arg_name)}ToC := (C.{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)})({clean_name(arg_name)})\n&#34;
                else:
                        how_many_stars = 0
                        # compute how many stars (to handle specifically the const char *)
                        if &#34;carg&#34; in val:
                                if hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;]) and not val[&#34;carg&#34;].ctype.const:
                                        how_many_stars = len(val[&#34;carg&#34;].ctype.ref)
                                elif val[&#34;carg&#34;].ctype.is_pointer():
                                        how_many_stars = 1
                        else:
                                if hasattr(val[&#34;conv&#34;].ctype, &#34;ref&#34;) and any(s in val[&#34;conv&#34;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;]) and not val[&#34;carg&#34;].ctype.const:
                                        how_many_stars = len(val[&#34;conv&#34;].ctype.ref)
                                elif val[&#34;conv&#34;].ctype.is_pointer():
                                        how_many_stars = 1

                        is_pointer = True
                        if how_many_stars == 0 or \
                                        (how_many_stars == 1 and &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;])):
                                is_pointer = False
                        c_call = val[&#34;conv&#34;].to_c_call(clean_name(
                                arg_name), f&#34;{clean_name(arg_name)}ToC&#34;, is_pointer)
                return c_call

        def __get_arg_bound_name_to_rust(self, val):
                if val[&#34;conv&#34;].is_type_class():
                        arg_bound_name = val[&#34;conv&#34;].bound_name
                else:
                        # check the convert from the base (in case of ptr) or a string
                        if (&#39;carg&#39; in val and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        (&#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):

                                if hasattr(val[&#34;conv&#34;], &#34;rust_type&#34;) and val[&#34;conv&#34;].rust_type is not None:
                                        arg_bound_name = str(val[&#34;conv&#34;].rust_type)
                                else:
                                        base_conv = self._get_conv(
                                                str(val[&#39;conv&#39;].ctype.scoped_typename))
                                        if base_conv is None:
                                                arg_bound_name = str(val[&#34;conv&#34;].bound_name)
                                        else:
                                                if hasattr(base_conv, &#34;rust_type&#34;) and base_conv.rust_type is not None:
                                                        arg_bound_name = base_conv.rust_type
                                                else:
                                                        arg_bound_name = base_conv.bound_name
                        else:
                                if val[&#39;conv&#39;].bound_name in self._enums.keys():  # if it&#39;s an enum
                                        arg_bound_name = f&#34;{val[&#39;conv&#39;].bound_name}&#34;
                                elif hasattr(val[&#34;conv&#34;], &#34;rust_type&#34;) and val[&#34;conv&#34;].rust_type is not None:
                                        arg_bound_name = val[&#34;conv&#34;].rust_type
                                else:
                                        arg_bound_name = val[&#34;conv&#34;].bound_name

                if arg_bound_name.endswith(&#34;_nobind&#34;) and val[&#34;conv&#34;].nobind:
                        arg_bound_name = arg_bound_name[:-len(&#34;_nobind&#34;)]

                # if it&#39;s a pointer and not a string not a const
                if ((&#39;carg&#39; in val and (not val[&#34;carg&#34;].ctype.const and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;]))))) or
                                (&#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or
                                isinstance(val[&#39;conv&#39;], RustPtrTypeConverter)):
                        # find how many * we need to add
                        stars = &#34;*mut &#34;
                        if &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;):
                                stars += &#34;*mut &#34; * (len(val[&#34;carg&#34;].ctype.ref) - 1)
                        if &#34;storage_ctype&#34; in val and hasattr(val[&#34;storage_ctype&#34;], &#34;ref&#34;):
                                stars += &#34;*mut &#34; * (len(val[&#34;storage_ctype&#34;].ref) - 1)

                        # special const char *
                        if &#34;RustConstCharPtrConverter&#34; in str(val[&#34;conv&#34;]):
                                stars = stars[1:]

                        # Harfang class doesn&#39;t need to be a pointer in rust (because it&#39;s a struct containing a wrap pointer C)
                        if not self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                arg_bound_name = stars + arg_bound_name

                # std function
                if &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        arg_bound_name = &#34;unsafe.Pointer&#34;

                # class or slice, clean the name with title
                if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]) or \
                                isinstance(val[&#39;conv&#39;], lib.rust.stl.RustSliceToStdVectorConverter):
                        arg_bound_name = clean_name_with_title(arg_bound_name)

                # i&#39;f it&#39;s a class, it&#39;s a pointer
                if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                        arg_bound_name = &#34;*mut &#34; + arg_bound_name

                return arg_bound_name

        def __get_arg_bound_name_to_c(self, val):
                arg_bound_name = &#34;&#34;

                # check to add const
                if &#39;storage_ctype&#39; in val and val[&#34;storage_ctype&#34;].const or \
                                &#39;carg&#39; in val and val[&#34;carg&#34;].ctype.const:
                        arg_bound_name += &#34;const &#34;

                # if class or pointer with class
                if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]) or \
                                &#34;RustStdFunctionConverter&#34; in str(val[&#34;conv&#34;]):
                        arg_bound_name += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(val[&#39;conv&#39;].bound_name)} &#34;
                else:
                        # check the convert from the base (in case of ptr)
                        if (&#39;carg&#39; in val and (val[&#39;carg&#39;].ctype.is_pointer() or (hasattr(val[&#39;carg&#39;].ctype, &#39;ref&#39;) and any(s in val[&#39;carg&#39;].ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        (&#39;storage_ctype&#39; in val and (val[&#39;storage_ctype&#39;].is_pointer() or (hasattr(val[&#39;storage_ctype&#39;], &#39;ref&#39;) and any(s in val[&#39;storage_ctype&#39;].ref for s in [&#34;&amp;&#34;, &#34;*&#34;])))) or \
                                        isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):
                                # check if it&#39;s an enum
                                if val[&#39;conv&#39;].bound_name in self._enums.keys():
                                        enum_conv = self._get_conv_from_bound_name(
                                                val[&#39;conv&#39;].bound_name)
                                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                                arg_bound_name = str(enum_conv.base_type)
                                        else:
                                                arg_bound_name = &#34;int&#34;
                                else:
                                        # sometimes typedef is weird and don&#39;t give valid value, so check it
                                        base_conv = self._get_conv(str(val[&#39;conv&#39;].bound_name))
                                        if base_conv is None:
                                                # check with typedef
                                                if hasattr(val[&#39;conv&#39;], &#34;base_type&#34;) and val[&#39;conv&#39;].base_type is not None:
                                                        arg_bound_name = str(val[&#39;conv&#39;].base_type)
                                                else:
                                                        if &#39;storage_ctype&#39; in val:
                                                                arg_bound_name += f&#34;{val[&#39;storage_ctype&#39;]} &#34;
                                                        else:
                                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].ctype} &#34;

                                                # if it&#39;s a ptr type, remove a star
                                                if isinstance(val[&#39;conv&#39;], RustPtrTypeConverter):
                                                        arg_bound_name = arg_bound_name.replace(
                                                                &#34;*&#34;, &#34;&#34;).replace(&#34;&amp;&#34;, &#34;&#34;)
                                        else:
                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].bound_name} &#34;

                                # add a star (only if it&#39;s not a const char * SPECIAL CASE)
                                if &#34;RustConstCharPtrConverter&#34; not in str(val[&#34;conv&#34;]):
                                        arg_bound_name += &#34;*&#34;

                                if &#34;carg&#34; in val and hasattr(val[&#34;carg&#34;].ctype, &#34;ref&#34;) and not val[&#34;carg&#34;].ctype.const:
                                        arg_bound_name += &#34;*&#34; * (len(val[&#34;carg&#34;].ctype.ref) - 1)
                                if &#34;storage_ctype&#34; in val and hasattr(val[&#34;storage_ctype&#34;], &#34;ref&#34;):
                                        arg_bound_name += &#34;*&#34; * (len(val[&#34;storage_ctype&#34;].ref) - 1)
                        else:
                                # check if it&#39;s an enum
                                if val[&#39;conv&#39;].bound_name in self._enums.keys():
                                        enum_conv = self._get_conv_from_bound_name(
                                                val[&#39;conv&#39;].bound_name)
                                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                                arg_bound_name = str(enum_conv.base_type)
                                        else:
                                                arg_bound_name = &#34;int&#34;
                                else:
                                        # sometimes typedef is weird and don&#39;t give valid value, so check it
                                        base_conv = self._get_conv(str(val[&#39;conv&#39;].bound_name))
                                        if base_conv is None:
                                                if hasattr(val[&#39;conv&#39;], &#34;base_type&#34;) and val[&#39;conv&#39;].base_type is not None:
                                                        arg_bound_name = str(val[&#39;conv&#39;].base_type)
                                                else:
                                                        if &#39;storage_ctype&#39; in val:
                                                                arg_bound_name += f&#34;{val[&#39;storage_ctype&#39;]} &#34;
                                                        else:
                                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].ctype} &#34;
                                        else:
                                                arg_bound_name += f&#34;{val[&#39;conv&#39;].bound_name} &#34;
                return arg_bound_name

        def __extract_sequence(self, conv, is_in_header=False):
                rust = &#34;&#34;

                cleanClassname = clean_name_with_title(conv.bound_name)

                internal_conv = conv._features[&#34;sequence&#34;].wrapped_conv

                arg_bound_name = self.__get_arg_bound_name_to_c(
                        {&#34;conv&#34;: internal_conv})

                # special std::string (convert to const char*)
                c_arg_bound_name = arg_bound_name.replace(&#34;std::string&#34;, &#34;const char*&#34;)
                c_arg_bound_name = c_arg_bound_name.replace(&#34;const const&#34;, &#34;const&#34;)

                # GET
                if is_in_header:
                        rust += &#34;extern &#34;
                rust += f&#34;{c_arg_bound_name} {clean_name_with_title(self._name)}{cleanClassname}GetOperator({clean_name_with_title(self._name)}{cleanClassname} h, int id)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += f&#34;{{\n&#34; \
                                        &#34;       bool error;\n&#34; \
                                        f&#34;      {internal_conv.ctype} v;\n      &#34;
                        rust += conv._features[&#39;sequence&#39;].get_item(
                                f&#34;(({conv.ctype}*)h)&#34;, &#34;id&#34;, &#34;v&#34;, &#34;error&#34;)

                        src, retval_c = self.__arg_from_cpp_to_c(
                                {&#34;conv&#34;: internal_conv}, &#34;v&#34;, False)
                        rust += src
                        rust += f&#34;      return {retval_c};\n}}\n&#34;

                # SET
                if is_in_header:
                        rust += &#34;extern &#34;
                rust += f&#34;void {clean_name_with_title(self._name)}{cleanClassname}SetOperator({clean_name_with_title(self._name)}{cleanClassname} h, int id, {c_arg_bound_name} v)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += f&#34;{{\n&#34; \
                                        &#34;       bool error;\n&#34;

                        src, inval = self.__arg_from_c_to_cpp(
                                {&#34;conv&#34;: internal_conv}, &#34;v&#34;, False)
                        rust += src

                        rust += conv._features[&#39;sequence&#39;].set_item(
                                f&#34;(({conv.ctype}*)h)&#34;, &#34;id&#34;, inval, &#34;error&#34;)
                        rust += f&#34;\n}}\n&#34;

                # LEN
                if is_in_header:
                        rust += &#34;extern &#34;
                rust += f&#34;int {clean_name_with_title(self._name)}{cleanClassname}LenOperator({clean_name_with_title(self._name)}{cleanClassname} h)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += f&#34;{{\n&#34; \
                                        &#34;       int size;\n     &#34;
                        rust += conv._features[&#39;sequence&#39;].get_size(
                                f&#34;(({conv.ctype}*)h)&#34;, &#34;size&#34;)
                        rust += f&#34;      return size;\n}}\n&#34;

                return rust

        def __extract_get_set_member(self, classname, convClass, member, static=False, name=None, bound_name=None, is_global=False, is_in_header=False):
                rust = &#34;&#34;
                conv = self.select_ctype_conv(member[&#34;ctype&#34;])

                if &#34;bound_name&#34; in member:
                        bound_name = str(member[&#34;bound_name&#34;])
                elif bound_name is None:
                        bound_name = str(member[&#34;name&#34;])
                if name is None:
                        name = bound_name
                name = clean_name_with_title(name)

                c_name = str(member[&#34;name&#34;])

                cleanClassname = clean_name_with_title(classname)

                # special Slice
                if isinstance(conv, lib.rust.stl.RustSliceToStdVectorConverter):
                        arg_bound_name = self.__get_arg_bound_name_to_c(
                                {&#34;conv&#34;: conv.T_conv})
                else:
                        arg_bound_name = self.__get_arg_bound_name_to_c({&#34;conv&#34;: conv})

                # special std::string (convert to const char*)
                c_arg_bound_name = arg_bound_name.replace(&#34;std::string&#34;, &#34;const char*&#34;)
                c_arg_bound_name = c_arg_bound_name.replace(&#34;const const&#34;, &#34;const&#34;)

                # GET
                if is_in_header:
                        rust += &#34;extern &#34;

                rust += f&#34;{c_arg_bound_name} {clean_name_with_title(self._name)}{cleanClassname}Get{name.replace(&#39;:&#39;, &#39;&#39;)}(&#34;
                if not static and not is_global:
                        rust += f&#34;{clean_name_with_title(self._name)}{cleanClassname} h&#34;
                rust += &#34;)&#34;

                if is_in_header:
                        rust += &#34;;\n&#34;
                else:
                        rust += &#34;{&#34;
                        # check if the value is a ref
                        prefix = &#34;&#34;
                        if (hasattr(conv.ctype, &#34;ref&#34;) and conv.ctype.ref in [&#34;&amp;&#34;, &#34;*&amp;&#34;]) or \
                                        conv.is_type_class():
                                prefix = &#34;&amp;&#34;

                        if static or is_global:
                                if convClass is not None:
                                        rust += f&#34;      auto ret = {prefix}{convClass.ctype}::{c_name};\n&#34;
                                else:
                                        rust += f&#34;      auto ret = {prefix}{classname}::{c_name};\n&#34;
                        else:
                                if convClass is not None and &#34;proxy&#34; in convClass._features:
                                        rust += f&#34;\n    auto v = _type_tag_cast(h, {convClass.type_tag}, {convClass._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;
                                        rust += f&#34;      auto ret = {prefix}(({convClass._features[&#39;proxy&#39;].wrapped_conv.ctype}*)v)-&gt;{c_name};\n&#34;
                                else:
                                        rust += f&#34;      auto ret = {prefix}(({convClass.ctype}*)h)-&gt;{c_name};\n&#34;

                        src, retval_c = self.__arg_from_cpp_to_c(
                                {&#34;conv&#34;: conv}, &#34;ret&#34;, True)
                        rust += src
                        rust += f&#34;return {retval_c};\n}}\n&#34;

                # SET
                # add set only if the member is not const
                if not (member[&#34;ctype&#34;].const or conv._non_copyable):
                        if is_in_header:
                                rust += &#34;extern &#34;

                        rust += f&#34;void {clean_name_with_title(self._name)}{cleanClassname}Set{name.replace(&#39;:&#39;, &#39;&#39;)}(&#34;
                        if not static and not is_global:
                                rust += f&#34;{clean_name_with_title(self._name)}{cleanClassname} h, &#34;
                        rust += f&#34;{c_arg_bound_name} v)&#34;

                        if is_in_header:
                                rust += &#34;;\n&#34;
                        else:

                                src, inval = self.__arg_from_c_to_cpp({&#34;conv&#34;: conv}, &#34;v&#34;)
                                rust += src

                                if static or is_global:
                                        if convClass is not None:
                                                rust += f&#34;{{ {convClass.ctype}::{c_name} = {inval};\n}}\n&#34;
                                        else:
                                                rust += f&#34;{{ {classname}::{c_name} = {inval};\n}}\n&#34;
                                else:
                                        if convClass is not None and &#34;proxy&#34; in convClass._features:
                                                rust += f&#34;{{\n  auto w = _type_tag_cast(h, {convClass.type_tag}, {convClass._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;
                                                rust += f&#34;      (({convClass._features[&#39;proxy&#39;].wrapped_conv.bound_name}*)w)-&gt;{c_name} = {inval};\n}}\n&#34;
                                        else:
                                                rust += f&#34;{{ (({convClass.ctype}*)h)-&gt;{c_name} = {inval};}}\n&#34;
                return rust

        def __extract_method(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_in_header=False, is_constructor=False, overload_op=None):
                rust = &#34;&#34;

                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name
                wrap_name = bound_name

                cpp_function_name = name
                if &#34;name&#34; in method:
                        cpp_function_name = method[&#34;name&#34;]

                uid = classname + bound_name if classname else bound_name

                protos = self._build_protos(method[&#34;protos&#34;])
                for id_proto, proto in enumerate(protos):
                        retval = &#34;void&#34;

                        if str(proto[&#34;rval&#34;][&#34;storage_ctype&#34;]) != &#34;void&#34;:
                                retval = self.__get_arg_bound_name_to_c(proto[&#34;rval&#34;])

                                # special std::string (convert to const char*)
                                retval = retval.replace(&#34;std::string&#34;, &#34;const char*&#34;)
                                retval = retval.replace(&#34;const const&#34;, &#34;const&#34;)

                        if is_in_header:
                                rust += &#34;extern &#34;
                        rust += f&#34;{retval} {clean_name_with_title(self._name)}{clean_name_with_title(wrap_name)}&#34;

                        # not global, add the Name of the class to be sure to avoid double name function name
                        if not is_global or (not is_constructor and is_global and convClass is not None):
                                rust += f&#34;{clean_name_with_title(convClass.bound_name)}&#34;

                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        rust += &#34;(&#34;

                        has_previous_arg = False
                        # not global, member class, include the &#34;this&#34; pointer first
                        if not is_global or (not is_constructor and is_global and convClass is not None):
                                has_previous_arg = True
                                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(convClass.bound_name)} this_&#34;

                        if len(proto[&#34;args&#34;]):
                                for argin in proto[&#34;args&#34;]:
                                        if has_previous_arg:
                                                rust += &#34; ,&#34;

                                        # get arg name
                                        # special Slice
                                        if isinstance(argin[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                                                arg_bound_name = self.__get_arg_bound_name_to_c(
                                                        {&#34;conv&#34;: argin[&#34;conv&#34;].T_conv})
                                        else:
                                                arg_bound_name = self.__get_arg_bound_name_to_c(argin)

                                        # special std::string (convert to const char*)
                                        arg_bound_name = arg_bound_name.replace(
                                                &#34;std::string&#34;, &#34;const char*&#34;)
                                        arg_bound_name = arg_bound_name.replace(
                                                &#34;const const&#34;, &#34;const&#34;)

                                        # special Slice
                                        if isinstance(argin[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                                                rust += f&#34;size_t {clean_name(argin[&#39;carg&#39;].name)}ToCSize, {arg_bound_name} *{clean_name(argin[&#39;carg&#39;].name)}ToCBuf&#34;
                                        else:
                                                # normal argument
                                                rust += f&#34;{arg_bound_name} {argin[&#39;carg&#39;].name}&#34;
                                        has_previous_arg = True

                        rust += &#34;)&#34;

                        if is_in_header:
                                rust += &#34;;\n&#34;
                        else:
                                rust += &#34;{\n&#34;

                                args = []
                                # if another route is set
                                if &#34;route&#34; in proto[&#34;features&#34;] and convClass is not None and not is_constructor:
                                        args.append(f&#34;({convClass.ctype}*)this_&#34;)

                                # convert arg to cpp
                                if len(proto[&#34;args&#34;]):
                                        # if the function is global but have a convclass,
                                        # special case, which include the class has arg in first arg
                                        if not is_constructor and is_global and convClass is not None:
                                                src, retval_c = self.__arg_from_c_to_cpp(
                                                        {&#34;conv&#34;: convClass}, &#34;this_&#34;)
                                                rust += src
                                                args.append(retval_c)

                                        # other normal args
                                        for argin in proto[&#34;args&#34;]:
                                                # special Slice
                                                if isinstance(argin[&#34;conv&#34;], lib.rust.stl.RustSliceToStdVectorConverter):
                                                        src, retval_c = self.__arg_from_c_to_cpp(
                                                                argin, clean_name(str(argin[&#34;carg&#34;].name)))
                                                else:
                                                        src, retval_c = self.__arg_from_c_to_cpp(
                                                                argin, str(argin[&#34;carg&#34;].name))
                                                rust += src
                                                args.append(retval_c)

                                if is_constructor:
                                        # constructor, make our own return
                                        retval = &#34;void&#34;
                                        # if another route is set
                                        if &#34;route&#34; in proto[&#34;features&#34;]:
                                                rust += f&#34;      return (void*){proto[&#39;features&#39;][&#39;route&#39;](args)}\n&#34;
                                        elif &#34;proxy&#34; in convClass._features:
                                                rust += &#34;       auto &#34; + convClass._features[&#34;proxy&#34;].wrap(
                                                        f&#34;new {convClass._features[&#39;proxy&#39;].wrapped_conv.bound_name}({&#39;,&#39;.join(args)})&#34;, &#34;v&#34;)
                                                rust += &#34;       return v;\n&#34;
                                        else:
                                                rust += f&#34;      return (void*)(new {convClass.ctype}({&#39;,&#39;.join(args)}));\n&#34;
                                else:
                                        # if there is return value
                                        if retval != &#34;void&#34;:
                                                rust += &#34;       auto ret = &#34;

                                        # special comparison
                                        if overload_op is not None:
                                                rust += f&#34;(*({convClass.ctype}*)this_)&#34;
                                                rust += overload_op
                                                rust += f&#34;({args[0]});\n&#34;
                                        # classic call to function
                                        else:
                                                # transform &amp; to *
                                                if hasattr(proto[&#34;rval&#34;][&#34;storage_ctype&#34;], &#34;ref&#34;) and any(s in proto[&#34;rval&#34;][&#34;storage_ctype&#34;].ref for s in [&#34;&amp;&#34;]):
                                                        rust += &#34;&amp;&#34;

                                                # if another route is set
                                                if &#34;route&#34; in proto[&#34;features&#34;]:
                                                        rust += proto[&#34;features&#34;][&#34;route&#34;](args) + &#34;\n&#34;
                                                else:
                                                        # not global, member class, include the &#34;this&#34; pointer first
                                                        if not is_global:
                                                                rust += f&#34;(*({convClass.ctype}*)this_)&#34;
                                                                if convClass.ctype.is_pointer():
                                                                        rust += &#34;-&gt;&#34;
                                                                else:
                                                                        rust += &#34;.&#34;

                                                        # cpp function name
                                                        rust += cpp_function_name

                                                        # add function&#39;s arguments
                                                        rust += f&#34;({&#39;,&#39;.join(args)});\n&#34;

                                                # return arg out
                                                if &#34;arg_out&#34; in proto[&#34;features&#34;] or &#34;arg_in_out&#34; in proto[&#34;features&#34;]:
                                                        for arg in proto[&#39;args&#39;]:
                                                                if (&#39;arg_out&#39; in proto[&#39;features&#39;] and str(arg[&#39;carg&#39;].name) in proto[&#39;features&#39;][&#39;arg_out&#39;]) or \
                                                                                (&#39;arg_in_out&#39; in proto[&#39;features&#39;] and str(arg[&#39;carg&#39;].name) in proto[&#39;features&#39;][&#39;arg_in_out&#39;]):
                                                                        # FOR NOW ONLY FOR THE STD::STRING
                                                                        if &#34;RustStringConverter&#34; in str(arg[&#34;conv&#34;]) and \
                                                                                        &#34;carg&#34; in arg and hasattr(arg[&#34;carg&#34;].ctype, &#34;ref&#34;) and any(s in arg[&#34;carg&#34;].ctype.ref for s in [&#34;&amp;&#34;]):
                                                                                # it&#39;s a pointer (or there is a bug)
                                                                                retval_cpp = f&#34;(&amp;({str(arg[&#39;carg&#39;].name)}_cpp))&#34;
                                                                                src, retval_cpp = self.__arg_from_cpp_to_c(
                                                                                        arg, retval_cpp, static)
                                                                                rust += src
                                                                                rust += f&#34;      {str(arg[&#39;carg&#39;].name)} = {retval_cpp};\n&#34;

                                if retval != &#34;void&#34;:
                                        src, retval_c = self.__arg_from_cpp_to_c(
                                                proto[&#34;rval&#34;], &#34;ret&#34;, static)
                                        rust += src
                                        rust += f&#34;return {retval_c};\n&#34;
                                rust += &#34;}\n&#34;

                return rust

        def __extract_get_set_member_rust(self, classname, member, static=False, name=None, bound_name=None, is_global=False, implicit_cast=None):
                rust = &#34;&#34;
                conv = self.select_ctype_conv(member[&#34;ctype&#34;])

                if &#34;bound_name&#34; in member:
                        bound_name = str(member[&#34;bound_name&#34;])
                elif bound_name is None:
                        bound_name = str(member[&#34;name&#34;])
                if name is None:
                        name = bound_name

                name = name.replace(&#34;:&#34;, &#34;&#34;)
                name = clean_name_with_title(name)

                arg_bound_name = self.__get_arg_bound_name_to_rust({&#34;conv&#34;: conv})

                def create_get_set(do_static):
                        # GET
                        rust = &#34;&#34;

                        # if it&#39;s a const, just write it once
                        if is_global and member[&#34;ctype&#34;].const:
                                rust += f&#34;// {name} ...\n&#34;
                                if self.__get_is_type_class_or_pointer_with_class(conv):
                                        rust += f&#34;static {clean_name(name)} : {arg_bound_name.replace(&#39;*&#39;,&#39;&#39;)} = {arg_bound_name.replace(&#39;*&#39;, &#39;&#39;)}{clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{name}()\n&#34;
                                elif implicit_cast is not None:
                                        rust += f&#34;static {clean_name(name)} : *{implicit_cast} = {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{name}() as {implicit_cast}\n&#34;
                                else:
                                        rust += f&#34;static {clean_name(name)} : {arg_bound_name} = {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{name}() as {arg_bound_name}\n&#34;
                        else:
                                rust += &#34;// &#34;
                                if do_static:
                                        rust += f&#34;{clean_name_with_title(classname)}&#34;
                                rust += f&#34;{clean_name_with_title(self._name)}Get{name} ...\n&#34;
                                rust += f&#34;pub fn {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Get{clean_name_with_title(member[&#39;name&#39;].naked_name())}({clean_name_with_title(classname).lower()}: *mut {clean_name_with_title(classname)}) -&gt; {self.select_ctype_conv(member[&#39;ctype&#39;]).rust_type};\n&#34;

                        # SET
                        # add set only if the member is not const
                        if not member[&#34;ctype&#34;].const:
                                rust += f&#34;// &#34;
                                if do_static:
                                        rust += f&#34;{clean_name_with_title(classname)}&#34;
                                rust += f&#34;{clean_name_with_title(self._name)}Set{name} ...\n&#34; \
                                        f&#34;pub fn {clean_name_with_title(self._name)}{clean_name_with_title(classname)}Set{clean_name_with_title(member[&#39;name&#39;].naked_name())}({clean_name_with_title(classname).lower()}: *mut {clean_name_with_title(classname)},value : {self.select_ctype_conv(member[&#39;ctype&#39;]).rust_type});\n&#34;
                        return rust

                # create twice, with and without static, to use it with the class and standalone
                if not is_global:
                        rust += create_get_set(False)
                if static or is_global:
                        rust += create_get_set(True)

                return rust

        def __extract_rust_signature(self, classname, proto, is_global, name_rust):
                rust = &#34;pub fn &#34;
                if not is_global:
                        rust += f&#34;(pointer *{clean_name_with_title(classname)}) &#34;
                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(name_rust)}&#34;

                # add bounding_name to the overload function
                if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                        rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                # if automatic suffix generated
                elif &#34;suggested_suffix&#34; in proto:
                        rust += proto[&#34;suggested_suffix&#34;]

                # add input(s) declaration
                rust += &#34;(&#34;
                if len(proto[&#34;args&#34;]):
                        has_previous_arg = False
                        for argin in proto[&#34;args&#34;]:
                                if has_previous_arg:
                                        rust += &#34; ,&#34;

                                # check if the input is in feature constant group, overrite the type
                                if &#34;features&#34; in proto and &#34;constants_group&#34; in proto[&#34;features&#34;] and str(argin[&#34;carg&#34;].name) in proto[&#34;features&#34;][&#34;constants_group&#34;]:
                                        rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {proto[&#39;features&#39;][&#39;constants_group&#39;][str(argin[&#39;carg&#39;].name)]}&#34;
                                else:
                                        rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {self.__get_arg_bound_name_to_rust(argin)}&#34;
                                has_previous_arg = True

                rust += &#34;)&#34;

                # add output(s) declaration
                # has_previous_ret_arg = False
                if proto[&#34;rval&#34;][&#34;conv&#34;]:
                        rust += &#34; -&gt; &#34;
                        rust += self.__get_arg_bound_name_to_rust(proto[&#34;rval&#34;])
                rust += &#34;;&#34;
                return rust

        def __extract_method_signature_rust(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False):
                rust = &#34;&#34;

                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name

                if bound_name == &#34;OpenVRStateToViewState&#34;:
                        bound_name = bound_name

                name_rust = clean_name_with_title(name)
                if is_constructor:
                        name_rust = &#34;new_&#34; + name_rust

                uid = classname + bound_name if classname else bound_name

                protos = self._build_protos(method[&#34;protos&#34;])
                for id_proto, proto in enumerate(protos):
                        retval = &#34;&#34;

                        if proto[&#34;rval&#34;][&#34;conv&#34;]:
                                retval = proto[&#34;rval&#34;][&#34;conv&#34;].bound_name

                        rust += &#34;// &#34; + clean_name_with_title(name_rust)
                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        # get doc
                        if classname == &#34;&#34; or is_constructor:
                                doc = self.get_symbol_doc(bound_name)
                        else:
                                doc = self.get_symbol_doc(classname + &#34;_&#34; + bound_name)

                        if doc == &#34;&#34;:
                                rust += &#34; ...\n&#34;
                        else:
                                rust += &#34; &#34; + re.sub(r&#39;(\[)(.*?)(\])&#39;, r&#39;\1harfang.\2\3&#39;, doc) + &#34;\n&#34;
                        rust += self.__extract_rust_signature(
                                classname, proto, is_global, name_rust)

                        rust += &#34;\n\n&#34;

                return rust

        def __extract_method_rust(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False):
                rust = &#34;&#34;

                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name

                if bound_name == &#34;OpenVRStateToViewState&#34;:
                        bound_name = bound_name

                name_rust = clean_name_with_title(name)
                if is_constructor:
                        name_rust = &#34;Constructor&#34; + name_rust

                uid = classname + bound_name if classname else bound_name

                protos = self._build_protos(method[&#34;protos&#34;])
                for id_proto, proto in enumerate(protos):
                        retval = &#34;&#34;

                        if proto[&#34;rval&#34;][&#34;conv&#34;]:
                                retval = proto[&#34;rval&#34;][&#34;conv&#34;].bound_name

                        rust += &#34;//&#34; + clean_name_with_title(name_rust)
                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        # get doc
                        if classname == &#34;&#34; or is_constructor:
                                doc = self.get_symbol_doc(bound_name)
                        else:
                                doc = self.get_symbol_doc(classname + &#34;_&#34; + bound_name)

                        if doc == &#34;&#34;:
                                rust += &#34; ...\n&#34;
                        else:
                                rust += &#34; &#34; + re.sub(r&#39;(\[)(.*?)(\])&#39;, r&#39;\1harfang.\2\3&#39;, doc) + &#34;\n&#34;

                        rust += &#34;pub fn &#34;
                        if not is_global:
                                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(name_rust)}{clean_name_with_title(classname)}&#34;
                        else:
                                rust += f&#34;{clean_name_with_title(self._name)}{clean_name_with_title(name_rust)}&#34;

                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                rust += proto[&#34;suggested_suffix&#34;]

                        # add input(s) declaration
                        if  is_constructor:
                                rust += &#34;(&#34;
                                has_previous_arg = False
                        else:
                                rust += &#34;(_this : *mut &#34; + clean_name_with_title(classname) + &#34; &#34;
                                has_previous_arg = True
                                
                        if len(proto[&#34;args&#34;]):
                                for argin in proto[&#34;args&#34;]:
                                        if has_previous_arg:
                                                rust += &#34; ,&#34;

                                        # check if the input is in feature constant group, overrite the type
                                        if &#34;features&#34; in proto and &#34;constants_group&#34; in proto[&#34;features&#34;] and str(argin[&#34;carg&#34;].name) in proto[&#34;features&#34;][&#34;constants_group&#34;]:
                                                rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {proto[&#39;features&#39;][&#39;constants_group&#39;][str(argin[&#39;carg&#39;].name)]}&#34;
                                        else:
                                                rust += f&#34;{clean_name(argin[&#39;carg&#39;].name)} : {self.__get_arg_bound_name_to_rust(argin)}&#34;
                                        has_previous_arg = True

                        rust += &#34;)&#34;

                        # add output(s) declaration
                        if proto[&#34;rval&#34;][&#34;conv&#34;]:
                                rust += &#34; -&gt;&#34;
                                rust += self.__get_arg_bound_name_to_rust(proto[&#34;rval&#34;])
                        
                        rust += &#34;;\n&#34;

                return rust

        # VERY SPECIAL
        # check in every methods,
        # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
        def _check_arg_out_add_constructor_if_needed(self, method):
                def check_if_val_have_constructor(val):
                        # if it&#39;s a arg out and a class
                        if self.__get_is_type_class_or_pointer_with_class(val[&#34;conv&#34;]):
                                # find the constructor without arg
                                type_conv = None
                                for arg_conv in self._bound_types:
                                        if str(arg_conv.ctype) == str(val[&#34;conv&#34;].ctype):
                                                type_conv = arg_conv
                                                if hasattr(arg_conv, &#34;constructor&#34;) and arg_conv.constructor is not None:
                                                        proto_args = self._build_protos(
                                                                arg_conv.constructor[&#34;protos&#34;])
                                                        break
                                else:
                                        proto_args = None

                                # if no proto constructor with no args, add one
                                if proto_args is None and type_conv is not None:
                                        self.bind_constructor(type_conv, [])

                # check all protos
                protos = self._build_protos(method[&#34;protos&#34;])
                for proto in protos:
                        # convert arg in to c
                        if len(proto[&#34;args&#34;]):
                                for arg in proto[&#34;args&#34;]:
                                        # if arg out only, declare this value
                                        if &#34;arg_out&#34; in proto[&#34;features&#34;] and str(arg[&#34;carg&#34;].name) in proto[&#34;features&#34;][&#34;arg_out&#34;]:
                                                if arg[&#34;carg&#34;].ctype.is_pointer() or (hasattr(arg[&#34;carg&#34;].ctype, &#34;ref&#34;) and arg[&#34;carg&#34;].ctype.ref == &#34;&amp;&#34;):
                                                        check_if_val_have_constructor(arg)

        # returns the header code to the binder
        def _write_header(self):
                # .h
                rust_h = &#39;#pragma once\n&#39; \
                        &#39;#ifdef __cplusplus\n&#39;\
                        &#39;extern &#34;C&#34; {\n&#39;\
                        &#39;#endif\n&#39;

                rust_h += &#39;#include &lt;stdint.h&gt;\n&#39; \
                        &#39;#include &lt;stdbool.h&gt;\n&#39; \
                        &#39;#include &lt;stddef.h&gt;\n&#39; \
                        &#39;#include &lt;memory.h&gt;\n&#39; \
                        &#39;#include &lt;string.h&gt;\n&#39; \
                        &#39;#include &lt;stdlib.h&gt;\n&#39; \
                        &#39;#include &#34;fabgen.h&#34;\n\n&#39;

                # enum
                for bound_name, enum in self._enums.items():
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                arg_bound_name = str(enum_conv.base_type)
                        else:
                                arg_bound_name = &#34;int&#34;

                        rust_h += f&#34;extern {arg_bound_name} Get{bound_name}(const int id);\n&#34;

                # write all typedef first
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        cleanBoundName = clean_name_with_title(conv.bound_name)
                        if self.__get_is_type_class_or_pointer_with_class(conv):
                                rust_h += f&#34;typedef void* {clean_name_with_title(self._name)}{cleanBoundName};\n&#34;

                        if &#34;RustStdFunctionConverter&#34; in str(conv):
                                func_name = conv.base_type.replace(&#34;std::function&lt;&#34;, &#34;&#34;).replace(
                                        &#34;&amp;&#34;, &#34;*&#34;)[:-1]  # [:-1] to remove the &gt; of std::function
                                first_parenthesis = func_name.find(&#34;(&#34;)
                                # get all args boundname in c
                                args = func_name[first_parenthesis+1:-1].split(&#34;,&#34;)
                                args_boundname = []
                                for arg in args:
                                        if len(arg):
                                                ctype = parse(arg, gen._CType)
                                                conv = self.select_ctype_conv(ctype)
                                                args_boundname.append(self.__get_arg_bound_name_to_c(
                                                        {&#34;conv&#34;: conv, &#34;carg&#34;: type(&#39;carg&#39;, (object,), {&#39;ctype&#39;: ctype})()}))

                                rust_h += f&#34;typedef {func_name[:first_parenthesis]} (*{clean_name_with_title(self._name)}{cleanBoundName})({&#39;,&#39;.join(args_boundname)});\n&#34;

                # write the rest of the classes
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        cleanBoundName = clean_name_with_title(conv.bound_name)

                        if &#34;sequence&#34; in conv._features:
                                rust_h += self.__extract_sequence(conv, is_in_header=True)

                        # static members
                        rust_h += self.extract_conv_and_bases(conv.static_members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member, static=True, is_in_header=True),
                                                                                                  [base_class.static_members for base_class in conv._bases])

                        # members
                        rust_h += self.extract_conv_and_bases(conv.members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member, is_in_header=True),
                                                                                                  [base_class.members for base_class in conv._bases])

                        # constructors
                        if conv.constructor:
                                rust_h += self.__extract_method(cleanBoundName, conv, conv.constructor,
                                                                                                bound_name=f&#34;constructor_{conv.bound_name}&#34;, is_in_header=True, is_global=True, is_constructor=True)

                        # destructor for all type class
                        if self.__get_is_type_class_or_pointer_with_class(conv):
                                rust_h += f&#34;extern void {clean_name_with_title(self._name)}{cleanBoundName}Free({clean_name_with_title(self._name)}{cleanBoundName});\n&#34;

                        # arithmetic operators
                        rust_h += self.extract_conv_and_bases(conv.arithmetic_ops,
                                                                                                  lambda arithmetic: self.__extract_method(
                                                                                                          conv.bound_name, conv, arithmetic, is_in_header=True, name=arithmetic[&#39;op&#39;], bound_name=gen.get_clean_symbol_name(arithmetic[&#39;op&#39;])),
                                                                                                  [base_class.arithmetic_ops for base_class in conv._bases])

                        # comparison_ops
                        rust_h += self.extract_conv_and_bases(conv.comparison_ops,
                                                                                                  lambda comparison: self.__extract_method(
                                                                                                          conv.bound_name, conv, comparison, is_in_header=True, name=comparison[&#39;op&#39;], bound_name=gen.get_clean_symbol_name(comparison[&#39;op&#39;])),
                                                                                                  [base_class.comparison_ops for base_class in conv._bases])

                        # static methods
                        rust_h += self.extract_conv_and_bases(conv.static_methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method, static=True, is_in_header=True),
                                                                                                  [base_class.static_methods for base_class in conv._bases])
                        # methods
                        rust_h += self.extract_conv_and_bases(conv.methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method, is_in_header=True),
                                                                                                  [base_class.methods for base_class in conv._bases])

                # functions
                for func in self._bound_functions:
                        rust_h += self.__extract_method(&#34;&#34;, None, func,
                                                                                        name=func[&#34;name&#34;], is_global=True, is_in_header=True)

                # global variables
                for var in self._bound_variables:
                        rust_h += self.__extract_get_set_member(
                                &#34;&#34;, None, var, is_global=True, is_in_header=True)

                rust_h += &#39;#ifdef __cplusplus\n&#39; \
                        &#39;}\n&#39; \
                        &#39;#endif\n&#39;
                return rust_h

        # returns the c code for the wrapper
        def _write_C_code(self):
                rust_c = &#39;// rust wrapper c\n&#39; \
                        &#39;#include \&#34;wrapper.h\&#34;\n&#39; \
                        &#39;#include &lt;memory&gt;\n&#39;

                if len(self._FABGen__system_includes) &gt; 0:
                        rust_c += &#34;&#34;.join([&#39;#include &#34;%s&#34;\n\n&#39; %
                                                          path for path in self._FABGen__system_includes])
                if len(self._FABGen__user_includes) &gt; 0:
                        rust_c += &#34;&#34;.join([&#39;#include &#34;%s&#34;\n\n&#39; %
                                                          path for path in self._FABGen__user_includes])

                rust_c += self._source

                # enum
                for bound_name, enum in self._enums.items():
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;base_type&#34;) and enum_conv.base_type is not None:
                                arg_bound_name = str(enum_conv.base_type)
                        else:
                                arg_bound_name = &#34;int&#34;

                        enum_vars = []
                        for name, value in enum.items():
                                enum_vars.append(f&#34;({arg_bound_name}){value}&#34;)
                        rust_c += f&#34;static const {arg_bound_name} {clean_name_with_title(self._name)}{bound_name} [] = {{ {&#39;, &#39;.join(enum_vars)} }};\n&#34;
                        rust_c += f&#34;{arg_bound_name} Get{bound_name}(const int id) {{ return {clean_name_with_title(self._name)}{bound_name}[id];}}\n&#34;

                #  classes
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        cleanBoundName = clean_name_with_title(conv.bound_name)
                        if conv.is_type_class():
                                rust_c += f&#34;// bind {clean_name_with_title(self._name)}{cleanBoundName} methods\n&#34;

                        if &#34;sequence&#34; in conv._features:
                                rust_c += self.__extract_sequence(conv)

                        # static members
                        rust_c += self.extract_conv_and_bases(conv.static_members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member, static=True),
                                                                                                  [base_class.static_members for base_class in conv._bases])

                        # members
                        rust_c += self.extract_conv_and_bases(conv.members,
                                                                                                  lambda member: self.__extract_get_set_member(
                                                                                                          conv.bound_name, conv, member),
                                                                                                  [base_class.members for base_class in conv._bases])

                        # constructors
                        if conv.constructor:
                                rust_c += self.__extract_method(conv.bound_name, conv, conv.constructor,
                                                                                                bound_name=f&#34;constructor_{conv.bound_name}&#34;, is_global=True, is_constructor=True)

                        # destructor for all type class
                        if self.__get_is_type_class_or_pointer_with_class(conv):
                                # delete
                                rust_c += f&#34;void {clean_name_with_title(self._name)}{cleanBoundName}Free({clean_name_with_title(self._name)}{cleanBoundName} h){{&#34; \
                                        f&#34;delete ({conv.ctype}*)h;&#34; \
                                        f&#34;}}\n&#34;

                        # arithmetic operators
                        rust_c += self.extract_conv_and_bases(conv.arithmetic_ops,
                                                                                                  lambda arithmetic: self.__extract_method(conv.bound_name, conv, arithmetic, name=arithmetic[&#39;op&#39;], bound_name=gen.get_clean_symbol_name(
                                                                                                          arithmetic[&#39;op&#39;]), overload_op=arithmetic[&#34;op&#34;]),
                                                                                                  [base_class.arithmetic_ops for base_class in conv._bases])

                        # comparison_ops
                        rust_c += self.extract_conv_and_bases(conv.comparison_ops,
                                                                                                  lambda comparison: self.__extract_method(conv.bound_name, conv, comparison, name=comparison[&#34;op&#34;], bound_name=gen.get_clean_symbol_name(
                                                                                                          comparison[&#34;op&#34;]), overload_op=comparison[&#34;op&#34;]),
                                                                                                  [base_class.comparison_ops for base_class in conv._bases])

                        # static methods
                        rust_c += self.extract_conv_and_bases(conv.static_methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method, static=True),
                                                                                                  [base_class.static_methods for base_class in conv._bases])
                        # methods
                        rust_c += self.extract_conv_and_bases(conv.methods,
                                                                                                  lambda method: self.__extract_method(
                                                                                                          conv.bound_name, conv, method),
                                                                                                  [base_class.methods for base_class in conv._bases])

                # functions
                for func in self._bound_functions:
                        rust_c += self.__extract_method(&#34;&#34;, None,
                                                                                        func, name=func[&#34;name&#34;], is_global=True)

                # global variables
                for var in self._bound_variables:
                        rust_c += self.__extract_get_set_member(
                                &#34;&#34;, None, var, is_global=True, static=True)
                return rust_c

        def _write_rust_enums(self):
                rust_bind = f&#34;// {self._name} enums ...\n&#34;
                for bound_name, enum in self._enums.items():
                        rust_bind += f&#34;// {bound_name} ...\n&#34;
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;rust_type&#34;) and enum_conv.rust_type is not None:
                                arg_bound_name = enum_conv.rust_type
                        else:
                                arg_bound_name = &#34;i32&#34;
                        rust_bind += f&#34;type {bound_name} = {arg_bound_name};\n&#34;
                return rust_bind

        def _write_rust_extern(self):
                rust_bind = f&#34;#[link(name = \&#34;{self._name}\&#34;)]\n&#34;
                rust_bind += &#34;extern \&#34;C\&#34; { \n\n&#34;

                for type in self._bound_types:
                        if type.nobind:
                                continue
                        if type.is_type_class():
                                rust_bind += f&#34;// bind {clean_name_with_title(self._name)}{clean_name_with_title(type.bound_name)} methods\n&#34;

                        # constructors
                        if type.constructor:
                                rust_bind += self.__extract_method_rust(type.bound_name, type, type.constructor,
                                                                                                                bound_name=f&#34;{type.bound_name}&#34;, is_global=True, is_constructor=True)

                        # static members
                        rust_bind += self.extract_conv_and_bases(type.static_members,
                                                                                                         lambda member: self.__extract_get_set_member_rust(
                                                                                                                 type.bound_name, member, static=True),
                                                                                                         [base_class.static_members for base_class in type._bases])

                        # members
                        rust_bind += self.extract_conv_and_bases(type.members,
                                                                                                         lambda member: self.__extract_get_set_member_rust(
                                                                                                                 type.bound_name, member, static=False),
                                                                                                         [base_class.members for base_class in type._bases])

                        # arithmetic operators
                        rust_bind += self.extract_conv_and_bases(type.arithmetic_ops,
                                                                                                         lambda arithmetic: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, arithmetic, bound_name=gen.get_clean_symbol_name(arithmetic[&#39;op&#39;])),
                                                                                                         [base_class.arithmetic_ops for base_class in type._bases])
                        # comparison_ops
                        rust_bind += self.extract_conv_and_bases(type.comparison_ops,
                                                                                                         lambda comparison: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, comparison, bound_name=gen.get_clean_symbol_name(comparison[&#39;op&#39;])),
                                                                                                         [base_class.comparison_ops for base_class in type._bases])

                        # static methods
                        rust_bind += self.extract_conv_and_bases(type.static_methods,
                                                                                                         lambda method: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, method, static=True),
                                                                                                         [base_class.static_methods for base_class in type._bases])
                        # methods
                        rust_bind += self.extract_conv_and_bases(type.methods,
                                                                                                         lambda method: self.__extract_method_rust(
                                                                                                                 type.bound_name, type, method),
                                                                                                         [base_class.methods for base_class in type._bases])

                # functions
                for func in self._bound_functions:
                        rust_bind += self.__extract_method_signature_rust(
                                &#34;&#34;, None, func, is_global=True)

                # global variables
                # sort by group if needed
                bound_variables_groups = {}
                for var in self._bound_variables:
                        if &#34;group&#34; in var and var[&#34;group&#34;] is not None:
                                group_name = clean_name_with_title(var[&#34;group&#34;])
                                if group_name not in bound_variables_groups:
                                        bound_variables_groups[group_name] = []
                                bound_variables_groups[group_name].append(var)

                # add bound variables groups
                for group_name, var_group in bound_variables_groups.items():
                        rust_bind += f&#34;// {group_name} ...\n&#34;
                        var_conv = self.select_ctype_conv(var_group[0][&#34;ctype&#34;])
                        if var_conv is not None and hasattr(var_conv, &#34;rust_type&#34;) and var_conv.rust_type is not None:
                                rust_bind += f&#34;type {group_name} {var_conv.rust_type}\n&#34;
                        else:
                                rust_bind += f&#34;type {group_name} int\n&#34;

                        for id, var in enumerate(var_group):
                                rust_bind += self.__extract_get_set_member_rust(
                                        &#34;&#34;, var, is_global=True, implicit_cast=group_name)

                # add bound variables without group
                for var in self._bound_variables:
                        if &#34;group&#34; not in var or var[&#34;group&#34;] is None:
                                rust_bind += self.__extract_get_set_member_rust(
                                        &#34;&#34;, var, is_global=True)

                for bound_name, enum in self._enums.items():
                        rust_bind += f&#34;// {bound_name} ...\n&#34;
                        enum_conv = self._get_conv_from_bound_name(bound_name)
                        if enum_conv is not None and hasattr(enum_conv, &#34;rust_type&#34;) and enum_conv.rust_type is not None:
                                arg_bound_name = enum_conv.rust_type
                        else:
                                arg_bound_name = &#34;i32&#34;
                                #enums are the only methods that aren&#39;t using the _name prefix, it doesn&#39;t work if you add them, i have no idea why
                        rust_bind += f&#34;pub fn Get{bound_name}(id : {arg_bound_name}) -&gt; {bound_name};\n&#34;
                        

                rust_bind += &#34;}\n&#34;
                return rust_bind

        def _write_rust_binder_header(self):
                rust_bind = f&#39;// This Crate was automatically generated by FABGen\n&#39; \
                        &#39;// Do not modify this file manually\n\n&#39;
                rust_bind += self.rust_directives
                rust_bind += &#39;use std::ffi::c_void;\n&#39;
                with open(&#34;lib/rust/WrapperConverter.rs_&#34;, &#34;r&#34;) as file:
                        lines = file.readlines()
                        rust_bind += &#34;&#34;.join(lines)
                        rust_bind += &#34;\n&#34;

                return rust_bind

        # helper to add from itself and from parent class
        def extract_conv_and_bases(self, convs_to_extract, extract_func, bases_convs_to_extract):
                rust = &#34;&#34;
                saved_names = []
                for conv_to_extract in convs_to_extract:
                        if &#34;name&#34; in conv_to_extract:
                                saved_names.append(conv_to_extract[&#34;name&#34;])
                        elif &#34;op&#34; in conv_to_extract:
                                saved_names.append(conv_to_extract[&#34;op&#34;])
                        rust += extract_func(conv_to_extract)
                # add static member get set for base class
                for base_convs_to_extract in bases_convs_to_extract:
                        for conv_to_extract in base_convs_to_extract:
                                # add only if it&#39;s not already in the current class
                                n = &#34;&#34;
                                if &#34;name&#34; in conv_to_extract:
                                        n = conv_to_extract[&#34;name&#34;]
                                elif &#34;op&#34; in conv_to_extract:
                                        n = conv_to_extract[&#34;op&#34;]
                                if n not in saved_names:
                                        saved_names.append(n)
                                        rust += extract_func(conv_to_extract)
                return rust

        def bind_method_translate(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False):
                if bound_name is None:
                        bound_name = method[&#34;bound_name&#34;]
                if name is None:
                        name = bound_name

                name_rust = name
                if is_constructor:
                        name_rust = &#34;new_&#34; + name_rust

                protos = self._build_protos(method[&#34;protos&#34;])
                return_protos_name = []
                for id_proto, proto in enumerate(protos):
                        method_name_rust = f&#34;{clean_name_with_title(name_rust)}&#34;

                        # add bounding_name to the overload function
                        if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                                method_name_rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                        # if automatic suffix generated
                        elif &#34;suggested_suffix&#34; in proto:
                                method_name_rust += proto[&#34;suggested_suffix&#34;]

                        return_protos_name.append(method_name_rust)
                return name, return_protos_name

        def _write_json_translate(self):
                rust_translate_file = {}

                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        rust_translate_file[conv.bound_name] = {
                                &#34;name&#34;: clean_name_with_title(conv.bound_name)}

                        # members
                        members = {}
                        for member in conv.static_members + conv.members:
                                bound_name = None
                                if &#34;bound_name&#34; in member:
                                        bound_name = str(member[&#34;bound_name&#34;])
                                elif bound_name is None:
                                        bound_name = str(member[&#34;name&#34;])

                                name = bound_name.replace(&#34;:&#34;, &#34;&#34;)
                                name = clean_name_with_title(name)
                                members[bound_name] = [f&#34;Get{name}&#34;, f&#34;Set{name}&#34;]

                        if len(members):
                                rust_translate_file[conv.bound_name][&#34;members&#34;] = members

                        # functions
                        functions = {}

                        # constructors
                        if conv.constructor:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, conv.constructor, bound_name=f&#34;{conv.bound_name}&#34;, is_global=True, is_constructor=True)
                                functions[name] = protos_name

                        for method in conv.static_methods + conv.methods:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, method)
                                functions[name] = protos_name

                        for arithmetic in conv.arithmetic_ops:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, arithmetic, bound_name=gen.get_clean_symbol_name(arithmetic[&#39;op&#39;]))
                                functions[name] = protos_name
                        for comparison in conv.comparison_ops:
                                name, protos_name = self.bind_method_translate(
                                        conv.bound_name, conv, comparison, bound_name=gen.get_clean_symbol_name(comparison[&#39;op&#39;]))
                                functions[name] = protos_name

                        if len(functions):
                                rust_translate_file[conv.bound_name][&#34;functions&#34;] = functions

                # enum
                for bound_name, enum in self._enums.items():
                        rust_translate_file[bound_name] = bound_name
                # rust_bind += &#34;var (\n&#34;
                        for id, name in enumerate(enum.keys()):
                                rust_translate_file[name] = clean_name(name)

                # functions
                for func in self._bound_functions:
                        name, protos_name = self.bind_method_translate(
                                &#34;&#34;, None, func, is_global=True)
                        rust_translate_file[name] = protos_name

                # global variables
                for member in self._bound_variables:
                        bound_name = None
                        if &#34;bound_name&#34; in member:
                                bound_name = str(member[&#34;bound_name&#34;])
                        elif bound_name is None:
                                bound_name = str(member[&#34;name&#34;])

                        name = bound_name.replace(&#34;:&#34;, &#34;&#34;)
                        name = clean_name_with_title(name)
                        rust_translate_file[bound_name] = [f&#34;Get{name}&#34;, f&#34;Set{name}&#34;]

        def _write_rust_struct(self):
                rust_struct = &#34;&#34;

                for conv in self._bound_types:
                        if conv.nobind:
                                continue
                        if conv.is_type_class():
                                rust_struct += f&#34;pub type {clean_name_with_title(conv.bound_name)} = c_void;\n\n&#34;
                return rust_struct

        def finalize(self):

                # add class global
                for conv in self._bound_types:
                        if conv.nobind:
                                continue

                        if conv.is_type_class():
                                # add equal of deep copy
                                if conv._supports_deep_compare:
                                        rust = &#34;&#34;
                                        if &#34;proxy&#34; in conv._features:
                                                rust += f&#34;bool _{conv.bound_name}_Equal({conv.ctype} *a, {conv.ctype} *b){{\n&#34;
                                                rust += f&#34;      auto cast_a = _type_tag_cast(a, {conv.type_tag}, {conv._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;
                                                rust += f&#34;      auto cast_b = _type_tag_cast(b, {conv.type_tag}, {conv._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;

                                                wrapped_conv = conv._features[&#34;proxy&#34;].wrapped_conv
                                                if wrapped_conv.is_type_class():
                                                        rust += f&#34;      return ({wrapped_conv.bound_name}*)cast_a == ({wrapped_conv.bound_name}*)cast_b;\n&#34;
                                                else:
                                                        # check the convert from the base (in case of ptr)
                                                        if wrapped_conv.ctype.is_pointer() or (hasattr(wrapped_conv.ctype, &#34;ref&#34;) and any(s in wrapped_conv.ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])):
                                                                base_conv = self._get_conv(
                                                                        str(wrapped_conv.ctype.scoped_typename))
                                                                if base_conv is None:
                                                                        type_bound_name = str(
                                                                                wrapped_conv.bound_name)
                                                                else:
                                                                        type_bound_name = str(base_conv.ctype)
                                                        else:
                                                                type_bound_name = str(wrapped_conv.ctype)
                                                        rust += f&#34;      return ({type_bound_name}*)cast_a == ({type_bound_name}*)cast_b;\n&#34;
                                        else:
                                                rust += f&#34;bool _{conv.bound_name}_Equal({conv.bound_name} *a, {conv.bound_name} *b){{\n&#34;
                                                rust += f&#34;      return *a == *b;\n&#34;
                                        rust += &#34;}\n&#34;

                                        self.insert_code(rust)
                                        if &#34;proxy&#34; in conv._features:
                                                self.bind_method(conv, &#34;Equal&#34;, &#34;bool&#34;, [
                                                                                 f&#34;{conv.ctype} *b&#34;], {&#34;route&#34;: route_lambda(f&#34;_{conv.bound_name}_Equal&#34;)})
                                        else:
                                                self.bind_method(conv, &#34;Equal&#34;, &#34;bool&#34;, [
                                                                                 f&#34;{conv.bound_name} *b&#34;], {&#34;route&#34;: route_lambda(f&#34;_{conv.bound_name}_Equal&#34;)})

                                # VERY SPECIAL
                                # check in every methods,
                                # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
                                for method in conv.static_methods+conv.methods:
                                        self._check_arg_out_add_constructor_if_needed(method)

                        # add down cast
                        for base in conv._bases:
                                self.add_cast(base, conv, lambda in_var, out_var: &#34;%s = (%s *)((%s *)%s);\n&#34; %
                                                          (out_var, conv.ctype, base.ctype, in_var))

                # VERY SPECIAL
                # check in every methods,
                # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
                for func in self._FABGen__function_declarations.values():
                        self._check_arg_out_add_constructor_if_needed(func)

                super().finalize()

                self.output_binding_api()

                self.rust_h = self._write_header()
                self.rust_c = self._write_C_code()
                self.rust_bind = self._write_rust_binder_header()
                self.rust_bind += self._write_rust_struct()
                self.rust_bind += self._write_rust_enums()
                self.rust_bind += self._write_rust_extern()
                self.rust_translate_file = json.dumps(
                        self._write_json_translate(), indent=4, sort_keys=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gen.FABGen</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="rust.RustGenerator.default_class_converter"><code class="name">var <span class="ident">default_class_converter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rust.RustGenerator.default_extern_converter"><code class="name">var <span class="ident">default_extern_converter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rust.RustGenerator.default_ptr_converter"><code class="name">var <span class="ident">default_ptr_converter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rust.RustGenerator.bind_method_translate"><code class="name flex">
<span>def <span class="ident">bind_method_translate</span></span>(<span>self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind_method_translate(self, classname, convClass, method, static=False, name=None, bound_name=None, is_global=False, is_constructor=False):
        if bound_name is None:
                bound_name = method[&#34;bound_name&#34;]
        if name is None:
                name = bound_name

        name_rust = name
        if is_constructor:
                name_rust = &#34;new_&#34; + name_rust

        protos = self._build_protos(method[&#34;protos&#34;])
        return_protos_name = []
        for id_proto, proto in enumerate(protos):
                method_name_rust = f&#34;{clean_name_with_title(name_rust)}&#34;

                # add bounding_name to the overload function
                if &#34;bound_name&#34; in proto[&#34;features&#34;]:
                        method_name_rust += proto[&#34;features&#34;][&#34;bound_name&#34;]
                # if automatic suffix generated
                elif &#34;suggested_suffix&#34; in proto:
                        method_name_rust += proto[&#34;suggested_suffix&#34;]

                return_protos_name.append(method_name_rust)
        return name, return_protos_name</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.close_proxy"><code class="name flex">
<span>def <span class="ident">close_proxy</span></span>(<span>self, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_proxy(self, ctx):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.commit_from_c_vars"><code class="name flex">
<span>def <span class="ident">commit_from_c_vars</span></span>(<span>self, rvals, ctx='default')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit_from_c_vars(self, rvals, ctx=&#34;default&#34;):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.extract_conv_and_bases"><code class="name flex">
<span>def <span class="ident">extract_conv_and_bases</span></span>(<span>self, convs_to_extract, extract_func, bases_convs_to_extract)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_conv_and_bases(self, convs_to_extract, extract_func, bases_convs_to_extract):
        rust = &#34;&#34;
        saved_names = []
        for conv_to_extract in convs_to_extract:
                if &#34;name&#34; in conv_to_extract:
                        saved_names.append(conv_to_extract[&#34;name&#34;])
                elif &#34;op&#34; in conv_to_extract:
                        saved_names.append(conv_to_extract[&#34;op&#34;])
                rust += extract_func(conv_to_extract)
        # add static member get set for base class
        for base_convs_to_extract in bases_convs_to_extract:
                for conv_to_extract in base_convs_to_extract:
                        # add only if it&#39;s not already in the current class
                        n = &#34;&#34;
                        if &#34;name&#34; in conv_to_extract:
                                n = conv_to_extract[&#34;name&#34;]
                        elif &#34;op&#34; in conv_to_extract:
                                n = conv_to_extract[&#34;op&#34;]
                        if n not in saved_names:
                                saved_names.append(n)
                                rust += extract_func(conv_to_extract)
        return rust</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.finalize"><code class="name flex">
<span>def <span class="ident">finalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finalize(self):

        # add class global
        for conv in self._bound_types:
                if conv.nobind:
                        continue

                if conv.is_type_class():
                        # add equal of deep copy
                        if conv._supports_deep_compare:
                                rust = &#34;&#34;
                                if &#34;proxy&#34; in conv._features:
                                        rust += f&#34;bool _{conv.bound_name}_Equal({conv.ctype} *a, {conv.ctype} *b){{\n&#34;
                                        rust += f&#34;      auto cast_a = _type_tag_cast(a, {conv.type_tag}, {conv._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;
                                        rust += f&#34;      auto cast_b = _type_tag_cast(b, {conv.type_tag}, {conv._features[&#39;proxy&#39;].wrapped_conv.type_tag});\n&#34;

                                        wrapped_conv = conv._features[&#34;proxy&#34;].wrapped_conv
                                        if wrapped_conv.is_type_class():
                                                rust += f&#34;      return ({wrapped_conv.bound_name}*)cast_a == ({wrapped_conv.bound_name}*)cast_b;\n&#34;
                                        else:
                                                # check the convert from the base (in case of ptr)
                                                if wrapped_conv.ctype.is_pointer() or (hasattr(wrapped_conv.ctype, &#34;ref&#34;) and any(s in wrapped_conv.ctype.ref for s in [&#34;&amp;&#34;, &#34;*&#34;])):
                                                        base_conv = self._get_conv(
                                                                str(wrapped_conv.ctype.scoped_typename))
                                                        if base_conv is None:
                                                                type_bound_name = str(
                                                                        wrapped_conv.bound_name)
                                                        else:
                                                                type_bound_name = str(base_conv.ctype)
                                                else:
                                                        type_bound_name = str(wrapped_conv.ctype)
                                                rust += f&#34;      return ({type_bound_name}*)cast_a == ({type_bound_name}*)cast_b;\n&#34;
                                else:
                                        rust += f&#34;bool _{conv.bound_name}_Equal({conv.bound_name} *a, {conv.bound_name} *b){{\n&#34;
                                        rust += f&#34;      return *a == *b;\n&#34;
                                rust += &#34;}\n&#34;

                                self.insert_code(rust)
                                if &#34;proxy&#34; in conv._features:
                                        self.bind_method(conv, &#34;Equal&#34;, &#34;bool&#34;, [
                                                                         f&#34;{conv.ctype} *b&#34;], {&#34;route&#34;: route_lambda(f&#34;_{conv.bound_name}_Equal&#34;)})
                                else:
                                        self.bind_method(conv, &#34;Equal&#34;, &#34;bool&#34;, [
                                                                         f&#34;{conv.bound_name} *b&#34;], {&#34;route&#34;: route_lambda(f&#34;_{conv.bound_name}_Equal&#34;)})

                        # VERY SPECIAL
                        # check in every methods,
                        # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
                        for method in conv.static_methods+conv.methods:
                                self._check_arg_out_add_constructor_if_needed(method)

                # add down cast
                for base in conv._bases:
                        self.add_cast(base, conv, lambda in_var, out_var: &#34;%s = (%s *)((%s *)%s);\n&#34; %
                                                  (out_var, conv.ctype, base.ctype, in_var))

        # VERY SPECIAL
        # check in every methods,
        # if one arg is only out and if it&#39;s a class, if there is a constructor with no arg
        for func in self._FABGen__function_declarations.values():
                self._check_arg_out_add_constructor_if_needed(func)

        super().finalize()

        self.output_binding_api()

        self.rust_h = self._write_header()
        self.rust_c = self._write_C_code()
        self.rust_bind = self._write_rust_binder_header()
        self.rust_bind += self._write_rust_struct()
        self.rust_bind += self._write_rust_enums()
        self.rust_bind += self._write_rust_extern()
        self.rust_translate_file = json.dumps(
                self._write_json_translate(), indent=4, sort_keys=True)</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.get_binding_api_declaration"><code class="name flex">
<span>def <span class="ident">get_binding_api_declaration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def get_binding_api_declaration(self):
                type_info_name = gen.apply_api_prefix(&#34;type_info&#34;)

                out = &#39;&#39;&#39;\
struct %s {
        uint32_t type_tag;
        const char *c_type;
        const char *bound_name;

        bool (*check)(void* p);
        void (*to_c)(void *p, void *out);
        int (*from_c)(void *obj, OwnershipPolicy policy);
};\n
&#39;&#39;&#39; % type_info_name

                out += &#34;// return a type info from its type tag\n&#34;
                out += &#34;%s *%s(uint32_t type_tag);\n&#34; % (type_info_name,
                                                                                                 gen.apply_api_prefix(&#34;get_bound_type_info&#34;))

                out += &#34;// return a type info from its type name\n&#34;
                out += &#34;%s *%s(const char *type);\n&#34; % (type_info_name,
                                                                                                gen.apply_api_prefix(&#34;get_c_type_info&#34;))

                out += &#34;// returns the typetag of a userdata object, nullptr if not a Fabgen object\n&#34;
                out += &#34;uint32_t %s(void* p);\n\n&#34; % gen.apply_api_prefix(
                        &#34;get_wrapped_object_type_tag&#34;)

                return out</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.get_language"><code class="name flex">
<span>def <span class="ident">get_language</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_language(self):
        return &#34;Rust&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.get_output"><code class="name flex">
<span>def <span class="ident">get_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output(self):
        return {&#34;wrapper.cpp&#34;: self.rust_c, &#34;wrapper.h&#34;: self.rust_h, &#34;bind.rs&#34;: self.rust_bind, &#34;translate_file.json&#34;: self.rust_translate_file}</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.get_self"><code class="name flex">
<span>def <span class="ident">get_self</span></span>(<span>self, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_self(self, ctx):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.get_var"><code class="name flex">
<span>def <span class="ident">get_var</span></span>(<span>self, i, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_var(self, i, ctx):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.open_proxy"><code class="name flex">
<span>def <span class="ident">open_proxy</span></span>(<span>self, name, max_arg_count, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_proxy(self, name, max_arg_count, ctx):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.output_binding_api"><code class="name flex">
<span>def <span class="ident">output_binding_api</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">        def output_binding_api(self):
                type_info_name = gen.apply_api_prefix(&#34;type_info&#34;)
                self._source += &#34;&#34;&#34;\
%s *%s(uint32_t type_tag) {
        return nullptr;
}\n\n&#34;&#34;&#34; % (
                        type_info_name,
                        gen.apply_api_prefix(&#34;get_bound_type_info&#34;),
                )

                self._source += &#34;&#34;&#34;
%s *%s(const char *type) {
        return nullptr;
}\n\n&#34;&#34;&#34; % (
                        type_info_name,
                        gen.apply_api_prefix(&#34;get_c_type_info&#34;),
                )

                self._source += &#34;&#34;&#34;\
uint32_t %s(void* p) {
        return 0;
        //auto o = cast_to_wrapped_Object_safe(L, idx);
        //return o ? o-&gt;type_tag : 0;
}\n\n&#34;&#34;&#34; % gen.apply_api_prefix(&#34;get_wrapped_object_type_tag&#34;)</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.output_includes"><code class="name flex">
<span>def <span class="ident">output_includes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_includes(self):
        pass</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.proxy_call_error"><code class="name flex">
<span>def <span class="ident">proxy_call_error</span></span>(<span>self, msg, ctx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proxy_call_error(self, msg, ctx):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.rbind_function"><code class="name flex">
<span>def <span class="ident">rbind_function</span></span>(<span>self, name, rval, args, internal=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rbind_function(self, name, rval, args, internal=False):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.return_void_from_c"><code class="name flex">
<span>def <span class="ident">return_void_from_c</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_void_from_c(self):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.rval_from_c_ptr"><code class="name flex">
<span>def <span class="ident">rval_from_c_ptr</span></span>(<span>self, conv, out_var, expr, ownership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rval_from_c_ptr(self, conv, out_var, expr, ownership):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.rval_from_nullptr"><code class="name flex">
<span>def <span class="ident">rval_from_nullptr</span></span>(<span>self, out_var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rval_from_nullptr(self, out_var):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.set_compilation_directives"><code class="name flex">
<span>def <span class="ident">set_compilation_directives</span></span>(<span>self, directives)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compilation_directives(self, directives):
        self.rust_directives = directives</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.set_error"><code class="name flex">
<span>def <span class="ident">set_error</span></span>(<span>self, type, reason)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_error(self, type, reason):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustGenerator.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, module_name):
        super().start(module_name)

        self._source += self.get_binding_api_declaration()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rust.RustPtrTypeConverter"><code class="flex name class">
<span>class <span class="ident">RustPtrTypeConverter</span></span>
<span>(</span><span>type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RustPtrTypeConverter(gen.TypeConverter):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=False):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)

        def get_type_api(self, module_name):
                return &#34;&#34;

        def to_c_call(self, in_var, out_var_p, is_pointer):
                return &#34;&#34;

        def from_c_call(self, out_var, expr, ownership):
                return &#34;&#34;

        def check_call(self, in_var):
                return &#34;&#34;

        def get_type_glue(self, gen, module_name):
                return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gen.TypeConverter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rust.RustPtrTypeConverter.check_call"><code class="name flex">
<span>def <span class="ident">check_call</span></span>(<span>self, in_var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_call(self, in_var):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustPtrTypeConverter.from_c_call"><code class="name flex">
<span>def <span class="ident">from_c_call</span></span>(<span>self, out_var, expr, ownership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_c_call(self, out_var, expr, ownership):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustPtrTypeConverter.get_type_api"><code class="name flex">
<span>def <span class="ident">get_type_api</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_api(self, module_name):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustPtrTypeConverter.get_type_glue"><code class="name flex">
<span>def <span class="ident">get_type_glue</span></span>(<span>self, gen, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_glue(self, gen, module_name):
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="rust.RustPtrTypeConverter.to_c_call"><code class="name flex">
<span>def <span class="ident">to_c_call</span></span>(<span>self, in_var, out_var_p, is_pointer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_c_call(self, in_var, out_var_p, is_pointer):
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rust.RustTypeConverterCommon"><code class="flex name class">
<span>class <span class="ident">RustTypeConverterCommon</span></span>
<span>(</span><span>type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RustTypeConverterCommon(gen.TypeConverter):
        def __init__(self, type, to_c_storage_type=None, bound_name=None, from_c_storage_type=None, needs_c_storage_class=None):
                super().__init__(type, to_c_storage_type, bound_name,
                                                 from_c_storage_type, needs_c_storage_class)
                self.base_type = type
                self.rust_to_c_type = None
                self.rust_type = None

        def get_type_api(self, module_name):
                out = &#34;// type API for %s\n&#34; % self.ctype
                if self.c_storage_class:
                        out += &#34;struct %s;\n&#34; % self.c_storage_class
                if self.c_storage_class:
                        out += &#34;void %s(int idx, void *obj, %s &amp;storage);\n&#34; % (
                                self.to_c_func, self.c_storage_class)
                else:
                        out += &#34;void %s(int idx, void *obj);\n&#34; % self.to_c_func
                out += &#34;int %s(void *obj, OwnershipPolicy);\n&#34; % self.from_c_func
                out += &#34;\n&#34;
                return out

        def to_c_call(self, out_var, expr):
                return &#34;&#34;

        def from_c_call(self, out_var, expr, ownership):
                return &#34;%s((void *)%s, %s);\n&#34; % (self.from_c_func, expr, ownership)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gen.TypeConverter</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="rust.RustClassTypeDefaultConverter" href="#rust.RustClassTypeDefaultConverter">RustClassTypeDefaultConverter</a></li>
<li><a title="rust.RustExternTypeConverter" href="#rust.RustExternTypeConverter">RustExternTypeConverter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rust.RustTypeConverterCommon.from_c_call"><code class="name flex">
<span>def <span class="ident">from_c_call</span></span>(<span>self, out_var, expr, ownership)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_c_call(self, out_var, expr, ownership):
        return &#34;%s((void *)%s, %s);\n&#34; % (self.from_c_func, expr, ownership)</code></pre>
</details>
</dd>
<dt id="rust.RustTypeConverterCommon.get_type_api"><code class="name flex">
<span>def <span class="ident">get_type_api</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type_api(self, module_name):
        out = &#34;// type API for %s\n&#34; % self.ctype
        if self.c_storage_class:
                out += &#34;struct %s;\n&#34; % self.c_storage_class
        if self.c_storage_class:
                out += &#34;void %s(int idx, void *obj, %s &amp;storage);\n&#34; % (
                        self.to_c_func, self.c_storage_class)
        else:
                out += &#34;void %s(int idx, void *obj);\n&#34; % self.to_c_func
        out += &#34;int %s(void *obj, OwnershipPolicy);\n&#34; % self.from_c_func
        out += &#34;\n&#34;
        return out</code></pre>
</details>
</dd>
<dt id="rust.RustTypeConverterCommon.to_c_call"><code class="name flex">
<span>def <span class="ident">to_c_call</span></span>(<span>self, out_var, expr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_c_call(self, out_var, expr):
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="rust.clean_name" href="#rust.clean_name">clean_name</a></code></li>
<li><code><a title="rust.clean_name_with_title" href="#rust.clean_name_with_title">clean_name_with_title</a></code></li>
<li><code><a title="rust.route_lambda" href="#rust.route_lambda">route_lambda</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rust.DummyTypeConverter" href="#rust.DummyTypeConverter">DummyTypeConverter</a></code></h4>
<ul class="">
<li><code><a title="rust.DummyTypeConverter.check_call" href="#rust.DummyTypeConverter.check_call">check_call</a></code></li>
<li><code><a title="rust.DummyTypeConverter.from_c_call" href="#rust.DummyTypeConverter.from_c_call">from_c_call</a></code></li>
<li><code><a title="rust.DummyTypeConverter.get_type_api" href="#rust.DummyTypeConverter.get_type_api">get_type_api</a></code></li>
<li><code><a title="rust.DummyTypeConverter.get_type_glue" href="#rust.DummyTypeConverter.get_type_glue">get_type_glue</a></code></li>
<li><code><a title="rust.DummyTypeConverter.to_c_call" href="#rust.DummyTypeConverter.to_c_call">to_c_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rust.RustClassTypeDefaultConverter" href="#rust.RustClassTypeDefaultConverter">RustClassTypeDefaultConverter</a></code></h4>
<ul class="two-column">
<li><code><a title="rust.RustClassTypeDefaultConverter.check_call" href="#rust.RustClassTypeDefaultConverter.check_call">check_call</a></code></li>
<li><code><a title="rust.RustClassTypeDefaultConverter.from_c_call" href="#rust.RustClassTypeDefaultConverter.from_c_call">from_c_call</a></code></li>
<li><code><a title="rust.RustClassTypeDefaultConverter.get_type_api" href="#rust.RustClassTypeDefaultConverter.get_type_api">get_type_api</a></code></li>
<li><code><a title="rust.RustClassTypeDefaultConverter.get_type_glue" href="#rust.RustClassTypeDefaultConverter.get_type_glue">get_type_glue</a></code></li>
<li><code><a title="rust.RustClassTypeDefaultConverter.is_type_class" href="#rust.RustClassTypeDefaultConverter.is_type_class">is_type_class</a></code></li>
<li><code><a title="rust.RustClassTypeDefaultConverter.to_c_call" href="#rust.RustClassTypeDefaultConverter.to_c_call">to_c_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rust.RustExternTypeConverter" href="#rust.RustExternTypeConverter">RustExternTypeConverter</a></code></h4>
<ul class="">
<li><code><a title="rust.RustExternTypeConverter.check_call" href="#rust.RustExternTypeConverter.check_call">check_call</a></code></li>
<li><code><a title="rust.RustExternTypeConverter.from_c_call" href="#rust.RustExternTypeConverter.from_c_call">from_c_call</a></code></li>
<li><code><a title="rust.RustExternTypeConverter.get_type_api" href="#rust.RustExternTypeConverter.get_type_api">get_type_api</a></code></li>
<li><code><a title="rust.RustExternTypeConverter.get_type_glue" href="#rust.RustExternTypeConverter.get_type_glue">get_type_glue</a></code></li>
<li><code><a title="rust.RustExternTypeConverter.to_c_call" href="#rust.RustExternTypeConverter.to_c_call">to_c_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rust.RustGenerator" href="#rust.RustGenerator">RustGenerator</a></code></h4>
<ul class="">
<li><code><a title="rust.RustGenerator.bind_method_translate" href="#rust.RustGenerator.bind_method_translate">bind_method_translate</a></code></li>
<li><code><a title="rust.RustGenerator.close_proxy" href="#rust.RustGenerator.close_proxy">close_proxy</a></code></li>
<li><code><a title="rust.RustGenerator.commit_from_c_vars" href="#rust.RustGenerator.commit_from_c_vars">commit_from_c_vars</a></code></li>
<li><code><a title="rust.RustGenerator.default_class_converter" href="#rust.RustGenerator.default_class_converter">default_class_converter</a></code></li>
<li><code><a title="rust.RustGenerator.default_extern_converter" href="#rust.RustGenerator.default_extern_converter">default_extern_converter</a></code></li>
<li><code><a title="rust.RustGenerator.default_ptr_converter" href="#rust.RustGenerator.default_ptr_converter">default_ptr_converter</a></code></li>
<li><code><a title="rust.RustGenerator.extract_conv_and_bases" href="#rust.RustGenerator.extract_conv_and_bases">extract_conv_and_bases</a></code></li>
<li><code><a title="rust.RustGenerator.finalize" href="#rust.RustGenerator.finalize">finalize</a></code></li>
<li><code><a title="rust.RustGenerator.get_binding_api_declaration" href="#rust.RustGenerator.get_binding_api_declaration">get_binding_api_declaration</a></code></li>
<li><code><a title="rust.RustGenerator.get_language" href="#rust.RustGenerator.get_language">get_language</a></code></li>
<li><code><a title="rust.RustGenerator.get_output" href="#rust.RustGenerator.get_output">get_output</a></code></li>
<li><code><a title="rust.RustGenerator.get_self" href="#rust.RustGenerator.get_self">get_self</a></code></li>
<li><code><a title="rust.RustGenerator.get_var" href="#rust.RustGenerator.get_var">get_var</a></code></li>
<li><code><a title="rust.RustGenerator.open_proxy" href="#rust.RustGenerator.open_proxy">open_proxy</a></code></li>
<li><code><a title="rust.RustGenerator.output_binding_api" href="#rust.RustGenerator.output_binding_api">output_binding_api</a></code></li>
<li><code><a title="rust.RustGenerator.output_includes" href="#rust.RustGenerator.output_includes">output_includes</a></code></li>
<li><code><a title="rust.RustGenerator.proxy_call_error" href="#rust.RustGenerator.proxy_call_error">proxy_call_error</a></code></li>
<li><code><a title="rust.RustGenerator.rbind_function" href="#rust.RustGenerator.rbind_function">rbind_function</a></code></li>
<li><code><a title="rust.RustGenerator.return_void_from_c" href="#rust.RustGenerator.return_void_from_c">return_void_from_c</a></code></li>
<li><code><a title="rust.RustGenerator.rval_from_c_ptr" href="#rust.RustGenerator.rval_from_c_ptr">rval_from_c_ptr</a></code></li>
<li><code><a title="rust.RustGenerator.rval_from_nullptr" href="#rust.RustGenerator.rval_from_nullptr">rval_from_nullptr</a></code></li>
<li><code><a title="rust.RustGenerator.set_compilation_directives" href="#rust.RustGenerator.set_compilation_directives">set_compilation_directives</a></code></li>
<li><code><a title="rust.RustGenerator.set_error" href="#rust.RustGenerator.set_error">set_error</a></code></li>
<li><code><a title="rust.RustGenerator.start" href="#rust.RustGenerator.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rust.RustPtrTypeConverter" href="#rust.RustPtrTypeConverter">RustPtrTypeConverter</a></code></h4>
<ul class="">
<li><code><a title="rust.RustPtrTypeConverter.check_call" href="#rust.RustPtrTypeConverter.check_call">check_call</a></code></li>
<li><code><a title="rust.RustPtrTypeConverter.from_c_call" href="#rust.RustPtrTypeConverter.from_c_call">from_c_call</a></code></li>
<li><code><a title="rust.RustPtrTypeConverter.get_type_api" href="#rust.RustPtrTypeConverter.get_type_api">get_type_api</a></code></li>
<li><code><a title="rust.RustPtrTypeConverter.get_type_glue" href="#rust.RustPtrTypeConverter.get_type_glue">get_type_glue</a></code></li>
<li><code><a title="rust.RustPtrTypeConverter.to_c_call" href="#rust.RustPtrTypeConverter.to_c_call">to_c_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rust.RustTypeConverterCommon" href="#rust.RustTypeConverterCommon">RustTypeConverterCommon</a></code></h4>
<ul class="">
<li><code><a title="rust.RustTypeConverterCommon.from_c_call" href="#rust.RustTypeConverterCommon.from_c_call">from_c_call</a></code></li>
<li><code><a title="rust.RustTypeConverterCommon.get_type_api" href="#rust.RustTypeConverterCommon.get_type_api">get_type_api</a></code></li>
<li><code><a title="rust.RustTypeConverterCommon.to_c_call" href="#rust.RustTypeConverterCommon.to_c_call">to_c_call</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>